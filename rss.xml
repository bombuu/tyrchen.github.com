<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[觅珠人 | Tyr Chen的个人博客 | 创意 | 心得 | 经验]]></title>
        <description><![CDATA[本博客提供我个人的想法，创意，经验，心得。你不必认同博主观点。]]></description>
        <link>http://tchen.me</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Thu, 30 Jan 2014 02:20:35 GMT</lastBuildDate>
        <atom:link href="http://tchen.me/rss.xml" rel="self" type="application/rss+xml"/>
        <author><![CDATA[Tyr Chen]]></author>
        <pubDate>Thu, 30 Jan 2014 02:19:50 GMT</pubDate>
        <item>
            <title><![CDATA[Golang之chan/goroutine]]></title>
            <description><![CDATA[<p>最近在team内部培训golang，目标是看看golang能否被C工程师快速掌握。我定了个一个月，共计20小时的培训计划，首先花10个小时（两周，每天1小时）让大家掌握golang的基本要素，能写一些入门级的程序，之后再花两周时间做一个1000行代码规模的Proof of concept项目。为了能在培训的slides上直接运行go code，我做了个简单的 <a href="https://github.com/tyrchen/coderunnerd">coderunnerd</a>，可以接受websocket传过来的code，编译运行再把stdout返回给websocket，为了更清晰地说明goroutine和chan的使用，以及golang的一些best practice，我分阶段写了个 <a href="https://github.com/tyrchen/chatroom">chatroom</a>。本文介绍一下如何使用goroutine和chan来做一个简单的聊天室。</p>
<!-- more -->

<h2>需求</h2>
<p>聊天室的需求很简单：</p>
<ul>
<li>服务器监听某个端口，客户端可连接并开始聊天。</li>
<li>任何客户端的发言都会被广播给所有客户端。</li>
<li>客户端可以为自己设定名字或者执行一些聊天命令。</li>
</ul>
<h2>设计与实现</h2>
<h3>基本想法</h3>
<p>服务器（Server）：</p>
<ul>
<li>Server accept下来的connection被存在一个数据结构Client中，并以connection为key，Client为value，存在map里。</li>
<li>每个Client都有自己的goroutine去接受和发送消息。Client和Server之间通过channel来传递消息。</li>
</ul>
<p>客户端（Client）：</p>
<ul>
<li>发送和接收都有各自的goroutine，通过channel和stdin/stdout交互</li>
</ul>
<h3>实现</h3>
<p>所有chat相关的逻辑都被封装在 <code>chat</code> package里，client和server的cli只负责将ui和chat粘合起来。</p>
<p>首先，是核心的数据结构：</p>
<pre><code>type Message chan string

type Client struct {
    conn     net.Conn
    incoming Message
    outgoing Message
    reader   *bufio.Reader
    writer   *bufio.Writer
    quiting  chan net.Conn
    name     string
}</code></pre>
<p>Client 是一个服务器和客户端都共享的数据结构。conn是建立的连接，reader/writer是conn上的bufio。Client与外界的接口是incoming/outgoing两个channel，即：Server 会把要发送的内容 push 到 outgoing channel 里，供writer去写；而从reader读入的数据会 push 到 incoming channel 里，供 Server 读。</p>
<p>每个 Client 有自己的名字，服务器端代码会使用这个名字（客户端代码不会使用）。</p>
<pre><code>type Token chan int
type ClientTable map[net.Conn]*Client

type Server struct {
    listener net.Listener
    clients  ClientTable
    tokens   Token
    pending  chan net.Conn
    quiting  chan net.Conn
    incoming Message
    outgoing Message
}</code></pre>
<p>Server 保存一张 <code>ClientTable</code>。每个 accept 到的 conn 会 push 进 pending channel，等待创建client。Server有 incoming / outgoing 两个 channel，分别和 client 的 incoming / outgoing 关联。</p>
<p>Server 有一组 tokens，决定了一个Server最多能装多少Client（避免Server overloading）。</p>
<p>下面看 Server 的创建流程：</p>
<pre><code>const (
    MAXCLIENTS = 50
)

func CreateServer() *Server {
    server := &amp;Server{
        clients:  make(ClientTable, MAXCLIENTS),
        tokens:   make(Token, MAXCLIENTS),
        pending:  make(chan net.Conn),
        quiting:  make(chan net.Conn),
        incoming: make(Message),
        outgoing: make(Message),
    }
    server.listen()
    return server
}</code></pre>
<p>很简单，无须多说。<code>server.Listen()</code> 实现如下：</p>
<pre><code>func (self *Server) listen() {
    go func() {
        for {
            select {
            case message := &lt;-self.incoming:
                self.broadcast(message)
            case conn := &lt;-self.pending:
                self.join(conn)
            case conn := &lt;-self.quiting:
                self.leave(conn)
            }
        }
    }()
}</code></pre>
<p>这是一个 goroutine，做三件事：</p>
<ul>
<li>如果 <code>self.incoming</code> 收到东西，将其 broadcast 出去。</li>
<li>如果有新的连接，则将其接入到聊天室。</li>
<li>如果一个 Client 退出，则进行一些清理和通知。</li>
</ul>
<p>我们先看一个新连接如何加入到聊天室：</p>
<pre><code>func (self *Server) join(conn net.Conn) {
    client := CreateClient(conn)
    name := getUniqName()
    client.SetName(name)
    self.clients[conn] = client

    log.Printf(&quot;Auto assigned name for conn %p: %s\n&quot;, conn, name)

    go func() {
        for {
            msg := &lt;-client.incoming
            log.Printf(&quot;Got message: %s from client %s\n&quot;, msg, client.GetName())

            if strings.HasPrefix(msg, &quot;:&quot;) {
                if cmd, err := parseCommand(msg); err == nil {
                    if err = self.executeCommand(client, cmd); err == nil {
                        continue
                    } else {
                        log.Println(err.Error())
                    }
                } else {
                    log.Println(err.Error())
                }
            }
            // fallthrough to normal message if it is not parsable or executable
            self.incoming &lt;- fmt.Sprintf(&quot;%s says: %s&quot;, client.GetName(), msg)
        }
    }()

    go func() {
        for {
            conn := &lt;-client.quiting
            log.Printf(&quot;Client %s is quiting\n&quot;, client.GetName())
            self.quiting &lt;- conn
        }
    }()
}</code></pre>
<p>这里先通过连接建立 Client 数据，为其自动分配一个唯一的名字，然后将其加入到 <code>ClientTable</code> 中。注意在这个函数里每个 Client 会运行两个 goroutine，我们先记住这一点。</p>
<p>第一个 goroutine 从 Client 的 incoming channel 中拿出 message，如果是命令的话就执行之，否则将其放入 Server 的 incoming channel，等待被 broadcast 出去。之前 <code>Listen()</code> 方法里有对应的处理：</p>
<pre><code>            case message := &lt;-self.incoming:
                self.broadcast(message)</code></pre>
<p>顺手看一下 <code>broadcast</code> 怎么做的：</p>
<pre><code>func (self *Server) broadcast(message string) {
    log.Printf(&quot;Broadcasting message: %s\n&quot;, message)
    for _, client := range self.clients {
        client.outgoing &lt;- message
    }
}</code></pre>
<p>第二个 goroutine 从 Client 的 quiting channel 中拿出 conn，放入 Server 的 quiting channel 中，等待处理某个 Client 的退出。同样在 <code>Listen()</code> 中有处理：</p>
<pre><code>            case conn := &lt;-self.quiting:
                self.leave(conn)</code></pre>
<p>顺手也看看 <code>Leave</code> 做些什么：</p>
<pre><code>func (self *Server) leave(conn net.Conn) {
    if conn != nil {
        conn.Close()
        delete(self.clients, conn)
    }

    self.generateToken()
}</code></pre>
<p><code>Leave</code> 里有两个坑，一个是从 map 里删除一个 key 是否需要 synchronize，我们放在下面的『并发与同步』里详细再表；另一个坑是 <code>generateToken()</code>，马上就会讲到。</p>
<p>看了这么多代码了，还没看到服务器建连的代码，有点说不过去。接下来我们看 <code>Start</code>：</p>
<pre><code>func (self *Server) Start(connString string) {
    self.listener, _ = net.Listen(&quot;tcp&quot;, connString)

    log.Printf(&quot;Server %p starts\n&quot;, self)

    // filling the tokens
    for i := 0; i &lt; MAXCLIENTS; i++ {
        self.generateToken()
    }

    for {
        conn, err := self.listener.Accept()

        if err != nil {
            log.Println(err)
            return
        }

        log.Printf(&quot;A new connection %v kicks\n&quot;, conn)

        self.takeToken()
        self.pending &lt;- conn
    }
}</code></pre>
<p>这里 <code>generateToken</code> 及 <code>takeToken</code> 与 <code>Leave</code> 里的 <code>generateToken</code> 呼应。这些代码对应一个隐式需求：服务器不可过载。所以我们有 <code>MAXCLIENTS</code> 来限制一个服务器的 client 上限。但是，怎么比较漂亮地处理这个上限问题？因为在一个真实的聊天场景下，聊天室里的人是可以进进出出的。</p>
<p>我们采用 token。系统生成有限的 token，被拿光后，当且仅当有人归还 token，等待者才能获得 token，进入聊天室。在 golang 中，goroutine 和 chan 简直是为此需求量身定制的。我们看运作机制：</p>
<ul>
<li>首先生成 MAXCLIENTS 个 token。</li>
<li>第 1 - MAXCLIENTS 个 client:<ul>
<li>从 tokens 里拿走一个 token</li>
<li>把自己的 conn 放入 pending channel（如果之前的 pending conn 还被取走，则这个 goroutine就会被挂起，等待之前的 pending conn 被取走。否则，继续执行。</li>
</ul>
</li>
<li>第 (MAXCLIENTS + 1) 个 client:<ul>
<li>从 tokens 里拿不到 token 了，当前的 goroutine 在这一点上挂起，等待 token。</li>
</ul>
</li>
<li>有人离开：<ul>
<li>归还一个 token，这样之前被挂起等待 token 的 goroutine 被唤醒，继续执行。 </li>
</ul>
</li>
</ul>
<p>没有使用任何同步机制，代码干净清晰漂亮，我们就完成了一个排队系统。Ura for go!</p>
<hr/>

<p>喘一口气，接下来看 <code>join</code> 的时候调用的 <code>CreateClient</code> 的代码：</p>
<pre><code>func CreateClient(conn net.Conn) *Client {
    reader := bufio.NewReader(conn)
    writer := bufio.NewWriter(conn)

    client := &amp;Client{
        conn:     conn,
        incoming: make(Message),
        outgoing: make(Message),
        quiting:  make(chan net.Conn),
        reader:   reader,
        writer:   writer,
    }
    client.Listen()
    return client
}</code></pre>
<p><code>client.Listen</code> 极其细节：</p>
<pre><code>func (self *Client) Listen() {
    go self.Read()
    go self.Write()
}

func (self *Client) Read() {
    for {
        if line, _, err := self.reader.ReadLine(); err == nil {
            self.incoming &lt;- string(line)
        } else {
            log.Printf(&quot;Read error: %s\n&quot;, err)
            self.quit()
            return
        }
    }

}

func (self *Client) Write() {
    for data := range self.outgoing {
        if _, err := self.writer.WriteString(data + &quot;\n&quot;); err != nil {
            self.quit()
            return
        }

        if err := self.writer.Flush(); err != nil {
            log.Printf(&quot;Write error: %s\n&quot;, err)
            self.quit()
            return
        }
    }

}</code></pre>
<p><code>client.Listen</code> 里我们也生成了两个 goroutine，加上之前的两个，每个 client 有四个 goroutine（所以运行中的Server的 gorutine 的数量接近于 client num * 4）。虽然我们可以做一些优化，但这并不要紧，一个 go 进程里运行成千上万个 goroutine没有太大问题，因为 goroutine 运行在 userspace，其 memory footprint很小（几k），切换代价非常低（没有 syscall）。</p>
<p>这两个 goroutine 正如一开始设计时提到的，一读一写，通过 channel 和外界交互。</p>
<p>这就是整个聊天室的主体代码。接下来的命令行就很简单了。</p>
<p>先看 Server 代码：</p>
<pre><code>package main

import (
    . &quot;chatroom/chat&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    if len(os.Args) != 2 {
        fmt.Printf(&quot;Usage: %s &lt;port&gt;\n&quot;, os.Args[0])
        os.Exit(-1)
    }

    server := CreateServer()
    fmt.Printf(&quot;Running on %s\n&quot;, os.Args[1])
    server.Start(os.Args[1])

}</code></pre>
<p>接下来是 Client 代码：</p>
<pre><code>package main

import (
    &quot;bufio&quot;
    . &quot;chatroom/chat&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;os&quot;
)

func main() {
    if len(os.Args) != 2 {
        fmt.Printf(&quot;Usage: %s &lt;port&gt;\n&quot;, os.Args[0])
        os.Exit(-1)
    }

    conn, err := net.Dial(&quot;tcp&quot;, os.Args[1])

    if err != nil {
        log.Fatal(err)
    }

    defer conn.Close()
    in := bufio.NewReader(os.Stdin)
    out := bufio.NewWriter(os.Stdout)

    client := CreateClient(conn)

    go func() {
        for {
            out.WriteString(client.GetIncoming() + &quot;\n&quot;)
            out.Flush()
        }
    }()

    for {
        line, _, _ := in.ReadLine()
        client.PutOutgoing(string(line))
    }

}</code></pre>
<p>运行一下（起了两个client）：</p>
<pre><code>➜  chatroom git:(master) ./bin/chatserver :5555
➜  chatroom git:(master) ./bin/chatserver :5555
Running on :5555
2014/01/30 09:05:24 Server 0xc2000723c0 starts
2014/01/30 09:05:34 A new connection &amp;{{0xc20008f090}} kicks
2014/01/30 09:05:34 Auto assigned name for conn 0xc200000100: User 0
2014/01/30 09:05:48 A new connection &amp;{{0xc20008f120}} kicks
2014/01/30 09:05:48 Auto assigned name for conn 0xc200000148: User 1
2014/01/30 09:06:39 Got message: Hello from client User 0
2014/01/30 09:06:39 Broadcasting message: User 0 says: Hello
2014/01/30 09:06:48 Got message: :name Tyr from client User 1
2014/01/30 09:06:48 Broadcasting message: Notification: User 1 changed its name to Tyr
2014/01/30 09:06:57 Got message: Hello world! from client User 0
2014/01/30 09:06:57 Broadcasting message: User 0 says: Hello world!
2014/01/30 09:07:01 Got message: Hello from client Tyr
2014/01/30 09:07:01 Broadcasting message: Tyr says: Hello
2014/01/30 09:08:19 Read error: EOF
2014/01/30 09:08:19 Client User 0 is quiting
2014/01/30 09:08:19 Broadcasting message: Notification: User 0 quit the chat room.</code></pre>
<p>其中一个 client：</p>
<pre><code>➜  chatroom git:(master) ./bin/chatclient :5555
User 0 says: Hello
:name Tyr
Notification: User 1 changed its name to Tyr
User 0 says: Hello world!
Hello
Tyr says: Hello
Notification: User 0 quit the chat room.</code></pre>
<p>完整代码请见 <a href="https://github.com/tyrchen/chatroom">github repo</a>。</p>
<p>以上代码能正确运行，不过还有不少问题，比如 server stop 时 goroutine 并未正确 cleanup。但对于理解 <code>goroutine</code> 和 <code>chan</code> 来说，不失为一个很好的例子。</p>
<h2>Lessons learnt</h2>
<h3>使用go test</h3>
<p>我现在写代码已经离不开非常方便的 <code>go test</code> 了。golang 的开发者们非常聪明，他们知道把一个 test framework / utility 放在核心的安装包中是多么重要。这个 chatroom 是迭代开发的，你可以 checkout v0.1/v0.2/v0.3 分别看不同时期的代码。每次添加新功能，或者重构代码时，<code>go test ./chat</code> 就是我信心的保证。代码和test case同步开发，新的 feature 有新的 case 去 cover，这样一点点做上去。拿柳总的话说，就是：『垒一层土，夯实，再垒一层』。</p>
<p>例子：</p>
<pre><code>➜  chatroom git:(master) go test ./chat
ok      chatroom/chat   0.246s</code></pre>
<h3>并发与同步</h3>
<p>golang 在设计时做了很多取舍。其中，对map的操作是否原子就有很多 debate。最终，为了 performance，map 的操作不具备原子性，亦即不是 multithread safe。所以，正确的做法是在从 map 中删除一个 conn 时和使用 <code>range</code> 中读取时做读写同步。由于本例运行在单线程环境下（是的，如果你不指定，golang process 默认单线程），且以教学为目的，实在不忍用难看的同步操作降低代码的美感。</p>
<p>另外一种做法是在读写两个需要同步的地方使用 channel 进行同步（还记得刚刚讲的 token）吧？</p>
<p>如果你对 map 的 thread-safe 感兴趣，可以读读 <a href="http://stackoverflow.com/questions/12938233/is-getting-a-value-using-range-not-thread-safe-in-go">stackoverflow上的这个问题</a>。</p>
<h3>通过close来向所有goroutine传递终止讯息</h3>
<p>在我的代码里，close 做得比较 ugly，不知你是否感受到了。更好的做法是使用 <code>close</code> 一个 channel 来完成关闭 goroutine 的动作。当 close 发生时，所有接收这个 channel 的 goroutine 都会收到通知。下面是个简单的例子：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
    &quot;time&quot;
)

const (
    N = 10
)

func main() {
    quit := make(chan bool)

    for i := 0; i &lt; N; i++ {
        go func(name string) {
            for {
                select {
                case &lt;-quit:
                    fmt.Printf(&quot;clean up %s\n&quot;, name)
                    return
                }
            }
        }(strconv.Itoa(i))
    }
    close(quit)

    for {
        time.Sleep(1 * time.Second)
    }
}</code></pre>
<p>我生成了 N 个 goroutine，但只需使用一个 <code>close</code> 就可以将其全部关闭。在 chatroom 代码中，关闭 server 时，也可以采用相同的方法，关闭所有的 client 上的 goroutine。</p>
<p>下面是上述代码执行的结果：</p>
<pre><code>➜  terminate  go run terminate.go
clean up 0
clean up 1
clean up 2
clean up 3
clean up 4
clean up 5
clean up 6
clean up 7
clean up 8
clean up 9</code></pre>
<h3>尽可能把任务分布在goroutine中</h3>
<p>如果你没有看过 Rob Pike 的 <a href="http://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not parallelism</a>，建议一定要看，不管你有没有 golang 的 background。Concurrency 是你写软件的一种追求，和是否并行无关，但和模块化，简单，优雅有关。</p>
<h3>goroutine不可做无阻塞的infinite loop</h3>
<p>goroutine，至少在 golang 1.2 及之前的版本，都运行在一个 cooperative multitasking 的 scheduler 上。所以你要保证你的任何一个 infinite loop 都要有可能被 block 住，无论是 block 在 IO, chan, 还是主动 block 在 timer 上，总之，infinite loop 要有退出机制。刚才的例子我们稍微改改：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
    //&quot;time&quot;
)

const (
    N = 10
)

func main() {
    quit := make(chan bool)

    for i := 0; i &lt; N; i++ {
        go func(name string) {
            for {
                select {
                case &lt;-quit:
                    fmt.Printf(&quot;clean up %s\n&quot;, name)
                    return
                }
            }
        }(strconv.Itoa(i))
    }
    close(quit)

    for {
        //time.Sleep(1 * time.Second)
    }
}</code></pre>
<p>乍一看，这个例子中的 gorountine应该能收到 <code>close</code> 而自我关闭。在 <code>main</code> 执行的过程中，头十个新创建出来的 <code>goroutine</code> 还未得到调度。虽然在 main 里我们 close 了 quit，但由于接下来的 dead loop 一直不释放 CPU，所以其他 goroutine 一直得不到调度。运行的话没有任何输出：</p>
<pre><code>➜  terminate  go run terminate.go
^Cexit status 2</code></pre>
<p>我们稍稍改改这个程序：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;strconv&quot;
    //&quot;time&quot;
)

const (
    N = 10
)

func main() {
    runtime.GOMAXPROCS(2)
    quit := make(chan bool)

    for i := 0; i &lt; N; i++ {
        go func(name string) {
            for {
                select {
                case &lt;-quit:
                    fmt.Printf(&quot;clean up %s\n&quot;, name)
                    return
                }
            }
        }(strconv.Itoa(i))
    }
    close(quit)

    for {
        //time.Sleep(1 * time.Second)
    }
}</code></pre>
<p>现在允许这个程序运行在两个 thread 上。这样就能正常运行了。但切记，没有阻塞机制的 infinite loop 不是一个好的设计。</p>
<pre><code>➜  terminate  go run terminate1.go
clean up 0
clean up 1
clean up 2
clean up 3
clean up 4
clean up 5
clean up 6
clean up 7
clean up 8
clean up 9
^Cexit status 2</code></pre>
<h3>DRY (Don&#39;t Repeat Yourself)</h3>
<p>写 chatroom 时，我不断重构代码，其目的就是能让代码干净，漂亮。比方我的一次 commit：<code>git diff 39690d9 6851177</code>，就是在做 test case refactor。</p>
<p>DRY 的前提是有完善的 test case，前文也提到。这是项目内部的 DRY。</p>
<p>另外一种 DRY 的方式是（从我途客圈的前同事 @chenchiyuan 那里学到的）：如果两个或以上的项目中都用到类似结构的代码，则考虑将其重构到一个第三方的 lib 里。在 chatroom 中，有两处这样的重构，重构在我的 <a href="https://github.com/tyrchen/goutil">goutil</a> 项目中。</p>
<p>第一处是生成唯一数：</p>
<pre><code>package uniq

var (
        num = make(chan int)
)

func init() {
        go func() {
                for i := 0; ; i++ {
                        num &lt;- i
                }
        }()
}

func GetUniq() int {
        return &lt;-num
}</code></pre>
<p>第二处是正则表达式匹配，将匹配的结果放入一个 map 的 slice 里：</p>
<pre><code>package regex

import (
        &quot;regexp&quot;
)

const (
        KVPAIR_CAP = 16
)

type KVPair map[string]string

func MatchAll(r *regexp.Regexp, data string) (captures []KVPair, ok bool) {
        captures = make([]KVPair, 0, KVPAIR_CAP)
        names := r.SubexpNames()
        length := len(names)
        matches := r.FindAllStringSubmatch(data, -1)
        for _, match := range matches {
                cmap := make(KVPair, length)
                for pos, val := range match {
                        name := names[pos]
                        if name != &quot;&quot; {
                                cmap[name] = val
                        }
                }
                captures = append(captures, cmap)
        }
        if len(captures) &gt; 0 {
                ok = true
        }
        return
}</code></pre>
<p>总结一条铁律：project 级的 DRY 是函数化，package化；cross project的 DRY 是 repo 化。</p>
<h2>后记</h2>
<p>大过年的，我这么嘚吧嘚吧地你也读得挺累，感谢你一路读到这里，新年快乐！</p>
<p><img src="/assets/files/photos/baby20140130.jpg" alt="小宝"></p>
]]></description>
            <link>http://tchen.me/posts/2014-01-27-golang-chatroom.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-01-27-golang-chatroom.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Wed, 29 Jan 2014 23:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[2014年年会节目脚本 - Branch取经记]]></title>
            <description><![CDATA[<p>每年的年会，依team旧例：新员工挑大梁演主角，而且要无耻度无底线。2013我是新员工，所以不得不被安排角色。一不小心大家选了个三国的剧本 <a href="http://www.docin.com/p-111786442.html">三国无间道</a>，重口一致要让我演董卓，说我体态样貌样样俱全。我一看剧本，这是毁人的节奏啊。不行不行，于是毛遂自荐当编剧，卸了主演。话说这三国无间道的剧本有点烂，笑点不多，和内事外事均无半毛钱关系，于是干脆一狠心，推翻重来。正巧13年重读了『西游记』，对唐太宗地府还魂记还记忆犹新，于是以此为蓝本展开故事。剧本着眼于普度众生，让大多数team成员都能上个台，露个脸，于是人物众多，在一个主线故事下，没有绝对的主角，算是本剧的小小遗憾。</p>
<p>以下内容做了些删改，避免暴露一些内部信息。</p>
<!--more-->

<h2>人物</h2>
<p>唐太宗：Tony</p>
<p>武媚娘：Lily</p>
<p>观音姐姐：Halin</p>
<p>黑白无常：Daniel, Leo</p>
<p>王玄奘：Dereck</p>
<p>邵悟空：Yafang</p>
<p>郭悟能：Cliff</p>
<p>郭悟净：Tim</p>
<p>天竺城管：Bo</p>
<p>接引道人：Dongdong</p>
<p>菩提祖师：Colin </p>
<p>举牌，新闻联播口型：Yaling，Hao</p>
<p>P1, P2 Issue: Hao</p>
<p>旁白及音乐播放：Tyr</p>
<h2>第一幕</h2>
<p>（牌子飘过：本故事纯属扯淡，请勿对号入座）</p>
<p>（中宫内，武媚娘正在弹吉他：一闪一闪亮晶晶）</p>
<p>（唐太宗背着手走进来）</p>
<p>唐太宗：抽刀断水水更流，举杯消愁愁更愁，人生在世不称意,明朝散发弄…扁…舟。</p>
<p>武媚娘（起身相迎）：陛下。</p>
<p>唐太宗：媚娘免礼。（走到媚娘旁边的龙榻前，卧在龙榻上，一脸倦容）</p>
<p>武媚娘：陛下满面愁容，是否国事太过繁重？</p>
<p>唐太宗：媚娘，自从天庭将 branch 业务托朕掌管，我就吃也吃不好，睡也睡不着，那些海龙王，河龙王，井龙王，加上女儿国，宝象国等各国国君天天给我开p1 issue，还动不动就escalate到观音姐姐甚至玉帝那里，弄得我好生烦躁。唉～～累觉不爱啊（说罢，闭上眼睛）</p>
<p>武媚娘：陛下莫愁，臣妾刚学会一首『广陵散』，这就弹来，为陛下安安神。</p>
<p>（媚娘弹奏两只老虎，唐太宗随着音乐晃着脑袋扭着身子渐渐入睡，入睡，媚娘放下吉他，拿苍蝇拍给太宗扇风，并打苍蝇）</p>
<p>（灯光转暗，黑白无常在远处现身。道具：招魂幡，一串糖葫芦，一个风车，凸显过年气氛）</p>
<p>（音乐 You drive me crazy）</p>
<audio src="/assets/files/mp3/1-1-you-drive-me-crazy.mp3" controls="controls"></audio>

<p>黑无常：阎王教人三更死，绝不留人到五更。可是就在前两天，地府出了大事！分布在阴曹地府各个角落的firewall不停的crash，真是一塌糊涂啊！</p>
<p>白无常：生死薄信息系统全部瘫痪，原本一帮贪官死期已至，结果到今天还活蹦乱跳的；高丽国三胖子的姑父本来还有十年阳寿，却嗝屁投胎去了。</p>
<p>黑无常：阎王大怒，差我兄弟勾了branch的负责人前去问话，说句公道话，这branch的活真心不好干啊。</p>
<p>白无常：谁说不是呢？以前大家都叫他小白，叫我小黑，叫得人家心里好自卑。自打当了JTAC以后，我就营养不良，脸色越来越白，上次PTO几天去高丽，一堆美女围着我问我用的面膜品牌。我告诉她们：要美白，请接customer issue，谁用谁知道！</p>
<p>黑无常：皇宫已到，那不是就是负责branch的老李？</p>
<p>（黑白上前锁住唐太宗，唐太宗惊醒）</p>
<p>白无常：老李，阎王要你去地府开个secure meeting，速速跟了我们去吧！</p>
<p>（唐太宗反抗，武媚娘上前阻拦，众人闹成一团）</p>
<p>唐太宗：我死也不去！哦，不，我不要死！</p>
<p>黑无常：不去就双规你！</p>
<p>唐太宗：大慈大悲观世音救命啊！</p>
<p>（观音姐姐手持玉净瓶，摆着兰花指出现。）</p>
<p>观音姐姐：善哉善哉，给贫僧一个薄面，大家请住手。</p>
<p>（众人住手，黑白无常原地吐舌头）</p>
<p>唐太宗：欧～巴～（尾音拖三秒），你来得正好。佛说你不入地狱谁入地狱，这个meeting还是你参加吧。你好歹是个喜大普奔的菩萨，阎王爷那说得上话。</p>
<p>（观音姐姐满脸黑线。黑线飘过。）</p>
<p>观音姐姐（塞给黑白一人一个红包）：黑白无常，你等且回去禀报阎罗王，我有个极好的workaround，地府不是有孟婆汤么，浇在那些有问题的盒子上可保十日平安。</p>
<p>黑白：尊法旨，不过我们要留一个人质！（拉着媚娘下场）</p>
<p>媚娘（伸手）：陛下～</p>
<audio src="/assets/files/mp3/1-2-huisekongjian.mp3" controls="controls"></audio>

<p>唐太宗（伸手）：Honey～</p>
<p>（画面定格。唐太宗面部抽搐，凄凄惨惨戚戚，内心独白）</p>
<p>（音乐停）</p>
<p>观音姐姐：随他们去吧。糖糖，目前你还有更重要的事情去做。我这次来就是想告诉你，什么是branch业务的真谛。</p>
<p>唐太宗（回过神来）：真谛？</p>
<p>观音姐姐：很多事情不是你表面上看到的那样。你以为遍布我大唐的沙县小吃仅仅是小吃么？</p>
<p>唐太宗：啊？这和branch有毛关系啊？</p>
<p>观音姐姐：打个比方嘛。你以为我们Juniper是卖硬件的么？你以为将 branch 产品做出来的西天神佛是吃素的么？其实我们是卖服务的。硬件软件不多出点问题，服务怎能做得起来？俗话说的好，一日卖硬件，终身卖服务。这，才是为商之道。</p>
<p>唐太宗：虽然不明白你在说什么，但感觉好厉害的样子。</p>
<p>观音姐姐：我想派你去西天取经。</p>
<p>唐太宗：取经？</p>
<p>观音姐姐：天竺班加罗尔寺的藏经阁里有大量 branch 知识，你组建一个取经团队，到天竺去学习，学好了branch知识就不怕customer issue了。</p>
<p>唐太宗：学习？</p>
<p>观音姐姐：对。贫僧先行告辞，替你们上下打点。</p>
<p>（说罢观音姐姐飘走）</p>
<p>唐太宗：喂，别走啊～天竺？我们没人懂梵文啊～</p>
<p>（众人除唐太宗外均下场）</p>
<p>（音乐 快乐女声）</p>
<audio src="/assets/files/mp3/1-3-xiangchang.mp3" controls="controls"></audio>

<p>旁白：就这样，唐太宗开始了艰苦卓绝的『西游记中人』海选，终于敲定了从超级女声十强赛中脱颖而出的史上最强大取经阵容：王玄奘，邵悟空，以及郭悟能，郭悟净两兄弟。这一天，唐太宗在Everest准备开all hands meeting，检阅取经部队。。。</p>
<h2>第二幕</h2>
<p>（播放运动员进行曲）</p>
<audio src="/assets/files/mp3/2-1-yundongyuan.mp3" controls="controls"></audio>

<p>（唐太宗在场地中央站着，旁边立一个牌子：长安，场地另一次立牌子：天竺）</p>
<p>（玄奘，孙悟空，白龙马，猪悟能，沙悟净列队上台）</p>
<p>玄奘：稍息，立正。向右看齐，向前看！</p>
<p>（玄奘小跑到太宗面前，行军礼）</p>
<p>玄奘：报告陛下，西天取经小分队集结完毕，请指示。</p>
<p>唐太宗（挥挥手）：同志们辛苦了！</p>
<p>玄奘等人：为branch服务！</p>
<p>唐太宗：玄奘，此去你等背负重大责任，branch 能否做好就看你们的了。</p>
<p>玄奘等人：Yes sir！</p>
<p>唐太宗：唉？你们的坐骑白龙马呢？</p>
<p>悟空：陛下，按照天庭规定，本周白马限行，只允许黑马上路。</p>
<p>唐太宗：哦，明白。你们的梵文练得怎样了？</p>
<p>悟净（出列）：前轱辘转后轱辘不转，前轱辘不转后轱辘转思密达（颔首）</p>
<p>唐太宗：（挥手）我大唐有你等高人，branch复兴指日可待！出发在即，大家还有什么问题？</p>
<p>悟空：此番西去，路途遥远，非一年半载不能归来，陛下可否多批些budget供我们旅途中team building？</p>
<p>唐太宗：我靠，这是出差，你当是带薪休假呢。最近手头紧，国库里就够你们两周的钱粮。</p>
<p>悟能：两周？此处离西天十万八千里，现在又是雾霾又是限行的，两周我们都走不出杜家坎啊陛下！</p>
<p>唐太宗：哈哈哈，你们out了。西域刚刚上供了一种灵鸡，叫灰机，骑上它，七八个时辰就到天竺。你们看～</p>
<p>众人：哦？</p>
<p>（Yalin举着灰机-Juniper Rocker-的牌子上场，众人一齐跟在灰机的后面，在场中绕圈子，唐太宗下）</p>
<h2>第三幕</h2>
<p>（灰机带着师徒四人飘过，绕场两圈到天竺，然后飘走）</p>
<p>（音乐 - 天竺少女）</p>
<audio src="/assets/files/mp3/3-1-tianzhu.mp3" controls="controls"></audio>

<p>（师徒四人开始跳印度舞）</p>
<p>（十秒左右，音乐声渐小）</p>
<p>悟能：师父，我们到天竺了～</p>
<p>玄奘：悟空，去打探一下，此处是何地？</p>
<p>悟空（抓耳挠腮，四处张望）：师父，此地正是班加罗尔寺。藏经阁应该就在附近，我们找人问问。</p>
<p>玄奘（大喜）：徒儿们咱们走。</p>
<p>（天竺城突然出现，操一口湖北普通话）</p>
<p>天竺城管：你们这是去哪儿？身份证，暂住证，结婚证，离婚证，独生子女证？没有？罚钱！1w 卢比！</p>
<p>郭悟净（跳出）：喂，大家都是道上的兄弟，给点面子。大哥以前混哪里？</p>
<p>天竺城管：老子洪兴的，来天竺前混铜锣湾，兄弟们都管我叫山鸡。</p>
<p>郭悟净：啊，洪兴啊（翘起大拇指）？小弟不才，混五道口多年，嘿嘿——前轱辘转后轱辘不转，前轱辘不转后轱辘转思密达（颔首）</p>
<p>天竺城管（大惊）：啊，五道口？你才是我大哥！对不起啊，大哥，你们请～请～（低三下四）</p>
<p>（城管大叔做个请的动作，随即离开）</p>
<p>（众人原地做前进状）</p>
<p>（接引道人出场，操一口纯正东北话）</p>
<p>接引道人（举个接机的牌子走过来）：哎呀妈呀，可算等到你们了。俺在这噶哒都被烤秃噜了。你们是从大唐那噶哒来的么？看你们面相，俺寻思应该是来做PTO的吧？啊不，TOI。</p>
<p>（牌子上写：Flight: N.G. 350，Country: Tang，Name: Derek Wang Xuanzang）</p>
<p>悟净：前轱辘转后轱辘不转，前轱辘不转后轱辘转思密达（颔首）</p>
<p>接引道人（转身欲走）：妈呀，接错淫了，丢淫丢大发了～</p>
<p>玄奘：大师莫走。我这徒弟最近解bug解岔脑子了，不太会说人话。弟子正是从东土大唐而来，来班加罗尔求亲的王玄奘，啊，不对，求经，求经。</p>
<p>接引道人：早说呀，你说你们一群大老爷们磨磨唧唧，跟老娘们似的。Let&#39;s go!</p>
<audio src="/assets/files/mp3/3-1-tianzhu.mp3" controls="controls"></audio>

<p>（菩提老祖上台，操一口湖南普通话）</p>
<p>玄奘：弟子玄奘一行五人，参见我佛。</p>
<p>（接引道人飘走）</p>
<p>菩提老祖：佛祖PTO去了，这次由我菩提老祖全程接待，哈哈。</p>
<p>玄奘：善哉善哉～</p>
<p>菩提老祖：我这里有红咖喱，绿咖喱，黄咖喱，黑咖喱，你们想吃哪一种撒？哈哈。</p>
<p>玄奘：感谢祖师恩惠。branch issue太多，我大唐陛下茶饭不思，我等岂敢怠慢？先不谈吃，能否即刻带我们去藏经阁学习经书？</p>
<p>菩提老祖：妥妥的，你们等在这里，我去找找，哈哈。</p>
<p>（菩提老祖离开，众人面面相觑）</p>
<p>（Yaling和Hao上场，准备新闻联播）</p>
<p>悟能：师父你也是的，人家好意请你吃，你却回绝，这一路旅途奔波，老郭我肚子都抑郁了半天了。</p>
<p>悟空：郭师弟，要不我拔根毫毛，变个猪蹄给你补补？</p>
<p>悟能：你看我的口型，哥屋恩。猪蹄我有四只，每天都在舔，我要吃猴脑！</p>
<p>（众人正在玩闹，菩提祖师出现）</p>
<p>菩提祖师：经书找到了，你们请看！哈哈。</p>
<p>（Yalin和Li Hao托着电视框上场，准备。Yalin对口型，表情夸张；Li Hao做手语，神情严肃）</p>
<p>（新闻联播音乐声骤然响起，众人一惊，然后捧着下巴，瞪大眼睛，一脸神往）</p>
<audio src="/assets/files/mp3/3-2-cctv.mp3" controls="controls"></audio>

<p>悟净（新闻联播音乐快结束时）：我靠，前轱辘转思密达！</p>
<p>（众人张大了嘴，瞪大了眼，呆若木鸡）</p>
<p>（播放完毕后，声音停止，众人跌倒，菩提老祖上台，电视机撤）</p>
<p>菩提老祖：这仅仅是我们branch的xx文档的一部分，还有xxx的要不要听？哈哈。</p>
<p>（众人爬起）</p>
<p>玄奘等人（含着热泪，做个长揖）：多谢老祖，人家培训要钱，你们培训要命！且罢切罢，我们回去慢慢学习！悟能，上优盘！</p>
<p>（悟能把猪鼻子凑过去，菩提老祖拿出U盘，插入猪鼻子）</p>
<p>（视频拷贝中，视频拷贝完成！西天取经成功！的牌子飘过）</p>
<p>旁白：就这样，师徒四人终于顺利取到真经。回到大唐后，众人努力学习 branch 视频，开始跟各种种奇葩customer issue斗争。</p>
<p>（音乐霍元甲）</p>
<audio src="/assets/files/mp3/3-3-hyj1.mp3" controls="controls"></audio>

<p>（P2 issue上，一副有恃无恐的样子，唐僧念经，P2 issue头昏欲裂，倒下台去）</p>
<p>（P1 issue上，双手捶胸，秀肌肉，唐僧念经，毫无效果，众人一齐上，将issue赶跑，下场）</p>
<p>（音乐停）</p>
<p>旁白：三个月后，整个branch终于清静了，再也没有customer issue来骚扰。唐太宗带着武媚娘天天哼着小芳，喝着摩卡，在5楼打着台球，小日子过得相当地思密达。</p>
<p>（全剧完）</p>
]]></description>
            <link>http://tchen.me/posts/2014-01-14-my-annual-festival-script.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-01-14-my-annual-festival-script.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Mon, 13 Jan 2014 23:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Sunnyvale trip - 所见，所聊，所感]]></title>
            <description><![CDATA[<p>又是一个一周的短差，来去匆匆。依旧是白天各种开会，各种social，跟所有认识的人打招呼唠家常，跟不认识的但有来往（或者即将来往的）熟悉并打交道。本文没什么主题，就是所见所聊所感，totally personal。</p>
<!--
走之前列了好几个清单，分别是：

* 这次过去老板布置的任务（3个）
* Peer布置的任务（2个）
* 自己想到的任务（4个）
* 要打个招呼，唠唠家常的人（29人）
* 要深入了解和认识的人（5人）
* 要一同工作，寻求帮助的人（6人）

到离开的时候，除了有6个要Say hello的人没见着外，其他都完成得不错。工作上的事情当然不便在博客里透露，但和形形色色的人接触得到的感受却值得说说。
-->

<!--more-->

<p>（一）</p>
<p>先说我老板G君。G君有10个US Patents，10年engineering工作经验，13年management工作经验。</p>
<p>他第一次来CNRD时，我和他曾聊了二十多分钟。他一直作为一个旁听者静静地听我的自我介绍，偶尔会插两句话让我就经历过的一些事提提看法，比如说scrum，python。那时对他印象还不算深。</p>
<p>他第二次来CNRD时，有次我负责领他去餐馆吃饭。他拎着皮箱去的，皮箱里有一本厚厚的书，撑着外侧的兜子合不上。书是上千页的那种大砖头。我问他是什么书？他说是 <strong>SRX cookbook</strong>，他想尽快熟悉我们的产品，就在amazon买了本带在飞机上看。我对他顿时肃然起敬。在途客圈，我喜欢招爱读书的工程师，面试时也会和对方聊聊最近读过什么书。我喜欢爱读书的人，因为读书要么能更新你的思想，要么能更新你的技能。愿意读书，便不会墨守成规。</p>
<p>其他深入接触到他的人，都认为他很注重细节，提问一针见血，并且雷厉风行。这次在Sunnyvale和他前后开了6次会，这个评价我认为恰到好处。一般而言，一个做了十几年管理者，已经离技术有相当的距离，但他似乎不同，还在不断跟踪和了解技术，并琢磨怎么能将这些技术用在daily work上。这也是为什么他总能提出一针见血的问题。具体细节我不便多说，这几次开会我被激发了出了不少新的想法和思路。</p>
<p>说几句题外话。我一直觉得在R&amp;D中，Manager只负责people management和resource planning是行不通的。Manager最好要有扎实的工程师背景，要有很强的技术敏感性，这样才更容易做正确的判断。并且越往上走（直到Engineering VP）这种能力应该越强才对。如果说Manager是县官或师团长，TL充其量也就是师爷或者参谋，出谋划策可以，最终拍板，make decision还是得Manager。很多东西可以delegate，但重要的decision making不能。因为Manager要为手下的弟兄们负责，要为team的成败负责。一个不那么懂技术的Manager很容易被TL蒙蔽（有意或无意），做出并非全局最优的决定。久而久之，能说会道者上去，勤奋木讷者下去，organization渐渐从治世转为乱局（和帝国的兴衰何其相似）。</p>
<p>自从做了途客圈后，我就养成个毛病，总把自己放在某个位置做沙盘推演。我常常会想，如果我是xxx（比如G君），我会怎么做？我会如何make decision？我会如何去让整个organization更优化，更有战斗力和活力？当然，这些推演都是纸上谈兵，乱点鸳鸯谱。</p>
<p>G君还有个特点就是早出晚归。这周经常早上8点左右，晚上7点后都能见到他。他喜欢把会议放在早上9点（不管是和Sunnyvale team还是和CNRD team），这给很多同事整了个大难题：8点多正是堵车的时候，肿么办？</p>
<p>总之，G君值得期待。</p>
<p>（二）</p>
<p>再说说新来的DE K君。K君履历惊人 - Brown小本，Stanford研究生，然后SGI 4年（嘿嘿，Ex-SGIer），NetApp 9年，Zynga 4年（2009-2013)，有6个US patents。Zynga 07年创立，11年上市，所以我猜K君应该发了笔横财（忘记当面跟他验证了）。</p>
<p>第一次见他是在3楼。我跟几个CNRD的老熟人在Pantry聊天，这哥们很唐突地加入并接管了话题，然后讲了个『冷』笑话。我没太听懂，但其他人都哈哈大笑（唉，no slangs，请讲英语普通话）。当时我以为他是 XX team里某个工程师，后来 XX 说他就是刚来的DE。充满活力，爱开玩笑的geek，这就是我对他的第一印象。</p>
<p>第二次见他是莫名其妙被 Program management team 拉进了一个会议。这会议是K君主导。K君一到，就把大家从椅子上拉起来，开站立会议。我顿时觉得这哥们有意思了。我喜欢站立会议，它让大家能集中精神在要讨论的事情上，而不是坐在那里一只耳朵听着，貌合神离。他把要做的事情分成sprint去manage，估计这是在Zynga里养成的习惯。讨论结束后，他立刻在会上就明确action plan和deadline，而且他的deadline是以天为单位，而不是在J记惯常的单位：周。我能感觉得到会上的其他人感觉不那么舒服，至少不适应这种style。</p>
<p>第三次是周五下午去他office跟他聊天。跟他拉家常你绝对不会感到沉闷，他话多，激情四射，玩笑一个接一个。聊到正题后，他展示给我他正在梳理的J记内部的整个process chain。这让我眼前一亮，我怎么从来没想过这么梳理一下呢？我甚至都没想过梳理一下途客圈的process chain呢？</p>
<p>总之，K君是个很好相处的人。我对他在Zynga的这段履历还是很看好（2009年Zynga应该还是startup的氛围吧）—— 我觉得在大公司里混日子，混title比较容易，但在startup里就困难多了。不过他的风格是否适合J记（agile v.s. waterfall），或者说他多大程度上能影响J记（得看他被授予什么样的权责），就看造化了。</p>
<p>（三）</p>
<p>这次出差，KP君跟我一道。我对KP君的第一印象很一般，觉得他是个典型的那种自我感觉良好的蹦蹦跳跳的美国人。虽然上过几次他的课，但我对他并没有太深入的了解。</p>
<p>这次出差我们share一辆车。每天晚上我都工作到比较晚，所以他都把车钥匙留给我，自己步行回酒店。</p>
<p>他这次出差的目的是给这边的team做business training。但是，每天结束时他都显得很沮丧。有次他很郁闷地跟我抱怨事情进行地不那么顺利，因为这边的中国工程师，尤其是dev，不怎么鸟他。我跟他说你得摆正心态。原因大概有这么三个，第一，在CNRD，你是个外国人，大家会对你格外客气，但在这里，大家都是美国人，你不再特别。第二，CNRD平均年龄低一些，对这种training接受程度自然高一些。第三，CNRD你已经有些影响力了，这边却还零基础。</p>
<p>说着我突然想起了06年我来这里出差，参加一个training的场景。那个training是 &quot;The Art of Presentation&quot;，training team花钱请的外边的trainer来做的。大家自我介绍后，我惊讶的发现十几个人中，R&amp;D的人聊聊无几，Dev貌似只有我一人。要知道，这个site，R&amp;D的人应该是占多数的。结果来的尽是PLM，PM，IT，blabla。你不能责备dev不求上进，因为在他们看来，写段代码要比这个有意思得多，这是性格使然。在途客圈里，诸多外事我也是能不参加就不参加，要不是跟投资人pitch我必须参加，我估计也会躲在一旁和工程师在一起快活地写代码（这性格对工程师来说没什么大碍，但对CTO的角色就是硬伤）。所以对一个Trainer来说，清楚地把握audience的性格特点也很重要。CNRD适用的，US未必；大多数人适用的，Dev也未必（dev就是这么个奇怪的群体）。就是这么个浅显的道理。</p>
<p>我与人接触的一个大原则是：不管跟什么人打交道，不管对方有什么缺点，你总能找到他的优点（有意思的是，我们所认为别人的缺点，往往是和自己不一样的地方，就像研发看sales觉得太吵，sales看研发觉得无趣）。KP君估计不太能和dev玩到一块，因为他sales的性格。但深入接触后，他其实是个很不错的人，为他人着想，乐于帮忙等等。周五早上我要给这边的dev和TL做一个presentation，我们8点到办公室后，我找了个会议室请他帮忙帮我看看我present的如何，他欣然同意并提出了很多很有价值的意见。</p>
<p>（四）</p>
<p>周五晚上，我约老上司F君一起聊聊创业。F君心态很好，认为创业『谋事在人，成事在天』，尽最大的努力后，成与不成并不那么重要了。和懵懵懂懂走上创业之路的我相比，他要成熟得多。他深谙『兵马未动，粮草先行』之道，在R&amp;D刚刚起步阶段就开始actively engage customers，天天跑市场。这很好。dev出身的创业者，比如我，marketing/sales的感觉很差，往往光顾研发，忽略产品最终要交到客户手上。</p>
<p>我跟他说，我四十岁前还会不断创业，直到成功，或者时间证明我这号人不管怎么努力，就是不适合创业。说到这里，我突然想起一个问题：F君多大了？我印象中他已经四十好几，但不能确定。</p>
<p>他告诉我他是六二年的。我有点吃惊。在这个年龄，以他的地位，财富，他完全可以退休，每天出海钓钓鱼享受人生。但是，他还在这里追寻创业的理想。这让我十分敬佩。我想，我应该把我的deadline放在五十岁，那时候我依然需要拥有这份闯劲。</p>
<p>F君跟我分享了一个故事。在他的职业早年，他的一个朋友，毕业于清华的很厉害的工程师，介绍他去E公司。因为没有past experience，他最终没能去成E，却成就了在NetScreen一段难得的startup经历。因为大环境的原因和执行层的问题，E不断走下坡路，最终那个朋友离开并加入Cisco。在最近的一次layoff中，他不幸中枪，现在还在艰难地寻找工作 —— 可竞争是如此激烈，他尽管曾经是个非常smart的工程师（现在如何不得而知），可年逾半百，和二三十岁同样smart，又精力充沛的工程师相比，已不具优势。F君说：我们做事要顺势而为，台风吹过的时候猪都能飞起来。炒股如此，工作如此，做startup亦如此。Totally agree。</p>
<p>（五）</p>
<p>这次来Sunnyvale，看到种种问题，我都痛心疾首。但这似乎是大公司的通病。有几个CNRD的工程师在外面转了一圈又回来，发现其实各个公司，EMC，Symantic，Microsoft，bla bla bla都差不多。一个公司就像一个人，从出生（startup），到成人（有些可能中途夭折），到壮年，到老年，到死亡。大家都在提基业长青，可真正存活百年以上屹立不倒的公司有几个呢？这似乎是个颠扑不破的自然规律。想想二十四史，里面发生的事情何其相似！不过话又说回来，如果大公司一直保持startup的状态，没有各种政治，产品不是政治妥协的产物，没有各种奇葩process，没有各种制肘，也不犯那些比较愚蠢的错误，那startup的生存空间何在？冥冥中自有天意，也许唯有这样，经济社会才能正常循环，生生不息。</p>
]]></description>
            <link>http://tchen.me/posts/2014-01-11-sunnyvale-trip.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-01-11-sunnyvale-trip.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Sat, 11 Jan 2014 14:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[盘点我的2013]]></title>
            <description><![CDATA[<p>提笔（确切地说，敲下键盘）开始盘点我的2013时，我感觉 <a href="http://tchen.me/posts/2012-12-28-retrospect-of-the-year-2012.html">回顾我的2012</a> 和 <a href="http://tchen.me/posts/2012-12-29-2013-things-to-do.html">展望2013</a> 似乎就在眼前。都说岁月催人，这哪是催，这是赶。无论心智是否更成熟，知识经验是否更丰富，过了一年，就老了一岁，去年的那支影子也渐行渐远。多愁善感并不单是文人的专利，年过三十后，我也染上了这臭毛病。太白说『白发三千丈，缘愁似个长。不知明镜里，何处得秋香！』（好吧，是秋霜 ^_^），本不大懂，但经历了2013这奇特，曲折，煎熬，仿佛过去的十年职场都被挤压收缩的一年后，我很能理解他那种年过半百，壮志未酬，人已衰老的那种痛苦。</p>
<!--more-->

<p>这一年经历了太多太多。</p>
<h2>大事记</h2>
<ul>
<li>1月：创业公司走到十字路口，向左走寻不到『生机』，向右转看不到『光明』。两权相害取其轻，不得已放弃『光明』选择『生机』，忍痛送别一个又一个战友。月底站完最后一班岗，正式自我放逐。</li>
<li>2月：拒绝了不少创业团队的邀请后，整天泡在国图看书，写书（创业回忆录『途客们的旅行梦』），同时思考未来，寻求出国工作的机会，但四处碰壁。离开的战友开始一个个找到工作，看在眼里，暖在心头。</li>
<li>3月：两年来在收入上对自己的吝啬让家里的经济状况开始触及红线，考虑到孩子的奶粉钱，无法留出哪怕一个 gap month。就业之紧迫感，为人父之责任感，应『劫』而生。在老领导的奔走帮忙下，虽应聘PLM无疾而终，但阴差阳错被AK激励重回旧地，重操旧业。一切尘埃落定后，当晚订机票酒店，第二天带着四个月大的小宝飞海南度假。</li>
<li>4月：两年前的3月31日离开，这月8日回归。打开邮箱，看到两年前的goodbye邮件的各种回复，有种时空错乱的感觉。人还是那群人，事还是那些事，仿佛我从未离开，仅仅是休了一周的PTO。那逝去的两年时光，就像一滴水汇入大海，瞬间消散地无影无踪。</li>
<li>5月：为了给小宝做视频，看了几个imovie的教程，拿team building和CNRD spring event练手，阴差阳错地被视为视频编辑能手。所谓劳者多能，我的视频编辑能力就这样一步步成长起来。此外，公司要求招聘要做code exam，于是我便花了个周末（及后续的n个晚上），做了 <a href="https://github.com/tyrchen/vint">vint</a> &amp; <a href="https://github.com/tyrchen/cerf">cerf</a> 这对鸳鸯来提供code exam。自此我个人的开源项目都使用计算机科学家的名字来命名，如：church，kahn，karp，etc.</li>
<li>6月：感觉Cliff track PR很辛苦，team用excel汇报PR状态也很痛苦，做了个爬虫，及其衍生出的网站，来减轻这一负担。同月得到机会去美国出差参加global TL meeting。Staybridge没有变化，North Mathilda似乎还是老样子，不过公司搬到了新楼，会议室门口都挂着ipad，有种土豪的感觉。</li>
<li>7月：迷恋上erlang。飞内蒙给老婆的爷爷过九十大寿。写下长文 <a href="http://tchen.me/posts/2013-07-27-the-remains-of-the-day.html">长日无痕</a>，平日门可罗雀的博客变得宾客盈门。</li>
<li>8月：人生中第一次恐怕也是最后一次因公出差去印度。由于种种原因，停止更新正在写的『途客们的旅行梦』。已写的很多内容也一直未能对外开放。也许明年下半年，这些文档才能逐渐解密。</li>
<li>9月：在茫茫bug中迷茫与彷徨。创业圈离我渐行渐远。更新了 <a href="https://github.com/tyrchen/teamspark">teamspark</a>，让其终于赶上 <a href="http://meteor.com">meteor</a> 0.6.x 的脚步。</li>
<li>10月：和美国一个team吵得不可开交。人生中还从未因工作的事如此愤怒。</li>
<li>11月：小宝满周岁，越南芽庄庆生。度假前后的三周里我每周完成一个feature，找到些成就感，也一扫十月的阴霾。</li>
<li>12月：出乎意料地在reorg中换了老板。接下来的至少一个季度，我将不得不与彼得定律『在一个等级制度中，每个职工趋向于上升到他所不能胜任的地位』抗争，来证明自己还未上升到不能胜任的地位。因为工作的需要，学习golang，一股脑写下了千余行代码，演练各种语言特性。</li>
</ul>
<h2>数字来说话</h2>
<h3>博客和文章</h3>
<p>对比2012年末做的2013展望，除了涉及的计算机书籍基本没读外，其他都做得还可以。博客当然没达到每周更新的频率，但也在抽风似地螺旋前进。</p>
<table>
<thead>
<tr>
<th align="center">Month</th>
<th align="center">Posts</th>
<th align="center">Published</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Jan</td>
<td align="center">7</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">Feb</td>
<td align="center">6</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">Mar</td>
<td align="center">4</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">Apr</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">May</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">Jun</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">Jul</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">Aug</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">Sep</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">Oct</td>
<td align="center">4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">Nov</td>
<td align="center">9</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">Dec</td>
<td align="center">4*</td>
<td align="center">4*</td>
</tr>
<tr>
<td align="center">Total</td>
<td align="center">45</td>
<td align="center">35</td>
</tr>
</tbody>
</table>
<p>实际发表数在每周 0.67 的水平，2014年争取达到 1。此外在 <a href="http://medium.com">Medium</a> 撰写五篇文章，发表两篇：<a href="https://medium.com/i-m-h-o/231d7499a75">Programmer&#39;s Dilemma</a> 和 <a href="https://medium.com/this-happened-to-me/8b2607eed960">Having a harse boss</a>。</p>
<table>
<thead>
<tr>
<th align="left">Title</th>
<th align="center">Views</th>
<th align="center">Reads</th>
<th align="center">Recs</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Programmer&#39;s dilemma</td>
<td align="center">54.1K</td>
<td align="center">45.2K</td>
<td align="center">123</td>
</tr>
<tr>
<td align="left">Having a Harsh boss</td>
<td align="center">911</td>
<td align="center">672</td>
<td align="center">6</td>
</tr>
</tbody>
</table>
<p>两者悬殊巨大，原因在于 [P] 被读者推到了 <a href="https://news.ycombinator.com/item?id=6221117">hacker news</a> 上，并引发激烈讨论。另外，此文更容易引发争议，而争议引发激辩，是眼球的重要来源。</p>
<h2>项目及代码</h2>
<p>2013新创建了不少项目，完成的项目或者说基本功能可用的大致如下：</p>
<table>
<thead>
<tr>
<th align="right">Projects</th>
<th align="right">Commits</th>
<th align="right">LOC</th>
<th align="center">Lang</th>
<th align="left">Intro</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">Vint</td>
<td align="right">22</td>
<td align="right">707</td>
<td align="center">python</td>
<td align="left">exam client</td>
</tr>
<tr>
<td align="right">Cerf</td>
<td align="right">54</td>
<td align="right">26534</td>
<td align="center">python</td>
<td align="left">exam server</td>
</tr>
<tr>
<td align="right">Church</td>
<td align="right">40</td>
<td align="right">24218</td>
<td align="center">python</td>
<td align="left">team bug tracking system</td>
</tr>
<tr>
<td align="right">Gnats</td>
<td align="right">19</td>
<td align="right">350</td>
<td align="center">python</td>
<td align="left">gnats crawler for church</td>
</tr>
<tr>
<td align="right">jd</td>
<td align="right">17</td>
<td align="right">394</td>
<td align="center">python</td>
<td align="left">company directory crawler for church</td>
</tr>
<tr>
<td align="right">kahn</td>
<td align="right">39</td>
<td align="right">421</td>
<td align="center">nodejs</td>
<td align="left">company directory and gnats api for church</td>
</tr>
<tr>
<td align="right">karp</td>
<td align="right">12</td>
<td align="right">6840</td>
<td align="center">python</td>
<td align="left">a set of tools for internal use</td>
</tr>
<tr>
<td align="right">matrix</td>
<td align="right">4</td>
<td align="right">515</td>
<td align="center">python</td>
<td align="left">a hackathon project for downloading internal resources</td>
</tr>
<tr>
<td align="right">tracker</td>
<td align="right">31</td>
<td align="right">33781</td>
<td align="center">python</td>
<td align="left">a hackathon project for easing management tracking problems</td>
</tr>
<tr>
<td align="right">calcapp</td>
<td align="right">45</td>
<td align="right">16540</td>
<td align="center">golang</td>
<td align="left">a breakable project for learning golang</td>
</tr>
</tbody>
</table>
<p>注意: </p>
<p>[1] 获取git diff:</p>
<pre><code>$ git log --author=&quot;YOUR NAME&quot; --pretty=tformat: --numstat | gawk &#39;{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf &quot;added lines: %s removed lines : %s total lines: %s\n&quot;,add,subs,loc }&#39;</code></pre>
<p>这条命令需要gawk，如果你的系统中没有，可以使用 <code>apt-get</code> (ubuntu) or <code>brew</code> (osx) 来安装.</p>
<p>[2] 获取git commits数量:</p>
<pre><code>$ git shortlog --numbered --summary</code></pre>
<p>[3] 代码行数不太准确，有几个web项目偏大。这是因为把第三方的javascript也包含进去了。所以那些超过万行代码的，把前边的一位数去掉就差不多。</p>
<h2>个人奥斯卡颁奖</h2>
<p>以下各大奖项都和我有关，和您无关。我评我的奖，自娱我的乐。</p>
<h3>最刻骨铭心</h3>
<p>没有任何悬念，最刻骨铭心当属我亲手裁去一半的team，并随后离开途客圈。个中滋味，外人是体会不到的。</p>
<p>本想将当时我发的邮件和日记在此公开，但考虑到保密协议，一年后再补吧（如果我还记得的话）。</p>
<h3>最深刻教训</h3>
<p>全年我领悟了很多教训，包括但不限于：</p>
<ul>
<li>北美找工作。如果想申请美国的工作机会，在前一年11月就要动手。近些年H1B基本4月初就被抢光，倒推下来能为你申请H1B的公司，他们内部可能1-2月就已经对H1B申请freeze了，所以早动手没坏处。</li>
<li>创业投融资。（见下）</li>
<li>工作生活的平衡。去年末小宝降临（源于去年初的意外）打破了我工作（创业）与生活的平衡。每周80小时的工作必然引发家庭中的诸多矛盾，这种状态是不可持续的。工作（创业）不是一个人的事，它与家庭息息相关。</li>
<li>...</li>
</ul>
<p>入围教训：创业投融资，工作生活的平衡</p>
<p>获奖教训：创业投融资</p>
<p>在创业投融资方面，刻骨铭心的教训是：</p>
<ol>
<li>如果你投入自有资金创业，在找到 product/market fit 前不要着急融资。对我和我的创业伙伴而言，50万人民币的自有资金只能给我们差不多半年的试错机会。我们要么在挣扎中找到收入来源，建立可持续的商业模式，要么破产清算。前者自不必说，后者能让我们更早更快地失败，最小化时间成本。而在没有做到 product/market fit 前的盲目融资，会让一切变得不再紧迫，大家的专注力下降（因为各种可能性，各种方向增多了），有种温水煮青蛙的感觉。</li>
<li>如果在创业之初有了产品后就奔着融资去，则不要投入自有资金，即使投入，也将其作为公司的债务。相对于融资额而言，个人投入的资金对公司后期的发展而言杯水车薪，而往往对自己的家庭影响巨大。以我为例，25万元人民币的投资在50万美元前不值一提，但这确是我当时家庭可动用的全部积蓄。之前自己有没有投钱，在融资时对创始人的股份，地位影响基本为零，而融资时投资条款中100%会出现的各种优先条款会让你个人的投入变成毫无意义的数字。</li>
<li>目前还不便透露，也许一两年后可以解密。</li>
</ol>
<p>综合以上，更合理的创业公司设置是：使用尽可能少的钱作为公司的注册资本（最新的法规应该已取消最低注册资本的要求，所以理论上1元钱可以注册公司），然后将要投入的钱作为公司向个人的短期借贷，也就是债务。当公司运作良好，融资与否债务都可以收回；当公司破产清算，债权清偿后才轮到股权清偿。这样能最大程度保护创始人自己的利益，不至于一次创业失败，失血过多，短期内很难东山再起。</p>
<p>所以，创业投融资获得最深刻教训奖绝对众望所归。</p>
<h3>最意外事件</h3>
<p>入围事件：</p>
<ul>
<li>回到Juniper。</li>
<li>google I/O 抢到票，行程已定，却在可退票的最后关头因种种原因取消。</li>
<li>在芽庄度假即将结束前一天，小宝高烧至39度。</li>
<li>reorg后被更换老板。</li>
<li>08年和09年申请的两个invention disclosure在今年正式成为US patent。</li>
</ul>
<p>获奖事件：回到Juniper</p>
<p>回归需要勇气，也需要运气。</p>
<h3>最佳阅读</h3>
<p>2013读了不少书，哲学，小说和创业相关的书最多。我有意减少了技术书籍的阅读，一来 online document，<code>wikipedia</code> 和 <code>stackoverflow</code> 足以弥补 99% 的知识，二来我希望涉猎更广些。</p>
<p>入围书籍：『长日留痕』，『西游论心』+ 『西游记』，『Programming Erlang』，『中国哲学史大纲』</p>
<p>获奖书籍：『西游论心』+ 『西游记』</p>
<p>以前读过好几遍『西游记』，但最后一次读西游还在高中。看完吴闲云的『解读西游记』和『再探西游记』，总觉见解虽很新奇，但有诸多漏洞，戏谑成分大些。而我无意中拾起的『西游论心』，从儒释道，易医巫几方面解读西游，很有滋味。边读『西游论心』边对着原文一点点啃，劲道十足。不得不说，是『西游论心』促使我十几年后重拾『西游记』这部巨著。</p>
<h3>最佳个人项目</h3>
<p>入围项目：</p>
<ul>
<li>代码机考系统。<a href="https://github.com/tyrchen/vint">vint</a> &amp; <a href="https://github.com/tyrchen/cerf">cerf</a>.</li>
<li>matrix。一个提供类似git命令行的下载工具。用于下载jive space里的文档。（内部项目）。</li>
</ul>
<p>获奖项目：matrix</p>
<p>vint &amp; cerf 很可惜，虽然我们已经使用它管理和组织了上百次code interview，但它还不是理想中的产品。功能稍嫌薄弱，也不足够简单。所以这个奖项给了matrix —— 这个从产品构想到实现我仅仅花了两三个小时就完成的项目。它足够简单，非常实用。TTI（Time to implementation）趋近于零，而ROI（Return on investment）却非同小可（省了我很多时间）。</p>
<h3>最有价值文章</h3>
<p>入围文章：<a href="http://tchen.me/posts/2013-07-27-the-remains-of-the-day.html">长日无痕</a>，<a href="http://tchen.me/posts/2013-07-22-why-should-c-programmers-learn-erlang.html">Erlang</a>，<a href="http://tchen.me/posts/2013-03-08-career-path-for-software-engineer.html">瞎扯软件工程师的职业生涯</a>，<a href="http://tchen.me/posts/2013-02-06-Making-a-next-generation-home-security-device.html">创建下一代家用防火墙</a></p>
<p>获奖文章：创建下一代家用防火墙</p>
<p>这是年初的一篇文章，大胆地构想了一种全新的智能家用网络（安全）产品的商业模式。从市场的角度来看，一个家庭基本上只会有一个网络设备，所以带有安全功能的网络连接设备最终会不可逆地取代单一功能的路由产品；从可用性来说，家用网络设备要尽可能地将IP/MAC，各种网络协议等术语隐藏起来，代之以人性化的命名。一条安全策略应该是：<code>孩子的ipad 禁止访问 黄色网站</code>，而不是只有专家才能看懂的配置；从智能化角度来说，利用云计算和大数据处理能力，将复杂计算，预测，防护和各种高级功能都云端化；从商业角度来看，硬件厂商最终不通过硬件本身赚钱（甚至免费为用户定期更新硬件），而通过ARPU持续产生收入。</p>
<h3>最有价值知识</h3>
<p>入围知识：<a href="http://en.wikipedia.org/wiki/Lean_Startup">lean startup</a>，<a href="http://steveblank.com/category/customer-development/">Customer development method</a>，<a href="http://paulgraham.com/ds.html">Do things that don&#39;t scale</a>，<a href="http://www.triz40.com/aff_Principles.htm">Triz 40 principles</a></p>
<p>获奖知识：Triz 40 principles</p>
<p>Triz背后的研究团队研究了40, 000个patents，从各个patent中和已有patent的delta中，试图找到创新活动的特征。最终他们得到了这40组principle，对创新很有指导意义。对我而言，知道这个结论产生的过程远比知道这个结论要震撼得多 —— 研究40,000个patents，这得花多大的功夫和毅力？</p>
<h3>最佳程序语言</h3>
<p>入围语言：c，python，golang，javascript，erlang</p>
<p>获奖程序语言：python</p>
<p>这些语言是我在2013年来写过有意义的项目的语言，玩票性质的 io，scala，elixir，emacslisp 不在此列。python获奖实至名归，我这一年来写的80%的代码都是python。尽管我倾注了不少精力向javascript倾斜，但真要甩着膀子大干一场，指尖下流出的还是python。（这就是爱啊）</p>
<p>什么？我的工作语言是C？好吧，大多数时间里C让我有钱花，而Python让我快乐。</p>
<h3>最佳社区贡献</h3>
<p>2013我对社区的贡献少得可怜，虽然写了不少开源的项目，但要么自娱自乐，要么为某一特定目的而作，对社区基本没什么价值。下面两个算是矮子里拔将军，勉强可以充数。</p>
<p>入围社区贡献：<a href="https://github.com/tyrchen/teamspark">teamspark</a>，<a href="http://stackoverflow.com/questions/20671535/why-this-code-generate-very-big-executable-in-go-around-81m">go compiler bug</a></p>
<p>获奖社区贡献：go compiler bug</p>
<p>在学习go语言的过程中，无意中发现在某种特定情况下，go的编译器会生成非常巨大的可执行文件。在stackoverflow上发问后，得到了有意思的答案，并促使我进一步去研究问题的原因和workaround。twitter上有人<a href="https://twitter.com/davecheney/status/413794697966936064">对此讨论</a>，并建议我给go <a href="https://code.google.com/p/go/issues/detail?id=6993">提交bug</a>。所以这个对社区的价值要比我用 <a href="http://meteor.com">Meteor</a> 写的 teamspark 要高。</p>
<h3>最佳进步</h3>
<p>入围事件：</p>
<ul>
<li>从golang hello world新手到写下有价值代码的 <strong>学徒</strong>，仅仅花了一周多的业余时间。在为一个项目写下1339行代码后，我已经正式步入golang学徒生涯。</li>
<li>从对编剧一无所知到写下一个自我感觉还过得去（比百度文档中找到的那些强多了），有故事，有笑点，结合公司内外大小诸事的剧本，仅花了半天时间。从此我正式跨入业余编剧的行列。</li>
<li>看了几个youtube教程后，我便走上了视频制作和剪辑之路。全年产出9个质量还过得去的视频。</li>
</ul>
<p>获奖事件：一周多学会golang</p>
<p>如果说C和python是我的现金奶牛事业部，那么golang则是我的未来发展事业部。至于编剧和视频剪辑嘛，在可预见的未来，他们都还是cost center。所以 &quot;一周多学会golang&quot; 拿下最佳进步奖当之无愧。</p>
<h3>最美滋味</h3>
<p>在劳碌了一天，拖着疲惫的身子回家，有什么能比得上我的心肝宝贝一句酥麻入骨的『爸爸』来得美妙？毫无悬念，这一年最美的滋味就是我那宝贝女儿。从学会翻身，到能坐起来，从勉强行走到奔走如飞，从只会叫大大，到十几个单词量，她带给我数不胜数的美妙感受。工作郁闷且又无法发泄时，想想她萌萌的表情，想想她动听的声音，快乐就从心底涌出，融掉了一切烦恼……</p>
<p>太久没放她的照片，这下一次就是五张！我会努力做一个称职的父亲滴！</p>
<p><img src="/assets/files/photos/baby20131224-1.jpg" alt="小宝">
<img src="/assets/files/photos/baby20131224-2.jpg" alt="小宝">
<img src="/assets/files/photos/baby20131224-3.jpg" alt="小宝">
<img src="/assets/files/photos/baby20131224-4.jpg" alt="小宝">
<img src="/assets/files/photos/baby20131224-5.jpg" alt="小宝"></p>
<h2>尾声</h2>
<p>啰啰唆唆写了这么多，还意犹未尽。暂且停笔，日后再慢慢修葺。千言万语都道不尽的2013，即将从指尖溜走；而我的2014，则注定会多姿多彩。</p>
]]></description>
            <link>http://tchen.me/posts/2013-12-23-my-year-2013.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-12-23-my-year-2013.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Mon, 23 Dec 2013 14:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[建立自己的docker repository]]></title>
            <description><![CDATA[<p>如果你不知道docker是什么，请参考 <a href="http://www.slideshare.net/dotCloud/why-docker">这个slides</a>。</p>
<p>在 ubuntu 下安装 docker 请参考 <a href="http://docs.docker.io/en/latest/installation/ubuntulinux/">官方教程</a> 。注意，由于 docker 的核心技术是 <a href="http://en.wikipedia.org/wiki/LXC">Linux container</a>，所以如果想在 osx 下安装 docker 请使用 vagrant。</p>
<!--more-->

<h2>安装docker-registry</h2>
<p>首先clone docker-registry：</p>
<pre><code>$ git clone https://github.com/dotcloud/docker-registry
$ cd docker-registry

$ cp config_sample.yml config.yml</code></pre>
<p>然后打开 <code>config.yml</code>，设置dev（缺省）的storage路径为 <code>/var/docker/registry</code>：</p>
<pre><code># This is the default configuration when no flavor is specified
dev:
    storage: local
    storage_path: /var/docker/registry
    loglevel: debug</code></pre>
<p>创建这个目录：</p>
<pre><code>$ sudo mkdir -p /var/docker/registry
$ sudo chown -R tchen /var/docker</code></pre>
<p>docker-registry使用了python，需要以下库的支持：</p>
<pre><code>$ sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev</code></pre>
<p>然后建立 <code>virtualenv</code> 并安装requirements：</p>
<pre><code>$ sudo pip install virtualenv
$ virtualenv --no-site-packages venv
$ . venv/bin/activate
$ pip install -r requirements.txt</code></pre>
<h2>配置supervisor</h2>
<p>如果系统没有安装supervisor，请先安装:</p>
<pre><code>$ sudo apt-get install supervisor</code></pre>
<p>安装完成后，配置 <code>supervisor</code>：</p>
<pre><code>$ sudo vim /etc/supervisor/conf.d/docker-registry.conf</code></pre>
<p>填入以下内容：</p>
<pre><code>[program:docker-registry]
directory=/home/dev/deployment/docker-registry
user=dev
command=/home/dev/deployment/docker-registry/venv/bin/gunicorn -b 0.0.0.0:7030 -k gevent --max-requests 100 --graceful-timeout 3600 -t 3600 -w 8 wsgi:application
redirect_stderr=true
stderr_logfile=none
stdout_logfile=/var/log/supervisor/docker-registry.log
autostart=true
autorestart=true</code></pre>
<p>重新加载 <code>supervisor</code> 配置：</p>
<pre><code>$ sudo supervisorctl
supervisor&gt; reread
docker-registry: available
supervisor&gt; update
docker-registry: added process group
supervisor&gt; status
docker-registry                  RUNNING    pid 4371, uptime 0:00:01</code></pre>
<p>这样，<code>docker-registry</code> 服务就正常运行了。</p>
<h2>配置nginx</h2>
<p>接下来把 <code>nginx</code> request proxy 到 <code>docker-registry</code> app 就大功告成了。</p>
<pre><code>$ sudo vim /etc/nginx/sites-available/docker-registry</code></pre>
<p>填入以下内容：</p>
<pre><code>server {
  listen 80;
  client_max_body_size 200m;
  server_name docker.your-domain.com;
  access_log /var/log/nginx/docker-registry.access.log;
  error_log /var/log/nginx/docker-registry.error.log;
  location / {
    proxy_pass http://localhost:7030;
    include /etc/nginx/proxy_params;
  }
}</code></pre>
<p>然后将其加入 <code>sites-enabled</code> 并重启nginx：</p>
<pre><code>$ cd /etc/nginx/sites-enabled/
$ sudo ln -s ../sites-available/docker-registry docker-registry
$ sudo /etc/init.d/nginx restart</code></pre>
<p>把 <code>docker</code> 二级域名加入到你的域名服务器中，然后打开浏览器访问 <code>http://docker.your-domain.com</code> 就可以看到如下页面：</p>
<pre><code>&quot;docker-registry server (dev)&quot;</code></pre>
<p>至此，<code>docker-registry</code> 就正常运行了。</p>
<p>接下来看看系统都有哪些 docker images：</p>
<pre><code>(venv)tchen@docker:~$ sudo docker images
REPOSITORY                            TAG                   IMAGE ID            CREATED             SIZE
colinsurprenant/ubuntu-raring-amd64   latest                2eb422301015        6 weeks ago         91.89 MB (virtual 91.89 MB)
colinsurprenant/ubuntu-raring-amd64   raring-amd64          2eb422301015        6 weeks ago         91.89 MB (virtual 91.89 MB)
colinsurprenant/ubuntu-raring-amd64   ubuntu-raring-amd64   22ca6d4b1576        6 weeks ago         91.89 MB (virtual 91.89 MB)
ubuntu                                12.04                 8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                latest                8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                precise               8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                12.10                 b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
ubuntu                                quantal               b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-12.10          b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantal        b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantl         b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)</code></pre>
<p>我们选择 <code>base</code> 对应的 image，将其 push 到自己的服务器。首先将其标记为要push到自己的服务器：</p>
<pre><code>$ sudo docker tag b750fe79269d docker.your-domain.com/tchen/base</code></pre>
<p>然后push:</p>
<pre><code>$ sudo docker push docker.your-domain.com/tchen/base
The push refers to a repository [docker.your-domain.com/tchen/base] (len: 1)
Sending image list
Pushing repository docker.your-domain.com/tchen (1 tags)
Pushing 27cf784147099545

2013/11/12 03:35:18 Received HTTP code 413 while uploading layer: &lt;html&gt;
&lt;head&gt;&lt;title&gt;413 Request Entity Too Large&lt;/title&gt;&lt;/head&gt;
&lt;body bgcolor=&quot;white&quot;&gt;
&lt;center&gt;&lt;h1&gt;413 Request Entity Too Large&lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx/1.4.3&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>如果出现以上错误，请修改之前nginx配置中的 <code>client_max_body_size 200m;</code>，将其扩大至能够容纳你的image。</p>
<p>成功后可以看到：</p>
<pre><code>$ sudo docker images
REPOSITORY                            TAG                   IMAGE ID            CREATED             SIZE
colinsurprenant/ubuntu-raring-amd64   latest                2eb422301015        6 weeks ago         91.89 MB (virtual 91.89 MB)
colinsurprenant/ubuntu-raring-amd64   raring-amd64          2eb422301015        6 weeks ago         91.89 MB (virtual 91.89 MB)
colinsurprenant/ubuntu-raring-amd64   ubuntu-raring-amd64   22ca6d4b1576        6 weeks ago         91.89 MB (virtual 91.89 MB)
ubuntu                                12.04                 8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                latest                8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                precise               8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                12.10                 b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
docker.your-domain.com/base              latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
docker.your-domain.com/tchen             latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
docker.your-domain.com/tchen/base        latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
ubuntu                                quantal               b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-12.10          b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantal        b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantl         b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)</code></pre>
<p>本地的image就可用了，尝试一下：</p>
<pre><code>$ sudo docker run -i -t docker.your-domain.com/tchen/base /bin/bash</code></pre>
<p>在其他机器上要pull这个image，很简单：</p>
<pre><code>$ sudo docker pull docker.your-domain.com/tchen/base</code></pre>
]]></description>
            <link>http://tchen.me/posts/2013-11-13-local-docker-repo.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-11-13-local-docker-repo.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Wed, 13 Nov 2013 14:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Build Your Own Docker Registry with DigitalOcean]]></title>
            <description><![CDATA[<h1>Build Your Own Docker Registry with DigitalOcean</h1>
<p><a href="http://www.slideshare.net/dotCloud/why-docker">Docker</a> might be the most attracting open source technologies in 2013. By providing a higher level API and management UI, it make linux container much more usable. If you haven&#39;t tried it, <a href="http://www.docker.io/gettingstarted/">try it</a>. You will then feel it is &quot;<a href="http://blog.scoutapp.com/articles/2013/08/28/docker-git-for-deployment">the git for deployment</a>&quot;.</p>
<p>After you played with it for a while, enjoying the git like operation for your software and their dependencies, a natural question will appear: how can I build my own private docker registry that I could leverage for my own IT infrastructure? </p>
<p>The docker-registry comes to help you. docker-registry is a software to provide similar functionality as <a href="http://index.docker.io/">official docker index</a>, which is a central registry for you to commit your new images, pull existing ones, etc. It can let you to build your own docker registry that is private, secure and speedy.</p>
<h2>Install docker-registry</h2>
<p>First of all, let&#39;s clone docker-registry：</p>
<pre><code>git clone https://github.com/dotcloud/docker-registry
cd docker-registry
cp config_sample.yml config.yml</code></pre>
<p>You need then to open config.yml to set the dev (the default profile) storage to something like <code>/var/docker/registry</code>:</p>
<pre><code># This is the default configuration when no flavor is specified
dev:
    storage: local
    storage_path: /var/docker/registry
    loglevel: debug</code></pre>
<p>Then create this directory and grant </p>
<pre><code>sudo mkdir -p /var/docker/registry
sudo chown -R `whoami` /var/docker</code></pre>
<p>As docker-registry uses python and ssl, you need to install the following libraries:</p>
<pre><code>sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev</code></pre>
<p>Then you can setup your virtualenv and install requirements:</p>
<p>(optional) install virtualenv if you haven&#39;t:</p>
<pre><code>sudo pip install virtualenv</code></pre>
<p>setup virtualenv:</p>
<pre><code>virtualenv --no-site-packages venv
. venv/bin/activate
pip install -r requirements.txt</code></pre>
<p>Now your docker-registry should be run via:</p>
<pre><code>gunicorn -k gevent --max-requests 100 --graceful-timeout 3600 -t 3600 -b localhost:8080 -w 8 wsgi:application</code></pre>
<p>You can open your browser on <code>http://localhost:8080</code> to see if it works. It should show you:</p>
<pre><code>&quot;docker-registry server (dev)&quot;</code></pre>
<p>Congratulations! The minimum installation is done. However, if you want to run it like a normal service, you need to configure supervisor and nginx. Let&#39;s continue our journey.</p>
<h2>Run docker-registry as a service</h2>
<p>If you don&#39;t have supervisor installed, please install it firstly:</p>
<pre><code>sudo apt-get install supervisor</code></pre>
<p>Then add a new configuration file:</p>
<pre><code>sudo vim /etc/supervisor/conf.d/docker-registry.conf</code></pre>
<p>In the opened vim editor, copy and paste the following content, save and quit (you need to change dev to your local user):</p>
<pre><code>[program:docker-registry]
directory=/home/dev/deployment/docker-registry
user=dev
command=/home/dev/deployment/docker-registry/venv/bin/gunicorn -b 0.0.0.0:7030 -k gevent --max-requests 100 --graceful-timeout 3600 -t 3600 -w 8 wsgi:application
redirect_stderr=true
stderr_logfile=none
stdout_logfile=/var/log/supervisor/docker-registry.log
autostart=true
autorestart=true</code></pre>
<p>Then reload supervisor to make it take effects.</p>
<pre><code>$ sudo supervisorctl
supervisor&gt; reread
docker-registry: available
supervisor&gt; update
docker-registry: added process group
supervisor&gt; status
docker-registry                  RUNNING    pid 4371, uptime 0:00:01</code></pre>
<p>If you see RUNNING int the status output, then it means your docker-registry is up and running normally. If not, please got to <code>/var/log/supervisor/docker-registry.log</code> to see what happened.</p>
<p>Next you need to use nginx to proxy the requests to docker-registry. If you don&#39;t have nginx installed, please install it firstly:</p>
<pre><code>sudo apt-get install nginx</code></pre>
<p>Then add a new configuration file:</p>
<pre><code>sudo vim /etc/nginx/sites-available/docker-registry</code></pre>
<p>Copy and paste the following content, then save and quite:</p>
<pre><code>server {
  listen 80;
  client_max_body_size 200m;
  server_name your-domain.com;
  access_log /var/log/nginx/docker-registry.access.log;
  error_log /var/log/nginx/docker-registry.error.log;
  location / {
    proxy_pass http://localhost:8080;
    include /etc/nginx/proxy_params;
  }
}</code></pre>
<p>Note that you need <code>client_max_body_size 200m</code> to allow big file post. If later your found error like:</p>
<pre><code>2013/11/12 03:35:18 Received HTTP code 413 while uploading layer</code></pre>
<p>You need to enlarge this value.</p>
<p>Then you need to soft link this file to <code>sites-enabled</code> and restart nginx:</p>
<pre><code>cd /etc/nginx/sites-enabled/
sudo ln -s ../sites-available/docker-registry docker-registry
sudo service nginx restart</code></pre>
<p>Open your browser to visit <code>http://your-domain.com</code>, you should see the same result as previous step:</p>
<pre><code>&quot;docker-registry server (dev)&quot;</code></pre>
<h2>Use your private docker registry</h2>
<p>First of all, let&#39;s see what images we have so far:</p>
<pre><code>$ sudo docker images
REPOSITORY                            TAG                   IMAGE ID            CREATED             SIZE
ubuntu                                12.04                 8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                latest                8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                precise               8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                12.10                 b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
ubuntu                                quantal               b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-12.10          b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantal        b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantl         b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)</code></pre>
<p>If you don&#39;t have any docker images, please use <code>sudo docker pull base</code> to pull base images from docker repository.</p>
<p>We would like to push the base image to our own shiny registry. First of all, tag it to push to your own server:</p>
<pre><code>sudo docker tag b750fe79269d your-domain.com/yourname/base</code></pre>
<p>Then push:</p>
<pre><code>sudo docker push your-domain.com/yourname/base</code></pre>
<p>If push succeeded, you will see your images with <code>docker images</code>:</p>
<pre><code>$ sudo docker images
REPOSITORY                            TAG                   IMAGE ID            CREATED             SIZE
ubuntu                                12.04                 8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                latest                8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                precise               8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                12.10                 b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
your-domain.com/yourname/base        latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
ubuntu                                quantal               b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-12.10          b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantal        b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantl         b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)</code></pre>
<p>It is already available locally, so you can try it：</p>
<pre><code>sudo docker run -i -t your-domain.com/yourname/base /bin/bash</code></pre>
<p>If you want to pull this image from other machine, just use:</p>
<pre><code>sudo docker pull your-domain.com/yourname/base</code></pre>
<p>Have fun!</p>
]]></description>
            <link>http://tchen.me/posts/2013-11-13-local-docker-repo-en.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-11-13-local-docker-repo-en.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Wed, 13 Nov 2013 14:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[使用HTTPS]]></title>
            <description><![CDATA[<p>如今随着网上交易规模不断扩大及API驱动的互联网的出现（如 <a href="https://strip.com">https://strip.com</a> ），互联网的安全性越来越受到重视。本文简单讲述如何将你的nginx配置成支持https的web server。当然，理论上一个合格的https server需要从CA那里获得正式的SSL certificate，但如何购买SSL certificate不在本文讨论之列。本文仅从技术上讨论如何在你的服务器上使能https。</p>
<!--more-->

<h2>生成证书</h2>
<h3>生成RSA key</h3>
<p>首先生成本地的RSA key，我们使用1024 bit的密钥。pass phrase一定要输入，并且输入的pass phrase在接下来的步骤中要使用。</p>
<pre><code>sudo mkdir /etc/nginx/ssl
cd /etc/nginx/ssl
$ sudo openssl genrsa -des3 -out myserver.key 1024
[sudo] password for tchen:
Generating RSA private key, 1024 bit long modulus
.....++++++
.++++++
e is 65537 (0x10001)
Enter pass phrase for myserver.key:
Verifying - Enter pass phrase for myserver.key:
`</code></pre>
<h3>生成csr (Certificate Signing Request)</h3>
<p>CSR包含能够鉴别证书申请人的信息。关于CSR及X.509证书的详细说明，请参考：<a href="http://en.wikipedia.org/wiki/Certificate_signing_request。">http://en.wikipedia.org/wiki/Certificate_signing_request。</a></p>
<pre><code>$ sudo openssl req -new -key myserver.key -out myserver.csr
Enter pass phrase for myserver.key:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter &#39;.&#39;, the field will be left blank.
-----
Country Name (2 letter code) [AU]:CN
State or Province Name (full name) [Some-State]:Beijing
Locality Name (eg, city) []:BJ
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Coderena
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:myserver.com
Email Address []:tchen@myserver.com

Please enter the following &#39;extra&#39; attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:</code></pre>
<h3>为csr签名</h3>
<p>首先要把刚才生成的RSA密钥的pass phrase移除：</p>
<pre><code>$ sudo openssl rsa -in myserver.key.org -out myserver.key
Enter pass phrase for myserver.key.org:
writing RSA key</code></pre>
<p>对CSR进行为期一年（365 days）的授权，生成证书：</p>
<pre><code>$ sudo openssl x509 -req -days 365 -in myserver.csr -signkey myserver.key -out myserver.crt
Signature ok
subject=/C=CN/ST=Beijing/L=BJ/O=Coderena/CN=myserver.com/emailAddress=tchen@myserver.com
Getting Private key</code></pre>
<h3>保护证书</h3>
<p>在当前目录下，把证书相关文件的权限改为只可自己读，防止他人使用或篡改。</p>
<pre><code>$ sudo chmod 600 *</code></pre>
<h2>设置nginx</h2>
<p>接下来就是设置网站使用证书。一般我们的app server（如nodejs或gunicorn）都部署在nginx或apache后，所以SSL可以在用户端和web server端使能，这样免去了为每个app server支持SSL的麻烦。这样做在web server和app server之间存在一定的安全风险，但一般而言，web server / app server都在同一个受信任的网络内，所以问题不大。</p>
<p>本文将讨论在nginx下配置SSL。假设在site-available下你有如下virtual host:</p>
<pre><code>server {
  listen 80;
  server_name myserver.com;
  set $current_root &quot;/home/dev/deployment/myserver&quot;;
  access_log /var/log/nginx/myserver.access.log;
  error_log /var/log/nginx/myserver.error.log;

  location ~* ^/media/ {
    autoindex off;
    root $current_root;
    expires max;
  }

  location ~* ^/static/ {
    autoindex off;
    root $current_root;
    expires 30d;
  }

  location / {
    proxy_pass http://localhost:7010;
    include /etc/nginx/proxy_params;
  }
}</code></pre>
<p>要对其使能https，首先，将所有http请求都跳转到https：</p>
<pre><code>server {
 listen      80;
 server_name myserver.com;
 rewrite     ^ https://$server_name$request_uri? permanent;
}</code></pre>
<p>接着配置https:</p>
<pre><code>server {
  listen 443;
  ssl on;
  ssl_certificate /etc/nginx/ssl/myserver.crt;
  ssl_certificate_key /etc/nginx/ssl/myserver.key;

  server_name myserver.com;

  set $current_root &quot;/home/dev/deployment/myserver&quot;;
  client_max_body_size 32m;

  access_log /var/log/nginx/myserver.access.log;
  error_log /var/log/nginx/myserver.error.log;

  location ~* ^/media/ {
    autoindex off;
    root $current_root;
    expires max;
  }


  location ~* ^/static/ {
    autoindex off;
    root $current_root;
    expires 30d;
  }

  location / {
    proxy_pass http://localhost:7010;
    include /etc/nginx/proxy_ssl_params;
  }

}</code></pre>
<p>我们之前使用的proxy params在 <code>proxy_params</code> 文件中：</p>
<pre><code>proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></pre>
<p>对于https，我们需要一个单独的 <code>proxy_ssl_params</code> 文件:</p>
<pre><code>proxy_redirect off;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto https;</code></pre>
<p>两者有一些差别。</p>
<p>至此，整个证书的生成及使用就完成了，重启nginx后打开浏览器就可以尝试。注意由于我们的证书是在本地签名的，不属于一个合法的CA授权的证书，所以浏览器会报警，继续浏览即可。虽然浏览器认为其安全性存在问题，但整个访问过程都是通过SSL进行加密的。</p>
<h2>补记</h2>
<p>如果要购买被验证的证书，需要花费一大笔美刀（比如Symantac的单服务器任意子域名3年有效的证书要$5095）。这么贵是有原因的：</p>
<ul>
<li>CA需要在技术上做大笔投入来保护自己的data center不被攻破。（想想看上百万的证书私钥对黑客有多大的吸引力，就像银行的金库一样）</li>
<li>CA往往对证书提供保险（上例中的证书有每年 $500, 000的保障，大致意思是如果证书被compromise，对于你的损失，我最高可以赔这些钱）。</li>
<li>SSL certificate是身份和实力的象征，大企业和创业土豪们不差钱。</li>
</ul>
<p>当然，如果你付不起这么多钱，很想使用https保护你的用户（但根本不需要巨额的保险），可以购买那些二三线的CA的证书。几美金到几十美金一年就可以搞定。这就跟把传家宝藏在瑞士银行的保险柜里和放在本地农商行的保险柜一个道理，一分钱一分货。</p>
<p>送上小宝照片一枚：</p>
<p><img src="/assets/files/photos/baby20131110.jpg" alt="小宝"></p>
]]></description>
            <link>http://tchen.me/posts/2013-11-11-https.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-11-11-https.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Sun, 10 Nov 2013 14:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Hatch: 实验]]></title>
            <description><![CDATA[<p>继续 <a href="/posts/2013-11-03-hatch-experiment.html">前文</a> 。熬到了周末，正式开始了 <code>hatch</code> 项目的开发。首先是一个关键问题：如果每个文件的生成由一个单一的shell脚本完成，那么数据库打开/关闭的损耗会不会成为瓶颈？做了个简单的实验，发现每次打开都要花费0.2s，一个不小的数字。</p>
<pre><code>➜  hatch git:(master) ✗ cat test.coffee
#!/usr/bin/env coffee

db = require(&#39;mongojs&#39;)(&#39;hatch&#39;)
col = db.collection(&#39;documents&#39;)

col.findOne {}, (err, doc) -&gt;
    db.close()</code></pre>
<pre><code>➜  hatch git:(master) ✗ time ./test.coffee
./test.coffee  0.20s user 0.03s system 99% cpu 0.226 total</code></pre>
<!--more-->

<p>这意味着照之前的设想，一千个文件如果都单独parse，那么仅数据库打开/关闭就需要200s，这是不可接受的。于是，最初的想法不得不调整。如果在一个大脚本中完成所有事情，显然是最经济的，但这样无法借助 <code>makefile</code> 的优势，于是妥协为：</p>
<ol>
<li>整个系统依旧由 <code>make</code> 驱动，除unix已有的工具外，撰写：<code>hatch-parse</code>，<code>hatch-gen</code>，<code>hatch-tag</code> 和 <code>hatch-index</code>。</li>
<li>所有这些脚本支持 <code>1..n</code> 个参数，为输入的文件名。</li>
<li>由于这样无法使用 <code>makefile</code> 中的依赖，所以需要一个 <code>hatch-diff</code> 为其提供参数。</li>
</ol>
<p>解释一下第三点：</p>
<p>如果 <code>hatch-gen</code> 只处理单个文件，那么 <code>makefile</code> 中的依赖关系很容易推导出需要处理的文件，并依次处理之：</p>
<pre><code>OUT=out
SRC=src
CONTENT_PATH=$(SRC)/contents
OUTS=$(subst $(SRC),$(OUT), $(shell find $(CONTENT_PATH) -type f -name &#39;*&#39;))

$(OUTS): $(OUT)%: $(SRC)%
    @echo &quot;Creating $@.&quot;
    @$(HATCH_GEN) $@ $&lt;</code></pre>
<p>但如果我们要处理大批文件，则不能这么做，所以我做了个 <code>hatch-diff</code> 来返回更改过的文件列表，于是 <code>makefile</code> 变为：</p>
<pre><code>generate:
    @$(HATCH_GEN) $(shell $(HATCH_DIFF) -e .html $(CONTENT_PATH) $(CONTENT_OUT_PATH))</code></pre>
<blockquote>
<p>注：写该代码时我还不知道 <code>makefile</code> 有 <code>$?</code> 这样的神器。所以其实 <code>hatch-diff</code>基本没用。</p>
</blockquote>
<h2>具体实现</h2>
<p>实现代码见：<a href="https://github.com/coderena/hatch">https://github.com/coderena/hatch</a>.</p>
<p>核心代码在 <code>lib/core.coffee</code>。目前实现得很简单，还没有进一步的命令行来帮助使用者创建项目。</p>
<p>测试代码在 <code>test</code> 下。</p>
<p>具体实现很简单，也很直接。就不讨论。</p>
<h2>问题与解决</h2>
<h3>加速，加速，加速！</h3>
<p>打开数据库的时间越滞后越好。</p>
<p>能通过 <code>makefile</code> 的 dependency 解决的就放在那里解决。数据库里的内容和磁盘上的文件谁新谁旧，可以通过建立这样的 dependency:</p>
<pre><code>$(CONTENT_DEPS): $(DEP)/%: $(SRC)/%
    @touch $@

content_depend: $(CONTENT_DEP_PATHS) $(CONTENT_DEPS)</code></pre>
<p>每次 parse 完磁盘文件就更新 dependency，这样一旦文件改变，make就能分析出要重新parse的文件。</p>
<p>牢记 <code>nodejs</code> 单线程的劣势，尽可能用asynchronous的库和代码。需要异步处理一堆事情，但要在所有处理完成后统一操作请使用 <code>async</code> 库。</p>
<p>为了提高速度，所有 <code>jade</code> 模板都预编译好，再和 <code>locals</code> 结合，生成html。</p>
<h3>绑定，绑定，绑定！</h3>
<p>跟 <code>docpad</code> 一样，我希望用户可以定制他们自己的helpers，在模板中使用。比如：</p>
<pre><code>hatchConfig =
    layoutData:
        site:
            # default url of the site
            url: &#39;http://hatch-jade-example.com&#39;
            # default time of the site
            title: &#39;Example website build with hatch&#39;

            getTitle: -&gt;

                if @document.title
                    &quot;#{@document.title} | #{@site.title}&quot;
                else
                    @site.title</code></pre>
<p>然后在模板中可以直接访问：</p>
<pre><code>extends common/default

block prepend title
  | #{ getTitle() }</code></pre>
<p>如果直接把 <code>layoutData</code> 传给 <code>jade</code> 去编译，<code>this</code> 并不存在，必然报错。所以需要为每个helper函数进行 <code>this</code> 的绑定，问题是，<a href="http://stackoverflow.com/questions/5999998/how-can-i-check-if-a-javascript-variable-is-function-type">怎么判断一个值是函数呢</a>？这是 javascript 语言中的又一个坑。我的项目中使用了 <code>lodash</code>，所以自然而然会使用 <code>_.isFunction()</code>:</p>
<pre><code>locals = {document: data}
_.extend locals, self.config.layoutData
    for own key, value of locals
        if _.isFunction value
            locals[key] = value.bind(locals)</code></pre>
<h3>处理teaser和长文的分页</h3>
<p>teaser一般是文章的头一段，在索引页中方便用户领略文章的大致内容。目前大部分静态网站生成器都使用html comment，如 <code>&lt;!--more--&gt;</code> 来达到这一目的，这样做有点问题：如果teaser之前有标题，那么标题也被包含在teaser里，展示效果不好，于是我采用下述方法定义teaser。用户仅需要在想标记为teaser的地方前后进行标注即可，不限于文章的任何部分，灵活性很好。</p>
<pre><code># teaser notation in the document
regexTeaser: /&lt;!--\s*teaser\s*--&gt;\s*([\s\S]*?)\s*&lt;!--\s*teaser\s*--&gt;/i</code></pre>
<p>长文的分页也是类似的想法。定义了 <code>&lt;!--page--&gt;</code>：</p>
<pre><code># page notation in the document
regexPager: /&lt;!--\s*page\s*--&gt;/</code></pre>
<p>可以这样来生成页面：</p>
<pre><code>@adapter.findOne src: src, (err, doc) -&gt;
    return cb(err) if err

    if doc
        generate_doc = (i, callback) -&gt;
            data = {}
            _.extend data, doc
            data.content = doc.contents[i]
            delete data.contents

            locals = {document: data}
            _.extend locals, self.config.layoutData
            for own key, value of locals
                if _.isFunction value
                    locals[key] = value.bind(locals)
            html = self.layouts[doc.layout] locals
            if i is 0
                filename = &quot;#{dst}.html&quot;
            else
                filename = &quot;#{dst}.#{i}.html&quot;
            fs.writeFile filename, html, (err) -&gt;
                callback err, filename

        async.map _.range(doc.contents.length), generate_doc, (err, data) -&gt;
            cb err, data</code></pre>
<h3>在jade里处理回调</h3>
<p>由于用户可以自定义helper，如果要访问数据库，理论上可以这样做：</p>
<pre><code>getRelated: (tags, cb) -&gt;
    @adapter.findTag tags: $in: tags, 10, (err, docs) -&gt;
        return cb(err) if err

        # blablabla</code></pre>
<p>但在 <code>jade</code> 中，helper是不允许回调的，所以，除了把数据库访问变成同步模式，这个现在貌似无解。</p>
<h2>测试</h2>
<p>在我的本地环境中，我创建了一个有1k+ <code>markdown</code> 源文件的项目，测试结果还不赖：</p>
<pre><code>➜  hatch-jade-example git:(master) ✗ make fullclean
➜  hatch-jade-example git:(master) ✗ time make
Creating dependency paths .dep/layouts.
Creating dependency paths .dep/layouts/common.
Creating dependency paths .dep/layouts/common/includes.
Creating dependency paths .dep/layouts/common/includes/asides.
Creating dependency paths .dep/layouts/common/mixins.
    Too many layouts changed, clean all outputs.
Parsing the documents into database.
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc  1118 docs parsed.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Generate documents.
    1118 docs generated.
Creating dependency paths .dep/contents.
Creating dependency paths .dep/contents/docs.
Creating dependency paths .dep/contents/post1.
Creating dependency paths .dep/contents/post10.
Creating dependency paths .dep/contents/post11.
Creating dependency paths .dep/contents/post12.
Creating dependency paths .dep/contents/post13.
Creating dependency paths .dep/contents/post14.
Creating dependency paths .dep/contents/post15.
Creating dependency paths .dep/contents/post16.
Creating dependency paths .dep/contents/post17.
Creating dependency paths .dep/contents/post18.
Creating dependency paths .dep/contents/post19.
Creating dependency paths .dep/contents/post2.
Creating dependency paths .dep/contents/post20.
Creating dependency paths .dep/contents/post21.
Creating dependency paths .dep/contents/post22.
Creating dependency paths .dep/contents/post23.
Creating dependency paths .dep/contents/post24.
Creating dependency paths .dep/contents/post25.
Creating dependency paths .dep/contents/post3.
Creating dependency paths .dep/contents/post4.
Creating dependency paths .dep/contents/post5.
Creating dependency paths .dep/contents/post6.
Creating dependency paths .dep/contents/post7.
Creating dependency paths .dep/contents/post8.
Creating dependency paths .dep/contents/post9.
Build completed!
make  5.93s user 1.65s system 100% cpu 7.540 total
➜  hatch-jade-example git:(master) ✗ touch src/contents/docs/2013-01-01-atanasoff-implementation.markdown
➜  hatch-jade-example git:(master) ✗ time make
Parsing the documents into database.
u   1 docs parsed.
Generate documents.
    1 docs generated.
Build completed!
make  2.28s user 0.24s system 101% cpu 2.477 total</code></pre>
<h2>后记 &amp; 未完待续</h2>
<p>这个项目目前仅仅实现了POC，比我预期的进展要缓慢一些。但这毕竟是我第一次跳出 <code>express</code> 的框框去写 <code>nodejs</code> 代码，所以可以原谅。</p>
<p>写 <code>makefile</code> 是种享受，尤其是几行很直观的代码下来就达到用编程语言几十甚至上百行的效果。不信，看看项目中我为了实现类似查找 dependency 变化的代码：</p>
<pre><code>$ cat lib/diff.coffee
fs = require &#39;fs&#39;
file = require &#39;file&#39;
path = require &#39;path&#39;
async = require &#39;async&#39;
_ = require &#39;lodash&#39;

# params should contain src, dst and ext
diffPath = (src, dst, ext, callback) -&gt;
    fileTimeDiff = (src_file, cb) -&gt;
        old_ext = path.extname(src_file)
        dst_file = src_file.replace(src, dst)
        if ext
            dst_file = dst_file.replace(old_ext, ext)

        fs.stat src_file, (err, src_stat) -&gt;
            return cb(err) if err

            fs.exists dst_file, (exists) -&gt;
                return cb null, src_file if not exists

                fs.stat dst_file, (err, dst_stat) -&gt;
                    cb(err) if err

                    if src_stat.mtime &gt; dst_stat.mtime
                        cb null, src_file
                    else
                        cb null, null


    file.walk src, (err, dirPath, dirs, files) -&gt;
        async.map files, fileTimeDiff, (err, results) -&gt;
            callback err, _.compact(results)

module.exports.diffPath = diffPath

$ cat scripts/hatch-diff.coffee
#!/usr/bin/env coffee
diffPath = require(&#39;./../lib/diff&#39;).diffPath

argv = require(&#39;optimist&#39;)
    .usage(&#39;&#39;&#39;
           Compare two folders
           Usage: $0 [--ext html] src_dir dst_dir
           &#39;&#39;&#39;)
    .demand(2)
    .alias(&#39;e&#39;, &#39;ext&#39;)
    .describe(&#39;e&#39;, &#39;destination file extention&#39;)
    .argv


[src, dst] = argv._
ext = argv.e

diffPath src, dst, ext, (err, data) -&gt;
    for item in data
        console.log item</code></pre>
<p>这么复杂的逻辑仅仅实现了 <code>makefile</code> 中 <code>$?</code> 的功能而已。。。</p>
<p>送上小宝照片一枚。</p>
<p><img src="/assets/files/photos/baby20131103.jpg" alt="小宝"></p>
]]></description>
            <link>http://tchen.me/posts/2013-11-03-hatch-experiment.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-11-03-hatch-experiment.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Mon, 04 Nov 2013 14:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Hatch: 又一个建站工具]]></title>
            <description><![CDATA[<p>在 <a href="/posts/2013-10-28-blog-reborn.html">前文</a> 中，我尝试了 <a href="http://docpad.org">docpad</a> 做为新的建站工具。<code>docpad</code> 有很多优点，但最大的缺点是效率。在我看来，一个好的静态网站生成工具最好能在秒级处理成千上万文档，这样才能真正满足个人博客外的中等规模网站的需求。要做到这一点，工具必须将full build和incremental build区别开来。这样，即使一个full build要花几十秒甚至几分钟，incremental build还能控制在秒级。当用户修改某个文件时，incremental build能够保证用户有良好的体验 —— 无需等待，改动立即可见。而这一点，则恰恰是 <code>docpad</code> 所欠缺的。本文讲述的 <code>hatch</code> 项目将尝试在保留 <code>docpad</code> 的诸多优点外，通过更智能的build过程将编译速度尽最大可能提高。</p>
<!--more-->

<h2>目标</h2>
<p><code>hatch</code> 的目标是实现如下功能：
1. 支持任意模板类型。官方可仅支持 <code>jade</code>，但用户可以轻松扩展。
2. 支持任意格式的源文件。官方可仅支持 <code>markdown</code> 和 <code>jade</code>，但用户可以轻松扩展。
3. 支持复杂页面的生成，如标签聚合页面（docpad-plugin-tagging）和每个文档的相关文档（docpad-plugin-related）的功能。
4. 支持less/coffeescript，及compress。
5. 支持live preview。</p>
<h2>工具选择</h2>
<p>有了目标，我们需要选择合适的工具去完成目标。</p>
<p>在web时代，尽管 <code>rake</code>，<code>jake</code>，<code>grunt</code> 等等task runner大行其道，我还是偏爱 <code>make</code>，因为它最能体现unix的哲学：</p>
<blockquote>
<p>write programs that do one thing and do it well.</p>
</blockquote>
<p>比如说将less生成css并打包，然后上传到服务器上这样的工作：</p>
<pre><code>CSS_SOURCE=$(CSS_PATH)/app.less
CSS_DEPS=$(shell find $(CSS_PATH) -type f -name &#39;*.less&#39;)
CSS_TARGET=app.min.css
SYNC_TARGET=tchen@my-awesome-server.com:/homes/tchen/deployment/css

$(CSS_TARGET): $(CSS_DEPS)
    lessc $(CSS_SOURCE) --yui-compress  &gt; $(CSS_TARGET)

sync: $(CSS_TARGET)
    rsync -au $(CSS_TARGET) $(SYNC_TARGET)</code></pre>
<p>这段代码很简单，目标任务 <code>sync</code> 依赖于 <code>$(CSS_TARGET)</code> 的构建，而 <code>$(CSS_TARGET)</code> 依赖于 <code>$(CSS_DEPS)</code> 的构建。</p>
<p>使用 <code>make</code> 简单明了，且不会做任何无用功。比如说：</p>
<pre><code>$ make sync</code></pre>
<p>在第一次执行后，如果less文件没有修改（ctime没有改变），则不会做任何事就结束了，节省大量的重复劳动。</p>
<p>使用 <code>make</code> 加上合适的shell命令（如果特定功能的命令不存在，我们需要自己创建），我们就可以构建一套完整的编译系统，将 <code>markdown</code> 文件（或者其他类型的文件），经过一系列处理，生成 <code>html</code>。</p>
<h2>依赖处理</h2>
<p>如前文所述，我们要解决的问题归化成一个如何构建合适的 <code>makefile</code>，让源文件（如markdown）高效地（且正确地）编译成目标文件（如html）。而这其中的重点，则在如何处理依赖。</p>
<p>最简单的依赖处理莫过于一个文件发生改变，整个项目都会重新编译。正确性得以保证，但显然不高效。<code>docpad</code> 采用这样的策略，以至于对css的改动会引发html的重编。很不科学，漫长的等待让我这样的用户很受伤。</p>
<p>所以我们要设定合理的依赖规则。</p>
<p>对于目标中我们想要实现的功能，5暂且放在一边，1/2/4很好实现。3是一个难点，需要两次build才能正确处理：
1. make parse。每个修改过的文档单独parse，中间结果保存在 <code>mongodb</code> 中，如果 <code>tags</code> 信息有改变，则删除对应的标签聚合页（会触发重新生成），及受影响的文档页面。
2. make generate。调用整个正式的生成过程，生成所有需要重新生成的页面。</p>
<p><img src="/assets/files/posts/hatch_dep.jpg" alt="博客截图"></p>
<p>如上图，如果删除了标签 <code>docpad</code> ，并添加了标签 <code>hatch</code>，那么 <code>make parse</code> 时会将该文档的最新内容保存在db里，删除 <code>docpad</code> 和 <code>hatch</code> 的标签聚合页面，删除已经生成的所有包含 <code>docpad</code> 和 <code>hatch</code>标签的页面（包括自己），然后进入到第二阶段的页面生成。</p>
<h2>系统结构</h2>
<p>有了上面的思考，<code>hatch</code> 的系统结构也就付出水面，整个系统围绕着 <code>make</code> 展开，尽可能使用已有的unix工具（sorry，为了保证小而美，windows不在这样一个系统的考虑之列）。如果没有合适的工具，则撰写之。</p>
<p>可以直接leverage的工具：</p>
<ul>
<li>lessc/sass，用于生成css。</li>
<li>coffee，用于生成js。</li>
<li>yuicompressor，用于compress css和js。</li>
<li>jade，用于将jade template生成html。</li>
<li>marked，用于将markdown文件生成html。</li>
<li>js-yaml，用于parse metadata。</li>
</ul>
<p>需要撰写的工具：</p>
<ul>
<li>hatch-parse，用于parse一个文档，将中间结果存入数据库中。例如：<code>hatch-parse test.md</code>。hatch-parse会根据扩展名自动使用相应的parser。</li>
<li>hatch-gen，用于生成一个页面，生成过程中可能需要读取数据库。例如：<code>hatch-gen -o test.html test.md</code>，<code>hatch-gen -o index.html index.jade</code>。如果文章需要分页（定义了<code>&lt;!--page--&gt;</code>），则进行分页处理。</li>
<li>tag-gen，用于生成标签索引页。例如：<code>tag-gen -o hatch.html -t tag.jade hatch</code>。将会查询数据库中标签是 <code>hatch</code> 的文档，将其写入hatch.html。如果 <code>tag-gen -o &lt;dir&gt; -t tag.jade *</code>，将会生成所有标签索引。如果生成过程中需要分页，则进行分页。</li>
<li>index-gen，用于生成索引页。例如：<code>index-gen -o index.html index.md</code>。如果生成过程中需要分页，则进行分页。</li>
</ul>
<h2>数据结构</h2>
<p>我用过的 <a href="http://wintersmith.io">wintersmith</a>，<a href="http://docpad.org">docpad</a> 都使用memory db存放文档的中间结果，为特殊需求（如related documents）提供接口。由于采用 <code>make</code> 来组织整个系统，每个运行的命令都是自己的进程空间，所以无法用in process memory db，另外我也不希望每次build都重新生成这个DB，所以一个可以persistent的DB就是我的第一选择。考虑到我有如下需求：</p>
<ul>
<li>数据库中的字段来源于文档的metadata，所以随意性很大，必须schemaless。</li>
<li>需要支持一些复杂的查询，比如，找出6篇标签为：<code>hatch</code> 或 <code>tool</code> 的文档。</li>
</ul>
<p>所以权衡之后，本文决定使用mongodb来保存中间结果。当然，每次build时可能涉及很多次数据库的open/close，至于performance如何，只有实测后才有结论。</p>
<p>mongodb中存储的是文档（template无须存储），大概长这个样子（<code>createdAt</code>，<code>tags</code>，<code>ignored</code>，<code>src</code> 上建有索引）：</p>
<pre><code>{
    &quot;_id&quot;: ObjectId(`blablabla`),
    &quot;template&quot;: &quot;posts.jade&quot;,
    &quot;createdAt&quot;: ISODate(&quot;2013-10-30T20:20.000Z&quot;),
    &quot;updatedAt&quot;: ISODate(&quot;2013-10-30T20:25.000Z&quot;),
    &quot;tags&quot;: [&quot;hatch&quot;, &quot;tool&quot;],
    &quot;ignored&quot;: true,
    &quot;comments&quot;: true,
    &quot;cover&quot;: &quot;/assets/files/posts/hatch.jpg&quot;,
    &quot;src&quot;: &quot;/documents/posts/hatch.md&quot;,
    &quot;outputs&quot;: [&quot;/posts/hatch.html&quot;, &quot;/posts/hatch.1.html&quot;],
    &quot;title&quot;: &quot;Hello Hatch&quot;,
    &quot;rawContent&quot;: &quot;This is a great document\n\nHello hatch!\n&quot;,
    &quot;teaser&quot;: &quot;&lt;p&gt;This is a great document&lt;/p&gt;&quot;,
    &quot;content&quot;: &quot;&lt;p&gt;This is a great document&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;Hello hatch!&lt;p&gt;&quot;
}</code></pre>
<p>对应在磁盘上的文件是这个样子：</p>
<pre><code>---
template: posts.jade
title: Hello Hatch
date: 2013-10-30 20:20
tags: [hatch, tool]
comments: true
ignored: true
cover: /assets/files/posts/hatch.jpg
---

This is a great document

Hello hatch!</code></pre>
<p>这引入一个问题：当磁盘文件修改时，如何找到数据库中对应的文档？源文件名是少数不那么容易修改又具备唯一性的字段，所以在数据库文档中我们放入了 <code>src</code> 这个域。在 <code>makefile</code> 里，我们需要提供 <code>make dbclean</code>，以便用户在需要时，可以将数据库中的文档清除干净。</p>
<h2>实现</h2>
<p>从构思的角度，基本的障碍已经消除，大致的设计也有了，剩下的就是如何实现。这个周末，争取能把最基本的功能实现出来，然后在讨论实现过程中遇到的问题，看看和我的构思/假设有什么明显的偏差。</p>
<p>顺手做了个 Lean Canvas: <a href="/canvases/2013-10-30-hatch.html">hatch project lean canvas</a>，感兴趣可以看看。</p>
<p>这几天没怎么照相，还是送上之前照的一张照片：</p>
<p><img src="/assets/files/photos/baby20131030.jpg" alt="小宝快一岁了"></p>
<!--
* index-gen，用于生成索引页，比如说标签索引页，首页等。用户传入一个查询条件，和一个排序条件，从数据库中读取对应的数据，生成html。例如：index-gen -e '[{"q": {"tag": "hatch"}, "s": {"date": -1}, "name": "dataset1"}, ...]'  > hatch.html。

比如说我们要生成 ``index.html``。它通过 ``documents/index.md`` 和 ``templates/index.jade`` 生成，并能展示 ``documents/posts`` 和 ``documents/slides`` 目录下的最新10篇文章。
-->]]></description>
            <link>http://tchen.me/posts/2013-10-30-the-hatch-project.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-10-30-the-hatch-project.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Tue, 29 Oct 2013 23:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[觅珠人：浴火重生]]></title>
            <description><![CDATA[<p>很久没有更新博客了。最近几个月写了三篇文章：</p>
<ul>
<li>8月底：『软件公司如何有效地组织和运作?』</li>
<li>9月中：『班加罗尔初体验』</li>
<li>10月：『nodejs callback hell的解决之道』</li>
</ul>
<p>因为种种原因都烂尾，没有继续下去，所以也就没有发表出来。绵绵不断的工作压力和为人父的家庭责任让我心力交瘁，眼一睁一闭，一睁一闭的，一天天就过去了。</p>
<p>这两天闲逛hn时，无意中发现了 <code>docpad</code>，又一个静态网站生成器。由于我目前使用的 <code>wintersmith</code> 是一个hack版，将其升级到2.x太麻烦，而且随着我文章的增多，分页，标签管理等都成为麻烦事。在尝试了 <code>docpad</code> 后，我发现这是个好东西，干脆心一横，就把整个博客的底层系统升级过去了。</p>
<!--more-->

<p>看过我之前博文的童鞋可能注意到，我的博客自诞生起，历经 <code>wordpress</code> -&gt; <code>octopress</code> -&gt; <code>wintersmith</code> -&gt; <code>docpad</code>。原因很简单，我需要一款能够支持以下功能的静态网站生成工具：</p>
<ul>
<li>能使用 <code>markdown</code> 或任何其他语言撰写文章（posts）。</li>
<li>支持尽可能多的模板，如jade，haml。</li>
<li>能生成标签索引页。</li>
<li>能生成文章索引页。</li>
<li>索引页支持分页。</li>
<li>支持local server，能在本地展示生成出来的网站的感觉。</li>
<li>生成速度尽可能快（不要超过10s），并且不要做无意义的重复生成。</li>
<li>是CMS，而非blog engine。</li>
</ul>
<p>在这个过程中，我不断寻觅，不断更新工具，直到我找到了 <code>docpad</code>。除去对性能的要求外，<code>docpad</code> 满足我上述所有需求。</p>
<p>所以我便开始了艰难的升级之旅。由于本文非 <code>docpad</code> 入门文档，重点描述我升级遇到的问题，所以要学习 <code>docpad</code> 请移步：<a href="http://docpad.org。">http://docpad.org。</a></p>
<h2>模板</h2>
<p>这次升级，UI全部重写。我放弃了bootstrap 2，选择了bootstrap 3，亦即意味着完全放弃了IE7，基本放弃了IE8。我的博客读者并不很多，在百度统计中，IE7/IE8占比不到15%（IE7及以下不到1%），所以对整体用户影响不太大。</p>
<p>UI的设计购买自wrapbootstrap，花四十美刀买了个multiple license，很划算。如果从设计做起，我未必能做出这样的设计，而且短期内不可能升级完成。</p>
<p>购买后前端的主要工作就是把html变成template。由于 <code>docpad</code> 对 <code>eco</code> 支持比较好，所以我花了些时间学习eco。</p>
<h2>文档</h2>
<p>文档的改动主要在文件名和metadata上。<code>docpad</code> 借鉴了rails的pipeline，根据文件名判断该如何转化，比如：<code>test.css.less</code>，<code>eco</code> 会先通过 <code>eco</code> 处理转换成 <code>test.css.less</code>，再通过 <code>lessc</code> 转换成 <code>test.css</code>。</p>
<p>metadata的转换主要是 <code>wintersmith</code> 和 <code>docpad</code>的命名不同，比如：</p>
<pre><code>---
template: default.jade
published: false
---</code></pre>
<p>在 <code>docpad</code> 中需要转换为：</p>
<pre><code>---
layout: default // default.html.eco
ignored: true
---</code></pre>
<p>这都不是什么大问题。</p>
<h2>分页</h2>
<p>之前的博客不支持分页，在首页我塞了40篇文章。如果我的博客超过了40篇文章，那么之前的就无法被直接索引到。使用 <code>docpad</code> 后，只要安装 <code>paged</code> 插件，并按例子写一小段代码，就能完美支持分页：</p>
<pre><code>$ docpad install paged</code></pre>
<p>我写的支持分页的partial：</p>
<pre><code>&lt;% if @document.page.count &gt; 1: %&gt;
&lt;ul class=&quot;paginator text-center&quot;&gt;
    &lt;!-- Previous Page Button --&gt;
    &lt;% unless @hasPrevPage(): %&gt;
        &lt;li class=&quot;disabled&quot;&gt;&lt;span&gt;上一页&lt;/span&gt;&lt;/li&gt;
    &lt;% else: %&gt;
        &lt;li&gt;&lt;a href=&quot;&lt;%= @getPrevPage() %&gt;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;
    &lt;% end %&gt;

    &lt;!-- Page Number Buttons --&gt;
    &lt;% for pageNumber in [0..@document.page.count-1]: %&gt;
        &lt;% if @document.page.number is pageNumber: %&gt;
            &lt;li class=&quot;active&quot;&gt;&lt;span&gt;&lt;%= pageNumber + 1 %&gt;&lt;/span&gt;&lt;/li&gt;
        &lt;% else: %&gt;
            &lt;li&gt;&lt;a href=&quot;&lt;%= @getPageUrl(pageNumber) %&gt;&quot;&gt;&lt;%= pageNumber + 1 %&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;% end %&gt;
    &lt;% end %&gt;

    &lt;!-- Next Page Button --&gt;
    &lt;% unless @hasNextPage(): %&gt;
        &lt;li class=&quot;disabled&quot;&gt;&lt;span&gt;下一页&lt;/span&gt;&lt;/li&gt;
    &lt;% else: %&gt;
        &lt;li&gt;&lt;a href=&quot;&lt;%= @getNextPage() %&gt;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;
    &lt;% end %&gt;
&lt;/ul&gt;
&lt;% end %&gt;</code></pre>
<h2>标签</h2>
<p>在 <code>docpad</code> 里支持标签很容易，安装两个plugin就好：</p>
<pre><code>$ docpad install related
$ docpad install tagging</code></pre>
<p>前者提供『相关文档』的功能，后者能生成类似 <code>/tags/:tag</code> 的索引页。</p>
<p>我们先看如何显示相关文档：</p>
<pre><code>&lt;div class=&quot;widget widget-cats&quot;&gt;
  &lt;h4 class=&quot;widget-title&quot;&gt;
    相关文章
  &lt;/h4&gt;
  &lt;ul&gt;
    &lt;% if @document.relatedDocuments : %&gt;
    &lt;% for document in @document.relatedDocuments: %&gt;
      &lt;li&gt;&lt;a href=&quot;&lt;%= document.url %&gt;&quot;&gt;&lt;%= document.title %&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;% end %&gt;
    &lt;% else : %&gt;
      &lt;li&gt;&lt;a&gt;无&lt;/a&gt;&lt;/li&gt;
    &lt;% end %&gt;
  &lt;/ul&gt;
&lt;/div&gt;</code></pre>
<p>这样，只要文档中使用了 <code>tags: [tag1, tag2]</code> 这样的metadata，所有定义了 <code>tag1</code> 或 <code>tag2</code> 的文章就被聚合在此。</p>
<p>生成标签索引页也不难，只要做一个template：</p>
<pre><code>---
layout: default
---
&lt;div class=&quot;container&quot;&gt;
    &lt;h1&gt;文章列表：『&lt;%= @document.tag %&gt;』&lt;/h1&gt;
    &lt;hr/&gt;

    &lt;ul&gt;
    &lt;% for doc in @getCollection(&#39;documents&#39;).findAll({tags: &#39;$in&#39;: @document.tag}).toJSON(): %&gt;
        &lt;%- @partial(&#39;posts/post_loop_item&#39;, {item: doc}) %&gt;
    &lt;% end %&gt;
    &lt;/ul&gt;

&lt;/div&gt;</code></pre>
<p>显示效果如：<a href="http://tchen.me/tags/technology.html。">http://tchen.me/tags/technology.html。</a></p>
<h2>问题</h2>
<p><code>docpad</code> 功能很强大，但其速度让人难以忍受。之前 <code>wintersmith</code> 生成全站只需要3s左右，<code>docpad</code> 则要40s。而且</p>
<p>为了加快速度我做了很多尝试：</p>
<ol>
<li>使用standalone metadata。<a href="https://docpad.org/docs/meta-data。效果一般，很多地方不适用，而且在诸如app.css.less里加这么个东西很不伦不类。">https://docpad.org/docs/meta-data。效果一般，很多地方不适用，而且在诸如app.css.less里加这么个东西很不伦不类。</a></li>
<li>对静态文件使用raw plugin。效果不明显，我往raw目录中拷一个文件还会trigger regenerate。</li>
<li>停用live-reload插件。我不希望加了一个回车，保存后就要话40s才能访问本地服务器。</li>
<li>使用 <code>docpad watch</code>，而不是 <code>docpad run</code>，同时启动一个 <code>python -m SimpleHTTPServer 8210</code>，来serve静态文件。这样，改动能够被重新生成，且生成时我还能浏览已有的页面。</li>
</ol>
<p>但这些都不太理想。<code>docpad</code> 蠢到我改一行less，整个网站就全部重编。你可想而知在迁移阶段我有多少时间耗费在等待中。</p>
<p>于是我把所有的静态文件都拿出来放在 <code>src</code> 外，不让 <code>docpad</code> 干蠢事。完全抛弃 <code>raw</code> 插件，我写了个几行的 <code>Makefile</code> 干这些事：</p>
<ul>
<li>将less生成css，并使用yuicompressor压缩。</li>
<li>将js用yuicompressor压缩。</li>
<li>将整个 <code>raw</code> 目录rsync到 <code>out</code> 目录。</li>
</ul>
<p>在 <code>raw</code> 目录下的Makefile如下：</p>
<pre><code>CHECK=\033[32m✔\033[39m
DONE=&quot;\n${CHECK} Done.\n&quot;
ECHO=echo
ROOT=assets

CSS_COMPRESSOR=lessc
JS_COMPRESSOR=yuicompressor
SYNC=rsync
CAT=cat
RM=rm

CSS_PATH=$(ROOT)/less
CSS_SOURCE=$(CSS_PATH)/app.less

JS_PATH=$(ROOT)/scripts
JS_PLUGIN_PATH=$(JS_PATH)/plugins
JS_SOURCE=$(JS_PLUGIN_PATH)/jquery.js $(JS_PLUGIN_PATH)/bootstrap.min.js $(JS_PLUGIN_PATH)/jquery.visible.min.js $(JS_PLUGIN_PATH)/jquery.isotope.min.js $(JS_PLUGIN_PATH)/jquery.knob.js $(JS_PLUGIN_PATH)/jquery.scrollUp.min.js $(JS_PLUGIN_PATH)/highlight.pack.js $(JS_PATH)/application.js

CSS_TARGET=$(ROOT)/css/app.min.css
JS_TARGET=$(ROOT)/js/app.min.js

SYNC_TARGET=../out


sync: $(CSS_TARGET) $(JS_TARGET)
    $(SYNC) -au --exclude $(CSS_PATH) --exclude $(JS_PATH) --exclude Makefile . $(SYNC_TARGET)
    @$(ECHO) $(DONE)

$(CSS_TARGET):
    $(CSS_COMPRESSOR) $(CSS_SOURCE) --yui-compress  &gt; $(CSS_TARGET)

$(JS_TARGET):
    @$(CAT) $(JS_SOURCE) &gt; tmp.js
    $(JS_COMPRESSOR) -o $(JS_TARGET) tmp.js
    @$(RM) tmp.js

clean:
    $(RM) -f $(CSS_TARGET) $(JS_TARGET)</code></pre>
<p>在根目录下的Makefile如下：</p>
<pre><code>generate:
    docpad generate
    @cd raw; make; cd ..

deploy:
    cd out; make; cd ../..

clean:
    cd raw; make clean; cd ../..</code></pre>
<p>这样，css/js的改动和 <code>docpad</code> 完全没关系，<code>docpad</code> 只需要帮我生成文档即可。这样下来，60%的修改都能够在1s内完成。剩下40%的修改，耗时稍微少了一些，可还要用三十多秒。没有本质差别。</p>
<h2>部署</h2>
<p>强烈不建议使用 <code>ghpages</code> 插件部署。我安装了这个插件，也使用了，但使用第二次的时候就将其卸载了。原因很简单：每次 <code>git push -f</code> 全部重新push，写这个plugin的作者之前没生成过大一些的网站吧？我的博客现在几十篇文章，不足百张图片，总共几十M的repo，每次都全部重新push要十多分钟，一天push十几次我还干不干活了？</p>
<p>所以还是自己解决部署问题吧：</p>
<pre><code>$ rm -rf out
$ git clone &lt;your repo url&gt;
$ make deploy # 这个我已经做进了上文中的Makefile中</code></pre>
<p>在要部署的repo中添加一个Makefile:</p>
<pre><code>DATE=$(shell date)
CHECK=\033[32m✔\033[39m
DONE=&quot;\n${CHECK} Done.\n&quot;

deploy:
    @echo &quot;Deploy the blog to github pages.&quot;
    git add --all .
    git commit -a -m &quot;Deploy to github pages on $(DATE).&quot;
    git push
    @echo $(DONE)</code></pre>
<p>也是简单之极。</p>
<h2>心得</h2>
<p>这次博客升级花费了我两个晚上和一个周日。按我晚上9点开工到12点，周日工作了至少6小时，总共耗时12+小时，耗资USD40。</p>
<p><code>docpad</code> 是个功能丰富的工具，值得试用，但要忍受极慢的编译速度。撰写者（尤其是plugin的撰写者）显然水平一般，不懂得用unix的设计哲学来设计这样工具。</p>
<p>在经历了这么多工具后，我有强烈的意愿写一个自己的静态网站生成器，来更好地支持我的需求。想法很简单：</p>
<ol>
<li>使用Makefile和现成的工具完成静态文件的处理。</li>
<li>高度组件化 - 撰写小脚本来完成单一的功能。用Makefile粘合这些脚本。</li>
<li>脚本解析的中间结果存储在redis/mongodb中，供其他附加功能使用，比如tagging/paging。</li>
<li>任何一个工具可以对全站使用，也可对部分文件使用。</li>
<li>尽可能并发处理，全站的生成速度控制在秒级。</li>
<li>如果可以，提供development模式，动态生成当前访问的页面。</li>
</ol>
<p>送上小宝近照一张。</p>
<p><img src="/assets/files/photos/baby20131028.jpg" alt="小宝"></p>
]]></description>
            <link>http://tchen.me/posts/2013-10-28-blog-reborn.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-10-28-blog-reborn.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Sun, 27 Oct 2013 23:40:00 GMT</pubDate>
        </item>
    </channel>
</rss>