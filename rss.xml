<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[觅珠人 | Tyr Chen的个人博客 | 创意 | 心得 | 经验]]></title>
        <description><![CDATA[本博客提供我个人的想法，创意，经验，心得。你不必认同博主观点。]]></description>
        <link>http://tchen.me</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Sun, 18 May 2014 00:33:11 GMT</lastBuildDate>
        <atom:link href="http://tchen.me/rss.xml" rel="self" type="application/rss+xml"/>
        <author><![CDATA[Tyr Chen]]></author>
        <pubDate>Sun, 18 May 2014 00:32:21 GMT</pubDate>
        <item>
            <title><![CDATA[Stanford guided tour]]></title>
            <description><![CDATA[<p>今天参加了早上的一个Stanford guided tour，非常建议来Stanford转转的人参加。早上11点，下午3:15在Stanford visitor center集合。</p>
<p>Tour结束后我即兴采访了一下给我们讲解的二年级（Sophomore）学生Nicale（不知道是不是这么拼），让他讲讲Stanford的生活。本来时间紧不想写东西，直接把采访录音发公众号，结果公众号不允许超过60s的语音文件，知乎也不能传mp3，郁闷中只好用博客了。不多写，放两段录音，放一些图片，大家自己欣赏。</p>
<!--more-->

<p>我发现我私底下说话还不算太磕巴，怎么一正式起来这么矬 —— 尤其周围有人一起凑热闹。这是我即兴采访的录音</p>
<audio src="/assets/files/mp3/interview.mp3" preload="auto" controls></audio>

<p>这个是我在guided tour中的录音（20分钟）：</p>
<audio src="/assets/files/mp3/guided_tour.mp3" preload="auto" controls></audio>

<p>下面是一些照片，这是我第三次去Stanford，所以没怎么照，主要听讲来着。</p>
<p><img src="/assets/files/posts/stanford/IMG_5565.JPG" alt="Stanford"></p>
<p><img src="/assets/files/posts/stanford/IMG_5571.JPG" alt="Stanford"></p>
<p><img src="/assets/files/posts/stanford/IMG_5576.JPG" alt="Stanford"></p>
<p><img src="/assets/files/posts/stanford/IMG_5579.JPG" alt="Stanford"></p>
<p><img src="/assets/files/posts/stanford/IMG_5585.JPG" alt="Stanford"></p>
<p><img src="/assets/files/posts/stanford/IMG_5592.JPG" alt="Stanford"></p>
<p><img src="/assets/files/posts/stanford/IMG_5569.JPG" alt="Stanford"></p>
<p><img src="/assets/files/posts/stanford/IMG_5573.JPG" alt="Stanford"></p>
<p><img src="/assets/files/posts/stanford/IMG_5578.JPG" alt="Stanford"></p>
<p><img src="/assets/files/posts/stanford/IMG_5584.JPG" alt="Stanford"></p>
<p><img src="/assets/files/posts/stanford/IMG_5588.JPG" alt="Stanford"></p>
<p><img src="/assets/files/posts/stanford/IMG_5595.JPG" alt="Stanford"></p>
]]></description>
            <link>http://tchen.me/posts/2014-05-17-stanford.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-05-17-stanford.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Sat, 17 May 2014 18:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[高效能程序员的七个习惯]]></title>
            <description><![CDATA[<h1>Vagrant share浅析</h1>
<p>最近vagrant 1.5升级力度空前，增加了很多新功能，其中最令人瞩目的当属 <code>vagrant share</code>。啥子意思呢？就是把你的虚拟机share给地球另一端的人。这功能很高大上啊，简直是居家旅行，远程办公的必备武器。你正在做的web app出bug了，需要帮忙？没问题，亲，把虚拟机share一下。</p>
<!--more-->

<pre><code>➜  dockerbox  vagrant share
==&gt; default: Detecting network information for machine...
    default: Local machine address: 127.0.0.1
    default:
    default: Note: With the local address (127.0.0.1), Vagrant Share can only
    default: share any ports you have forwarded. Assign an IP or addres to your
    default: machine to expose all TCP ports. Consult the documentation
    default: for your provider (&#39;virtualbox&#39;) for more information.
    default:
    default: Local HTTP port: 3000
    default: Local HTTPS port: disabled
    default: Port: 2200
    default: Port: 3000
==&gt; default: Checking authentication and authorization...
==&gt; default: Creating Vagrant Share session...
    default: Share will be at: cheerful-beaver-2087
==&gt; default: Your Vagrant Share is running! Name: cheerful-beaver-2087
==&gt; default: URL: http://cheerful-beaver-2087.vagrantshare.com
==&gt; default:
==&gt; default: You&#39;re sharing your Vagrant machine in &quot;restricted&quot; mode. This
==&gt; default: means that only the ports listed above will be accessible by
==&gt; default: other users (either via the web URL or using `vagrant connect`).</code></pre>
<p>我的虚机里开放了3000端口，是个web app。share好以后，别人就可以使用这个链接：<code>http://cheerful-beaver-2087.vagrantshare.com</code>，访问程序君正在调试开发的app了。（别试了，当您看到本文时，程序君已经把共享关闭喽）。</p>
<p>很神奇吧？</p>
<h2>这是怎么做到的？</h2>
<p>估计你有和程序君一样的问题。程序君开始捣鼓。</p>
<p>首先tcp dump抓包。</p>
<pre><code>➜  appshare git:(master) ✗ tcpdump -i en0</code></pre>
<p>内容很多，就不在这里呈现了。没有太多实质的内容，主要是下面几个步骤：</p>
<p>(1) DNS请求 vagrantcloud.com 获得两个IP: 107.23.21.165, 54.85.101.30</p>
<p>(2) 分别进行https握手</p>
<pre><code>20:46:06.357551 IP 10.0.0.6.61158 &gt; ec2-107-23-21-165.compute-1.amazonaws.com.https: Flags [S], seq 3383705821, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 922128202 ecr 0,sackOK,eol], length 0
20:46:06.968517 IP ec2-107-23-21-165.compute-1.amazonaws.com.https &gt; 10.0.0.6.61158: Flags [S.], seq 2369287401, ack 3383705822, win 14480, options [mss 1460,sackOK,TS val 132138929 ecr 922128202,nop,wscale 8], length 0
20:46:06.968607 IP 10.0.0.6.61158 &gt; ec2-107-23-21-165.compute-1.amazonaws.com.https: Flags [.], ack 1, win 8235, options [nop,nop,TS val 922128810 ecr 132138929], length 0</code></pre>
<pre><code>20:46:08.502461 IP 10.0.0.6.61159 &gt; ec2-54-85-101-30.compute-1.amazonaws.com.https: Flags [S], seq 3557617978, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 922130332 ecr 0,sackOK,eol], length 0
20:46:09.316782 IP ec2-54-85-101-30.compute-1.amazonaws.com.https &gt; 10.0.0.6.61159: Flags [S.], seq 1741334642, ack 3557617979, win 14480, options [mss 1460,sackOK,TS val 132128867 ecr 922130332,nop,wscale 8], length 0
20:46:09.316849 IP 10.0.0.6.61159 &gt; ec2-54-85-101-30.compute-1.amazonaws.com.https: Flags [.], ack 1, win 8235, options [nop,nop,TS val 922131145 ecr 132128867], length 0</code></pre>
<p>(3) 传输数据 blablabla（这不废话么）</p>
<p>郁闷的是vagrant考虑到数据安全性，全部采用https，所以无法窥探里面的究竟。</p>
<p>为什么不用Fiddler来偷窥？好吧，fillder基于.net，程序君不想在mac上装mono...</p>
<p>所以程序君只能靠脑子生猜这个功能是怎么实现的了。</p>
<h2>我猜我猜...</h2>
<p>可能的实现手段：</p>
<p>(1) 使用p2p（但vagrant显然不是这么实现的）。先放在一边。</p>
<p>(2) 使用tcp proxy。具体做法：</p>
<pre><code>local http server --- local proxy --- cloud proxy ---- cloud http server</code></pre>
<p>用户从url过来的http请求，被负载到cloud proxy，然后cloud proxy再将其relay给local proxy，local proxy再relay给local http server；http响应反之。</p>
<p>这个想法比较靠谱。</p>
<p>试着用go简单实现了一下，主要是为了验证想法。结果证实了这个方案可行：</p>
<pre><code>local http server (8000) --- local proxy (7000) --- cloud proxy (9000) ---- cloud http server</code></pre>
<p>由于我在本机测试，所以不需要放一个nginx在cloud http server侧，直接访问：<code>http://localhost:9000</code>即可。经过两层proxy，local http server的内容被转到浏览器上。当然，目前的代码有问题，local proxy和cloud proxy间只有一个connection，遇到keep-alive的http connection就阻塞住了...所以你看到的页面是这样(local http server跑的是我的博客）：</p>
<p><img src="../assets/week12/proxy.jpg" alt="proxy proxy"></p>
<p>代码见：<a href="https://github.com/tyrchen/appshare">appshare</a></p>
<p>首先用Python起一个simple http server:</p>
<pre><code>➜  out git:(master) simpleweb
Serving HTTP on 0.0.0.0 port 8000 ...
127.0.0.1 - - [20/Mar/2014 22:08:06] &quot;GET / HTTP/1.1&quot; 200 -
127.0.0.1 - - [20/Mar/2014 22:08:06] &quot;GET /assets/css/app.min.css HTTP/1.1&quot; 200 -
127.0.0.1 - - [20/Mar/2014 22:08:06] &quot;GET /assets/images/tyr.png HTTP/1.1&quot; 200 -
127.0.0.1 - - [20/Mar/2014 22:08:06] &quot;GET /assets/images/shadow-separator-wide-bottom.png HTTP/1.1&quot; 200 -
127.0.0.1 - - [20/Mar/2014 22:08:06] &quot;GET /assets/files/posts/busy.jpg HTTP/1.1&quot; 200 -
127.0.0.1 - - [20/Mar/2014 22:08:06] &quot;GET /assets/js/app.min.js HTTP/1.1&quot; 200 -
127.0.0.1 - - [20/Mar/2014 22:08:33] &quot;GET /assets/favicon.ico HTTP/1.1&quot; 200 -
127.0.0.1 - - [20/Mar/2014 22:08:33] &quot;GET /assets/js/app.min.js HTTP/1.1&quot; 200 -</code></pre>
<p>然后启动cloud proxy：</p>
<pre><code>➜  appshare git:(master) ✗ bin/server :7000 :9000
2014/03/20 22:07:10 Listening to clients
2014/03/20 22:07:14 A client connection &amp;{{0x1062f280}} kicks
2014/03/20 22:07:14 Listening to webserver
2014/03/20 22:08:06 A web server connection &amp;{{0x1062f400}} kicks
2014/03/20 22:08:06 A web server connection &amp;{{0x1062f4c0}} kicks
2014/03/20 22:08:06 A web server connection &amp;{{0x1062f640}} kicks
2014/03/20 22:08:06 A web server connection &amp;{{0x1062f700}} kicks
2014/03/20 22:08:06 A web server connection &amp;{{0x1062f7c0}} kicks
2014/03/20 22:08:06 A web server connection &amp;{{0x1062f880}} kicks
2014/03/20 22:08:06 A web server connection &amp;{{0x1062f940}} kicks
2014/03/20 22:08:33 A web server connection &amp;{{0x1062fa00}} kicks
2014/03/20 22:08:33 A web server connection &amp;{{0x1062fac0}} kicks</code></pre>
<p>然后启动local proxy：</p>
<pre><code>➜  appshare git:(master) ✗ bin/client :7000 :8000
2014/03/20 22:07:14 Dial to server: &amp;{{0x1062f100}}
Request bytes:  1207
GET / HTTP/1.1
Host: localhost:8000
Connection: keep-alive
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.152 Safari/537.36
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4
Cookie: bdshare_firstime=1367059155378; sessionID=b33172c1ee44d1cc188c63393cbd4f4e235fc0a9; sails.sid=s%3Axyk6QFXHoeqR15ybvL4Z1dX7.QaNFa5nuM6derKoIjTMGLr5OH9DAI10xmXuLHO65iew; connect.sid=s%3Ai0O%2F4CQPGaQ27glzc7XoGDOu.pCIlLwDcK1NCNaPguY8zVFAJsKTu5I4Ri4StI5Cd0Ps; REVEL_FLASH=; REVEL_SESSION=9d3d9559107e87236af7279c814d0dee026bd376-%00_TS%3A1395459175%00; request_method=GET; _dockernotes_session=WjRrWUx6aDhNVHVCUmtWUHJVSnZnbzdhV2h5emJ3ZFJiY3NYdlA0S3NqcnZFaDUwWGwwOFVQWGxzbkVnWmU4MXErT3Jkd0kzQTA1WEdyMVlRby9kdThCMFNISlNtZVlHRE5wMGQwVmZkWk1CNHRqZGZKVzlneVo5RG1CZzRQZnM2Tm0wNmdpSVhGMndZTjZLT0JJeEZ3VkhCSUNUdkhNTnlOR093YjdDM3V3UE1OWmNUdGtmYjdkMDNWTE1vLzY5LS01WFNEcEExOHM1VHNQYkx5ZDlUb2lRPT0%3D--0ad6871648be9dce51901555efc81f075f2d78fb; sessionid=hlgkc4638sl2eza80jmgpofvckq3ctkd; djdt=hide; csrftoken=NtojvfH3vbpOdEwyAFMG4ATKML3w6gkl


2014/03/20 22:08:06 Dial to web server: &amp;{{0x1062f300}}
Request bytes:  1206
GET /assets/css/app.min.css HTTP/1.1
Host: localhost:8000
...


2014/03/20 22:08:06 Dial to web server: &amp;{{0x1062f580}}
Request bytes:  1207
GET /assets/images/tyr.png HTTP/1.1
Host: localhost:8000
...


2014/03/20 22:08:06 Dial to web server: &amp;{{0x1062f6c0}}
Request bytes:  1232
GET /assets/images/shadow-separator-wide-bottom.png HTTP/1.1
Host: localhost:8000
...


2014/03/20 22:08:06 Dial to web server: &amp;{{0x1062f840}}
Request bytes:  2427
GET /assets/files/posts/busy.jpg HTTP/1.1
Host: localhost:8000
...

GET /assets/files/posts/world.jpg HTTP/1.1
Host: localhost:8000
...


2014/03/20 22:08:06 Dial to web server: &amp;{{0x1062f980}}
Request bytes:  1189
GET /assets/js/app.min.js HTTP/1.1
Host: localhost:8000
...


2014/03/20 22:08:06 Dial to web server: &amp;{{0x1062fac0}}
Request bytes:  1154
GET /assets/favicon.ico HTTP/1.1
Host: localhost:8000
。。。


2014/03/20 22:08:33 Dial to web server: &amp;{{0x1062fc00}}
Request bytes:  1189
GET /assets/js/app.min.js HTTP/1.1
Host: localhost:8000
...</code></pre>
]]></description>
            <link>http://tchen.me/posts/2014-03-20-vagrant-share.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-03-20-vagrant-share.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Fri, 21 Mar 2014 05:50:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[高效能程序员的七个习惯]]></title>
            <description><![CDATA[<p>昨天收到一个读者留言，问作为程序员，有什么学习和工作上的好习惯可以借鉴？想了想，干脆附庸风雅一下，总结个『高效能程序员的七个习惯』吧。Disclaimer：一家之言，可不信，但不可全信。</p>
<!--more-->

<h2>拥抱unix哲学</h2>
<p>每个程序员入门的第一堂和第二堂课应该是和unix哲学相关的内容，简言之就是：做一件事，做好它。具体点：</p>
<ul>
<li>小即是美。</li>
<li>让程序只做好一件事。</li>
<li>尽可能早地创建原型。</li>
<li>可移植性比效率更重要。</li>
<li>数据应该保存为文本文件。</li>
<li>尽可能地榨取软件的全部价值。</li>
<li>使用shell脚本来提高效率和可移植性。</li>
<li>避免使用可定制性低下的用户界面。</li>
<li>所有程序都是数据的过滤器。</li>
</ul>
<p>再具体一些（TL;DR）：</p>
<pre><code>In [1]: import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren&#39;t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you&#39;re Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it&#39;s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let&#39;s do more of those!</code></pre>
<h2>选一个样板，follow之</h2>
<p>每个NBA新秀都有自己的样板，我们也总习惯称某足球新星为『小罗』，『小小罗』。样板为你提供了可模仿可追赶的对象，同时也让你审视自己究竟想成为什么样的程序员。我的样板是Greg Pass和Werner Vogels，虽然我这辈子可能也达不到他们的高度，可这并不妨碍向着我心目中的明星一步步靠近。</p>
<h2>写代码，而不是调代码</h2>
<p>写软件最糟糕的体验恐怕是边写边调，写一点，运行一下，再写一点。是很多程序员都会这么干。原因有二：1. 不熟悉相关的代码（类库），需要边写边运行保证代码的正确。2. 现代编程语言的REPL(Read-Evaluate-Print-Loop，就是语言的shell)能力助长了这一行为。</p>
<p>写系统软件的人很少这么做。他们手头糟糕的工具让边写边调的行为成为效率杀手 —— 如果稍稍改动，编译就要花去几分钟，甚至更长的时间，你还会这么干么？所以他们往往是写完一个模块，再编译调试。（由此看来，高效的工具有时候是把双刃剑啊）</p>
<p>我觉得写代码就跟写文章一样，构思好，有了大纲，就应该行云流水一样写下去，一气呵成，然后回过头来再调整语句，修改错别字。如果写完一段，就要回溯检查之前写的内容，效率很低，思维也会被打散。</p>
<p>靠边写边调做出来的代码还往往质量不高。虽然局部经过了雕琢，但整体上不那么协调，看着总是别扭。这就好比雕刻，拿着一块石头，你先是精修了鼻子，然后再一点一点刻画面部。等修到耳朵的时候，鼻子可能过大或过小，即便再精美，它也得不到赞赏。</p>
<h2>聪明地调试</h2>
<p>软件总会出问题。遇到问题，很多程序员就会用IDE在各种可能的地方加断点调试，如果没有IDE，那么各种print/log手段一齐抛出，有枣没枣打一杆子再说。</p>
<p>优秀的程序员会在撰写代码的时候就考虑到调试问题，在系统关键的节点上注入各种等级的调试信息，然后在需要的时候打开相应的调试级别，顺藤摸瓜，避免了不靠谱的臆测。这是调试之『道』。</p>
<p>很多问题打开调试开关后就原形毕露，但有时候靠调试信息找到了初步原因，进一步定位问题还需要具体的工具，也就是调试之『术』，如上文所述之断点调试。有些时候，遇到靠类似gdb（如python的pdb）的工具无法解决的问题时（如性能问题），你还需要更多的调试工具做runtime profiling，如systemtap。</p>
<h2>使用标记语言来写文档，而非word/power point</h2>
<p>不要使用只能使用特定软件才能打开的工具写文档，如word/page或者power point/keynote。要使用『放之四海而皆可用』的工具。</p>
<p>java的市场口号是：『一次编写，到处运行』，对于文档，你也需要这样的工具。Markdown(md) / Restructured Text(rst)（以及任何编辑语言，甚至是jade）就是这样的工具。通过使用一种特定的文本格式，你的文档可以被编译成几乎任意格式（html，rtf，latex，pdf，epub，...），真正达到了『一次编写，到处运行』。最重要的是，由于逻辑层（文章本身）和表现层（各种格式，字体，行距等）分离，同样的文档，换个模板，就有完全不一样的形象。</p>
<p>除非必须，我现在所有的文档都是md或者rst格式。</p>
<h2>一切皆项目</h2>
<p>程序员的所有产出应该项目制。软件自不必说，文档和各种碎片思想也要根据相关性组织成项目。举一些我自己的例子：</p>
<ul>
<li>我的博客是一个名叫jobs的github项目</li>
<li>我的微信文章全部放在craftsman这个项目中</li>
<li>我学习某种知识的过程（比如说golang）会放在一个或若干个项目中</li>
<li>我工作上每个项目的各种产出（包括会议纪要）会按照项目对应生成git repo</li>
</ul>
<p>项目制的好处是具备可回溯性。每个项目我可以用git来管理，这样，几乎在任何一台设备上我都可以看到我之前的工作。想想你三年前写的某个文档，你还能找到它么？你还能找回你的修改历史么？</p>
<p>项目制的另一大好处是可以在其之上使能工具。比如说你看到的这些微信文章，我随时可以</p>
<pre><code>make publish YEAR=2014</code></pre>
<p>来生成包含了2014年我所写文章的pdf。</p>
<h2>心态开放，勇于尝试</h2>
<p>在程序员社区里，语言之争，系统之争，软件思想之争几乎是常态。python vs ruby，go vs java vs erlang vs rust，scala vs cljure，OOP vs FP，iOS vs Android。其实不管黑猫白猫，抓到老鼠的就是好猫，facebook还用php呢。程序员应该用开放的心态去包容新的技术，新的思想，勇于尝试，而不是立即否定。这个世界最悲哀的是，手里有把锤子，看什么都是钉子（或者说，眼里就只能看见钉子）。</p>
<p>我接触mac时间不过三年。可这三年时间，我从对mac不屑，到深深热爱，最终成为mac的一个重度用户。很多东西用过才知道，不尝试不接触我可能永远活在自己下意识构筑的无形之墙的另一边。</p>
<p>最近的两年里我学习了erlang，golang，scala，还看了一点点clojure和rust。目前我热衷于golang开发，但并不妨碍我继续拥抱python和nodejs。每个程序员要在不同的层级上有一门主力语言，比如说我：</p>
<ul>
<li>系统级（realtime）：C （可能以后会是rust）</li>
<li>系统应用级（realtime）：erlang（养成中）</li>
<li>系统应用级（非realtime）：golang（养成中）</li>
<li>应用级：python</li>
<li>Web后端：python，nodejs，golang</li>
<li>Web前端：javascript</li>
<li>设备端：Android Java（暂无计划）</li>
</ul>
<p>这个列表你不必参考，我只是想用此来说明心态越开放，你看到的世界就越大。</p>
<hr/>

<p>如果你对本文感兴趣，欢迎订阅公众号『程序人生』（搜索微信号 programmer_life）。每天一篇原汁原味的文章，早8点与您相会。</p>
<p>如果你还意犹未尽，戳下面的链接（来自智库百科）回顾一下 <a href="http://wiki.mbalib.com/wiki/%E3%80%8A%E9%AB%98%E6%95%88%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E3%80%8B">高效能人士的七个习惯</a> 吧。</p>
]]></description>
            <link>http://tchen.me/posts/2014-03-05-highly-effective-programmer.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-03-05-highly-effective-programmer.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Wed, 05 Mar 2014 15:50:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[程序员混日子不完全手册]]></title>
            <description><![CDATA[<p>昨天收到同事转发的dtrace作者解释关于『为何dtrace在x86上能支持function boundary trace，而mips不行』的一封邮件点燃了我的战斗激情，写了段程序分别在mips，arm和x86上编了下求证。本想就此写篇微信文章，但琢磨一下还是算了，一来昨天已有承诺，二来这东西放在微信上估计打开率为0。</p>
<p>前天有读者希望我多写点职场的建议，我深感惶恐。思来想去，怎么写都像在熬鸡汤，干脆换个思路，教教大家如何混日子吧。</p>
<!--more-->

<p>除了程序员的老板们和公务员（这年头公务员也不好混啊），世界上估计没有一种职业比程序员更好混日子了。</p>
<p>程序员常见的场景一，软件崩溃：</p>
<p>『Tyr，你做的feature流量上到1G就crash了！』</p>
<p>『哦，我看看。尼玛，内存不够了，等着，我马上修好』</p>
<p>如果我是个建筑师：</p>
<p>『Tyr，昨晚设计的楼盘有家人办party，来了很多人，于是那幢楼坍塌了』</p>
<p>『哦，我看看。尼玛，钢筋放少了。等着，我～』</p>
<p>『等个屁，死伤几十人，你自裁吧』</p>
<p>程序员常见场景二，解bug：</p>
<p>『Tyr，这有个customer issue。在xxx场景下，网络不通。』</p>
<p>『能复现么？』</p>
<p>『能，blablabla』</p>
<p>『我给你编个版本哈』</p>
<p>『好』</p>
<p>『能工作了么？』</p>
<p>『不能』</p>
<p>『可能是另一个问题导致，我再给你一个版本吧』</p>
<p>『好』</p>
<p>『能工作了么？』</p>
<p>『不能』</p>
<p>。。。</p>
<p>（第5次后）</p>
<p>『Tyr，customer火很大了』</p>
<p>『我终于知道问题所在了。这个版本再不过，你杀了我吧』</p>
<p>『OK了』</p>
<p>（之后一封热情洋溢的邮件表扬了Tyr的出色表现）</p>
<p>如果我是个医生：</p>
<p>『大夫，我不舒服』</p>
<p>『能复现么？啊不对，你都什么症状啊』</p>
<p>『blablabla』</p>
<p>『你做这些检查，然后我给你开药哈』</p>
<p>『好』</p>
<p>（一周后）</p>
<p>『大夫，我病情加重了』</p>
<p>『啊，哎呀，你这可能不是肠炎，有可能是肺炎』</p>
<p>『啊？得，开药吧』</p>
<p>（两周后）</p>
<p>『大夫，我这病更重了』</p>
<p>『我再看看，从最新的检查看，你这可能是脑膜炎』</p>
<p>『。。。你把我当小白鼠了？我要告你！』</p>
<p>（之后Tyr失去了行医执照）</p>
<p>莫笑，这世界上可能没有比软件工程更不靠谱的工程了。虽有质量保证部门，但出点问题简直是家常便饭，不出问题反而让人惊讶；虽有项目管理甚至监理，可还经常延期。就这工程质量，客户还总能忍，你说怪不怪？</p>
<p>由于软件行业有这么些子特点，所以混日子也比别的行业容易。下面的不完全手册乃我十多年辛辛苦苦累积，您请搬好小板凳，静待我一一到来。</p>
<p><strong>混日子守则第一条：瞒天过海。</strong></p>
<p>这行业不靠谱，所以招人『难』，怎么办，一来给高薪，二来实行弹性工作制，不用打卡。这弹性工作制真是个好东西啊，非常方便咱刷存在感。早上十点一刻到，晚上七点一刻走。为啥这个时间？来得不算晚，走得足够晚。周六或者周日来公司上上网，来加班的同事一看，哟，Tyr怎么周末又来加班了？另外，算好老板限行的日子，然后赶在那天正巧七点过一点点到公司，途经老板的办公室不忘赞一句：这么早～</p>
<p><strong>混日子守则第二条：无中生有。</strong></p>
<p>随时保持自己忙碌，各种项目都凑上去充个数，但实际上都在邮件里扯淡，活没干多少。没关系，大家都注意到了你说的话，却往往忽略你干的事。</p>
<p><strong>混日子守则第三条：混水摸鱼，偷梁换柱。</strong></p>
<p>既然混日子，那么绩效必然不好，这时候必须想办法把水搅浑，让自己显得不那么『鹤立鸡群』。具体做法：你跟我讨论architecture，我跟你扯performance issue；你跟我谈performance optimization，我跟你扯not modulized；你跟我解决modularity，我跟你说我们要customer centric，其它的都是浮云。总之牵着你的鼻子走。</p>
<p><strong>混日子守则第四条：隔岸观火。</strong></p>
<p>没完没了地开会是混日子的最佳选择，尤其是各种没有schedule，没有action plan的讨论会。上来就把讨论的方向引到有争议的细枝末节，甚至和议题无关的地方，只要有争议就可。然后就可以坐等会议膨胀，通过一个会议引发更多的会议。让大家永远都在讨论，但总讨论不到点子上。</p>
<p><strong>混日子守则第五条：树上开花。</strong></p>
<p>要学会营造大场面，大阵势。估计项目时间的时候将一切风险，一切问题都尽可能放大。一个月就能看到成果的项目不好，想办法让其膨胀到半年，一年。想想看，一个月的项目你延期半个月，那是延期50%，多不好看；一年的项目延期三个月，才仅仅是25%，正常。而且项目时间越短，就越好追踪，反之，越难追踪。你要的不是产品的v1，而是打着v1旗号的v10。</p>
<p><strong>混日子守则第六条：走为上。</strong></p>
<p>一般这么混日子法，换个detail oriented的老板就得赶紧跑路。没关系，找家钱多人傻的公司继续混，将日子混到底。</p>
<p>hmm...</p>
<p>说了这么多~</p>
<p>Have you figured out the head fake?</p>
<p>我没在讲行为准则。我在谈<strong>文化</strong>。不贯彻以<strong>结果</strong>和<strong>产出</strong>为准的文化，神马的都是浮云。</p>
<p>Have you figured out the second head fake?</p>
<p>这篇文章文章不是写给程序员的，而是写给老板和即将当老板的人的。</p>
<p>程序员应该戳下面的链接看这篇文章（还是英文）。</p>
<p><a href="http://programming.oreilly.com/2014/01/7-ways-to-be-a-better-programmer-in-2014.html">7 Ways to be a Better Programmer in 2014</a></p>
<hr/>

<p>本文纯属扯淡，顺带小小地向Randy Pausch教授致敬。如果你没听过他的最后一课，在优酷上搜搜，趁着星星还是月亮的那个剧结局了的空档期，看看，就当学习英文了。</p>
<p>最后恳求大家一件事，方便的话上一下腾讯微博，收听『Tyr在路上』。程序君需要足够的粉来申请微博认证，进而申请微信认证，这样『程序人生』公众号就可以有自定义菜单，能更好地为您服务了。程序君先在这里跪谢啦。</p>
]]></description>
            <link>http://tchen.me/posts/2014-02-28-programmer-life.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-02-28-programmer-life.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Fri, 28 Feb 2014 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[闲扯code review]]></title>
            <description><![CDATA[<p>如果说git终于让工程师在合作撰写代码的过程中找回了丢失已久的乐趣，那么，code review的过程还是让人相当地抓狂。我用过的所有code review的工具，没有一款能让code review的过程轻松起来。</p>
<!--more-->

<p>公司内部使用的工具自不必说，那是反人类的极致体验。</p>
<p>reviewboard和gerrit不那么反人类，但submit review和review的流程也不太方便，而且体验并不一致。submit review可以在命令行下方便地完成，但review需要点开邮件通知里的链接才能查看。如果你一直在代码上工作，而不查邮件，你可能会miss掉一些review。</p>
<p>不过，这些体验上的问题都是细枝末节。目前已有的code review工具的最大问题是：<strong>它不是写给程序员用的！</strong>慢着，这话听着好耳熟？没错，Linux Tolvalds在撰写git的时候，就说svn最大的问题是这玩意儿不是写给程序员用的。</p>
<p>如果要我设计一款code review工具，它的使用体验会类似这样：</p>
<h2>Submit code review</h2>
<pre><code>$ git commit -a
$ git push</code></pre>
<p>Done! 不需要更多的流程了。</p>
<p>这里面隐含了如下步骤：</p>
<ul>
<li>git commit时会弹出一个form，所有项目都正确填写才能提交。</li>
<li>git push时会将diff push到review server上，review server会根据修改了那些文件确定出reviewers，然后从中round robin选两到三人进行review。</li>
</ul>
<p>与之最接近的体验是gerrit:</p>
<pre><code>$ git commit -a
$ git push origin HEAD:refs/for/master</code></pre>
<p>但，<code>HEAD:refs/for/master</code>究竟是什么，我想没多少人能搞懂。如果配置了一个repo必须要经过code review后才能push到服务器，那么，为何不直接把<code>git push</code>用做review的命令？</p>
<h2>Review the code</h2>
<p>蒂尔原则：code review应该和repo紧密相连，而不是那该死的邮件。</p>
<p>当reviewer在同样的repo下运行<code>git status</code>时，会有如下提示：</p>
<pre><code>$ git status
# On branch master
nothing to commit, working directory clean
You have 2 reviews:
  6ae24fe: PR12345 - can not connect to server, by Tyr Chen
  723e9e2: PR12346 - Tracking feature 123: add queue support, by Tyr Chen
You must run &quot;git review &lt;review-id&gt;&quot; to do review.</code></pre>
<p>这个提示很恼人，一般git用户都会尽快完成review以便让<code>git status</code>的输出看上去干净些。如果review长时间得不到处理，其颜色每隔4个小时变红一些，直至鲜红。</p>
<p>Reviewer可以运行<code>git review</code>进行代码review：</p>
<pre><code>$ git review 6ae24fe</code></pre>
<p>根据配置，这条命令会自动调出对应的代码比较工具，比如说<code>vimdiff</code>。如果没有指定，则会输出标准的<code>git diff</code>。</p>
<p>代码阅读完毕，可以使用：</p>
<pre><code>$ git review 6ae24fe --approve|reject</code></pre>
<p>这会弹出一个form，填写review的意见。</p>
<p>被round robin出的2-3个reviewers必须全部approve，这个review才算通过。如果某个reviewer在72小时内还没有review代码（可能休假去了），则相应的review自动被approve，review的注释是：&quot;review skipped automatically due to XXX not-responding&quot;。这就像信用记录，对于一个程序员来说，如果他review别人的代码总出现这样的日志，自己脸上也挂不住。</p>
<p>此外，review服务器还记录和索引每个review，方便日后检索。以后如果哪个问题是由某次不正确的修改导致的，那么能够很快查询到是谁批准了这段代码。</p>
<p>最后，review的数据最好能做visualization，每个程序员都能看到他的历史review图表（这个可以做得非常有意思），也可以看到各种各样的统计信息（比如说团队里提交代码的排行榜，review通过率排行榜，review大牛排行榜等等），让冷冰冰的code commit和code review活泼起来。</p>
<p>投票：如果有这样一个code review工具，你会试用么？回复即可。:)</p>
]]></description>
            <link>http://tchen.me/posts/2014-02-24-codereview.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-02-24-codereview.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Tue, 25 Feb 2014 06:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[公司成长之殇]]></title>
            <description><![CDATA[<p>自打踏入了创业者的行列，我就总会不自觉把自己置于某个位置之上，去操心如果是我掌舵，该如何如何。最近，我心头一直萦绕的一个问题是：为什么一家公司，不管曾经多么辉煌，多么具备创新能力，最终都会不可避免地向平庸滑去，甚至走向衰落？</p>
<p><!--more-->
这似乎是<a href="http://book.douban.com/subject/4243770/">『创新者的窘境』</a>中已经讨论过的话题。这本书阐述了破坏性技术是如何取代已有技术，以及管理良好的企业内部所蕴含的强大力量是如何阻碍它自己开发破坏性技术，这种力量让企业在挑战者面前不断将中低端市场拱手相让，一步步龟缩到高端市场，最终走向灭亡。里面的案例精彩而又发人深省。如果你没读过『创新者的窘境』，上下班乘地铁的时候可以拿来读读，比玩手游刷微博看我的文章带劲多了。</p>
<p>然而我想说的另外一个原因关乎于人 —— 人才密度。</p>
<p>在一家公司的初创期，它的人才密度是最大的。只有和产品（R&amp;D）/商业（sales）直接相关的人才组成团队。如果人才密度（Density of talent）可以表述为：</p>
<blockquote>
<p>Dt = (直接创造企业价值的员工 / 总员工) x (直接创造企业价值的工作时间 / 总工作时间) x 员工的平均能力</p>
</blockquote>
<p>那么，此时Dt无限逼近于1。</p>
<p>之后，随着公司的发展，员工越来越多，业务越来越复杂，更多的不直接创造价值的职位被引入：HR，Manager，Admin，Finance，IT，etc.，这就导致Dt开始震荡向下，逐渐远离1。更多的员工，更多的岗位和更复杂的业务意味者需要不断完善的流程来约束和引导，这必然带来更高的管理开销，从而进一步拉低了直接创造企业价值的工作时间。然后，马太效应就渐渐形成：有效工作时间的降低需要更多的人来弥补，更多的人又带来更加复杂的人力结构，更细化的业务流程，更高的管理开销，和更多的文山会海等，最终每个人的效率不断下滑，形成一个 downward spiral。</p>
<p><img src="/assets/files/posts/downward_spiral.jpg" alt="downward spiral"></p>
<p><a href="http://www.quora.com/Google-Company-History/I-heard-about-an-incident-in-Google-history-where-all-engineering-managers-were-fired-and-100-engineers-reported-directly-to-Wayne-Rosing-What-are-the-details">google曾经试图反抗</a>，解雇了所有的经理，但很快导致灾难性的后果，所以它又回到了传统的人力结构。</p>
<p>人的潜能在被直接赋予权利和责任的时候是最大的。当项目要层层审批，动用一点资金受到诸多限制，甚至写几行代码都要多个group进行review的话，每个人的潜能都被消耗殆尽。管理者开始寻求稳定，寻求最大程度follow process，这样犯错的机会会少很多；每个员工只能老老实实干好手头的工作，将新鲜的想法埋藏在心底。</p>
<p>于是，不甘平庸的人开始离开，而留下的人由于受到种种制肘，其能力向着整个公司的平均能力滑落。按照人才流动的规律，除非有特别的激励，一家企业的平均员工能力决定了它招到的人才的能力。这样一来，当人才不断自由出走和补入时，企业员工的平均能力也在不断地被拉低。</p>
<p>当google开始兴盛时，不少微软员工跳槽过来；当facebook在社交领域开疆拓土时，又有不少google的员工被吸引走。优秀的人总是愿意往人才密度（按我的表述）大的企业流动，因为这里有充分的施展空间（工作时间基本都用来创造价值了）。</p>
<p>我不知道该如何破这个局。没有实践就没有发言权。但如果让我来纸上谈兵的话，我愿意尝试这些手段：</p>
<ul>
<li>将薪水一直保持在行业的制高点。宁可少招人，也要多招高薪者。郭隗给燕昭王讲的『千金买马骨』的故事，就是这么个道理。</li>
<li>给予一线团队充分的权利和责任。产品（或者功能）的决策权和执行权下放到一线团队，而不是中高层管理者亲自挂帅。要让一线员工有敢干敢当，输则提头来见的责任心和气魄。sales team为何总能涌现英雄豪杰，就是因为他们有权利，有责任，有担当。</li>
<li>最大限度地缩减流程，减少企业组织机构中的层级。很多新兴公司在做类似的尝试，如twitter, github, netflix（还有很多不知名的创业公司），效果如何不得而知，但这应该是一条路子。netflix据说连报销，差旅，请假的流程都废除了，企业相信员工能够做出最有利于公司的判断和选择。</li>
<li>在文化上熏陶，从根上落实前面三点。</li>
</ul>
]]></description>
            <link>http://tchen.me/posts/2014-02-18-pain-of-grow.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-02-18-pain-of-grow.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Wed, 19 Feb 2014 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Plan for taking coursera courses 1F 2014]]></title>
            <description><![CDATA[<p>This is not a post for you - it&#39;s only my own plans. These are the courses I&#39;m currently interested and will put an eye on it. The probability to execute them all is less than 50%.</p>
<p>If you&#39;re really interested, you can subscribe to my weixin public account: <code>程序人生</code>.</p>
<p><img src="/assets/files/weixin.jpg" width="150px" /></p>
<!-- more -->

<p>Past courses:</p>
<ul>
<li><a href="https://class.coursera.org/sciwrite-2012-001/lecture">Writing in Sciences (Stanford)</a></li>
<li><a href="https://class.coursera.org/lead-ei-001">Inspiring Leadership through Emotional Intelligence</a></li>
<li><a href="https://class.coursera.org/sdn-001/lecture">Software Defined Networking</a></li>
<li><a href="https://class.coursera.org/organalysis-002/lecture">Organizational Analysis (Stanford)</a></li>
<li><a href="https://class.coursera.org/modelsystems-001">Everything is the Same: Modeling Engineered Systems</a></li>
</ul>
<h2>The First Step in Entrepreneurship</h2>
<p>URL: <a href="https://class.coursera.org/innovativeideas-004/lecture">https://class.coursera.org/innovativeideas-004/lecture</a></p>
<h3>Syllabus</h3>
<ul>
<li>Entrepreneurial Perspective</li>
<li>Entrepreneurial Mindset, Motivations and Behavoirs</li>
<li>Industry Understanding</li>
<li>Customer Understanding</li>
<li>Business Modeling</li>
<li>Business Planning</li>
</ul>
<h3>Time</h3>
<ul>
<li>Feb 3rd</li>
<li>6 weeks</li>
<li>5-7 hours of work / week</li>
<li>English subtitles</li>
</ul>
<h2>Data Analysis and Statistical Inference</h2>
<p>URL: <a href="https://www.coursera.org/course/statistics">https://www.coursera.org/course/statistics</a></p>
<p>suggested reading: <a href="https://www.dropbox.com/s/cr9e177a4yziqih/os2.pdf">https://www.dropbox.com/s/cr9e177a4yziqih/os2.pdf</a></p>
<h3>Syllabus</h3>
<ul>
<li>Introduction to data</li>
<li>Probability and distributions</li>
<li>Foundations for inference</li>
<li>Finish up Unit 3 + Midterm</li>
<li>Statistical inference for numerical variables</li>
<li>Statistical inference for categorical variables</li>
<li>Introduction to linear regression</li>
<li>Multiple linear regression</li>
<li>Review / catch-up week</li>
<li>Final exam</li>
</ul>
<h3>Time</h3>
<ul>
<li>Feb 17th</li>
<li>10 weeks</li>
<li>6-8 hours of work / week</li>
<li>English subtitles</li>
</ul>
<h2>Networks: Friends, Money, and Bytes</h2>
<p>URL: <a href="https://www.coursera.org/course/friendsmoneybytes">https://www.coursera.org/course/friendsmoneybytes</a></p>
<h3>Syllabus</h3>
<ul>
<li>What makes CDMA work for my smartphone?</li>
<li>How does Google rank webpages?</li>
<li>How does Netflix recommend movies?</li>
<li>Why do AT&amp;T and Verizon Wireless charge me $10 a GB?</li>
<li>How does traffic get through the Internet?</li>
<li>Why doesn&#39;t the Internet collapse under congestion?</li>
<li>Why is WiFi faster at home than at a hotspot?</li>
</ul>
<h3>Time</h3>
<ul>
<li>March 1st</li>
<li>9 weeks</li>
<li>8 hours of work / week</li>
<li>English subtitles</li>
</ul>
<h2>Machine Learning</h2>
<p>URL: <a href="https://www.coursera.org/course/ml">https://www.coursera.org/course/ml</a></p>
<h3>Syllabus</h3>
<p>n/a</p>
<h3>Time</h3>
<ul>
<li>March 3rd</li>
<li>10 weeks</li>
<li>5-7 hours of work / week</li>
<li>English subtitles</li>
</ul>
<h2>An Introduction to Operations Management</h2>
<p>URL: <a href="https://www.coursera.org/course/operations">https://www.coursera.org/course/operations</a></p>
<h3>Syllabus</h3>
<ul>
<li>Introduction</li>
<li>Process analysis</li>
<li>Productivity</li>
<li>Responsiveness</li>
<li>Quality</li>
<li>Product variety</li>
</ul>
<h3>Time</h3>
<ul>
<li>March 3rd</li>
<li>8 weeks</li>
<li>5-7 hours of work / week</li>
<li>English subtitles</li>
</ul>
<h2>Grow to Greatness: Smart Growth for Private Businesses, Part II</h2>
<p>Previous course: <a href="https://class.coursera.org/growtogreatness-002/lecture">https://class.coursera.org/growtogreatness-002/lecture</a></p>
<p>URL: <a href="https://www.coursera.org/course/GTG">https://www.coursera.org/course/GTG</a></p>
<h3>Syllabus</h3>
<ul>
<li>The Entrepreneur Must Grow, Too! </li>
<li>The “Secret” of High Performance is High Employee Engagement</li>
<li>Growth Is Much More Than a Strategy—It Requires a SYSTEM</li>
<li>The Surprising Difficulties in Building a Senior Management Team</li>
</ul>
<h3>Time</h3>
<ul>
<li>March 17rd</li>
<li>4 weeks</li>
<li>4-6 hours of work / week</li>
<li>English subtitles</li>
</ul>
<h2>Introduction to Public Speaking</h2>
<p>URL: <a href="https://www.coursera.org/course/publicspeak">https://www.coursera.org/course/publicspeak</a></p>
<h3>Syllabus</h3>
<ul>
<li>Design and deliver basic arguments clearly.</li>
<li>Design and deliver informative presentations clearly.</li>
<li>Design and deliver complex arguments persuasively.</li>
<li>Speak confidently with appropriate rate, projection, movement, and vocal variety.</li>
<li>Evaluate and critique speeches insightfully.</li>
</ul>
<h3>Time</h3>
<ul>
<li>March 31th</li>
<li>10 weeks</li>
<li>3-5 hours of work / week</li>
<li>English subtitles</li>
</ul>
]]></description>
            <link>http://tchen.me/posts/2014-02-14-knowing-by-learning.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-02-14-knowing-by-learning.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Fri, 14 Feb 2014 15:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Golang之chan/goroutine]]></title>
            <description><![CDATA[<p>最近在team内部培训golang，目标是看看golang能否被C工程师快速掌握。我定了个一个月，共计20小时的培训计划，首先花10个小时（两周，每天1小时）让大家掌握golang的基本要素，能写一些入门级的程序，之后再花两周时间做一个1000行代码规模的Proof of concept项目。为了能在培训的slides上直接运行go code，我做了个简单的 <a href="https://github.com/tyrchen/coderunnerd">coderunnerd</a>，可以接受websocket传过来的code，编译运行再把stdout返回给websocket，为了更清晰地说明goroutine和chan的使用，以及golang的一些best practice，我分阶段写了个 <a href="https://github.com/tyrchen/chatroom">chatroom</a>。本文介绍一下如何使用goroutine和chan来做一个简单的聊天室。</p>
<!-- more -->

<h2>需求</h2>
<p>聊天室的需求很简单：</p>
<ul>
<li>服务器监听某个端口，客户端可连接并开始聊天。</li>
<li>任何客户端的发言都会被广播给所有客户端。</li>
<li>客户端可以为自己设定名字或者执行一些聊天命令。</li>
</ul>
<h2>设计与实现</h2>
<h3>基本想法</h3>
<p>服务器（Server）：</p>
<ul>
<li>Server accept下来的connection被存在一个数据结构Client中，并以connection为key，Client为value，存在map里。</li>
<li>每个Client都有自己的goroutine去接受和发送消息。Client和Server之间通过channel来传递消息。</li>
</ul>
<p>客户端（Client）：</p>
<ul>
<li>发送和接收都有各自的goroutine，通过channel和stdin/stdout交互</li>
</ul>
<h3>实现</h3>
<p>所有chat相关的逻辑都被封装在 <code>chat</code> package里，client和server的cli只负责将ui和chat粘合起来。</p>
<p>首先，是核心的数据结构：</p>
<pre><code>type Message chan string

type Client struct {
    conn     net.Conn
    incoming Message
    outgoing Message
    reader   *bufio.Reader
    writer   *bufio.Writer
    quiting  chan net.Conn
    name     string
}</code></pre>
<p>Client 是一个服务器和客户端都共享的数据结构。conn是建立的连接，reader/writer是conn上的bufio。Client与外界的接口是incoming/outgoing两个channel，即：Server 会把要发送的内容 push 到 outgoing channel 里，供writer去写；而从reader读入的数据会 push 到 incoming channel 里，供 Server 读。</p>
<p>每个 Client 有自己的名字，服务器端代码会使用这个名字（客户端代码不会使用）。</p>
<pre><code>type Token chan int
type ClientTable map[net.Conn]*Client

type Server struct {
    listener net.Listener
    clients  ClientTable
    tokens   Token
    pending  chan net.Conn
    quiting  chan net.Conn
    incoming Message
    outgoing Message
}</code></pre>
<p>Server 保存一张 <code>ClientTable</code>。每个 accept 到的 conn 会 push 进 pending channel，等待创建client。Server有 incoming / outgoing 两个 channel，分别和 client 的 incoming / outgoing 关联。</p>
<p>Server 有一组 tokens，决定了一个Server最多能装多少Client（避免Server overloading）。</p>
<p>下面看 Server 的创建流程：</p>
<pre><code>const (
    MAXCLIENTS = 50
)

func CreateServer() *Server {
    server := &amp;Server{
        clients:  make(ClientTable, MAXCLIENTS),
        tokens:   make(Token, MAXCLIENTS),
        pending:  make(chan net.Conn),
        quiting:  make(chan net.Conn),
        incoming: make(Message),
        outgoing: make(Message),
    }
    server.listen()
    return server
}</code></pre>
<p>很简单，无须多说。<code>server.Listen()</code> 实现如下：</p>
<pre><code>func (self *Server) listen() {
    go func() {
        for {
            select {
            case message := &lt;-self.incoming:
                self.broadcast(message)
            case conn := &lt;-self.pending:
                self.join(conn)
            case conn := &lt;-self.quiting:
                self.leave(conn)
            }
        }
    }()
}</code></pre>
<p>这是一个 goroutine，做三件事：</p>
<ul>
<li>如果 <code>self.incoming</code> 收到东西，将其 broadcast 出去。</li>
<li>如果有新的连接，则将其接入到聊天室。</li>
<li>如果一个 Client 退出，则进行一些清理和通知。</li>
</ul>
<p>我们先看一个新连接如何加入到聊天室：</p>
<pre><code>func (self *Server) join(conn net.Conn) {
    client := CreateClient(conn)
    name := getUniqName()
    client.SetName(name)
    self.clients[conn] = client

    log.Printf(&quot;Auto assigned name for conn %p: %s\n&quot;, conn, name)

    go func() {
        for {
            msg := &lt;-client.incoming
            log.Printf(&quot;Got message: %s from client %s\n&quot;, msg, client.GetName())

            if strings.HasPrefix(msg, &quot;:&quot;) {
                if cmd, err := parseCommand(msg); err == nil {
                    if err = self.executeCommand(client, cmd); err == nil {
                        continue
                    } else {
                        log.Println(err.Error())
                    }
                } else {
                    log.Println(err.Error())
                }
            }
            // fallthrough to normal message if it is not parsable or executable
            self.incoming &lt;- fmt.Sprintf(&quot;%s says: %s&quot;, client.GetName(), msg)
        }
    }()

    go func() {
        for {
            conn := &lt;-client.quiting
            log.Printf(&quot;Client %s is quiting\n&quot;, client.GetName())
            self.quiting &lt;- conn
        }
    }()
}</code></pre>
<p>这里先通过连接建立 Client 数据，为其自动分配一个唯一的名字，然后将其加入到 <code>ClientTable</code> 中。注意在这个函数里每个 Client 会运行两个 goroutine，我们先记住这一点。</p>
<p>第一个 goroutine 从 Client 的 incoming channel 中拿出 message，如果是命令的话就执行之，否则将其放入 Server 的 incoming channel，等待被 broadcast 出去。之前 <code>Listen()</code> 方法里有对应的处理：</p>
<pre><code>            case message := &lt;-self.incoming:
                self.broadcast(message)</code></pre>
<p>顺手看一下 <code>broadcast</code> 怎么做的：</p>
<pre><code>func (self *Server) broadcast(message string) {
    log.Printf(&quot;Broadcasting message: %s\n&quot;, message)
    for _, client := range self.clients {
        client.outgoing &lt;- message
    }
}</code></pre>
<p>第二个 goroutine 从 Client 的 quiting channel 中拿出 conn，放入 Server 的 quiting channel 中，等待处理某个 Client 的退出。同样在 <code>Listen()</code> 中有处理：</p>
<pre><code>            case conn := &lt;-self.quiting:
                self.leave(conn)</code></pre>
<p>顺手也看看 <code>Leave</code> 做些什么：</p>
<pre><code>func (self *Server) leave(conn net.Conn) {
    if conn != nil {
        conn.Close()
        delete(self.clients, conn)
    }

    self.generateToken()
}</code></pre>
<p><code>Leave</code> 里有两个坑，一个是从 map 里删除一个 key 是否需要 synchronize，我们放在下面的『并发与同步』里详细再表；另一个坑是 <code>generateToken()</code>，马上就会讲到。</p>
<p>看了这么多代码了，还没看到服务器建连的代码，有点说不过去。接下来我们看 <code>Start</code>：</p>
<pre><code>func (self *Server) Start(connString string) {
    self.listener, _ = net.Listen(&quot;tcp&quot;, connString)

    log.Printf(&quot;Server %p starts\n&quot;, self)

    // filling the tokens
    for i := 0; i &lt; MAXCLIENTS; i++ {
        self.generateToken()
    }

    for {
        conn, err := self.listener.Accept()

        if err != nil {
            log.Println(err)
            return
        }

        log.Printf(&quot;A new connection %v kicks\n&quot;, conn)

        self.takeToken()
        self.pending &lt;- conn
    }
}</code></pre>
<p>这里 <code>generateToken</code> 及 <code>takeToken</code> 与 <code>Leave</code> 里的 <code>generateToken</code> 呼应。这些代码对应一个隐式需求：服务器不可过载。所以我们有 <code>MAXCLIENTS</code> 来限制一个服务器的 client 上限。但是，怎么比较漂亮地处理这个上限问题？因为在一个真实的聊天场景下，聊天室里的人是可以进进出出的。</p>
<p>我们采用 token。系统生成有限的 token，被拿光后，当且仅当有人归还 token，等待者才能获得 token，进入聊天室。在 golang 中，goroutine 和 chan 简直是为此需求量身定制的。我们看运作机制：</p>
<ul>
<li>首先生成 MAXCLIENTS 个 token。</li>
<li>第 1 - MAXCLIENTS 个 client:<ul>
<li>从 tokens 里拿走一个 token</li>
<li>把自己的 conn 放入 pending channel（如果之前的 pending conn 还被取走，则这个 goroutine就会被挂起，等待之前的 pending conn 被取走。否则，继续执行。</li>
</ul>
</li>
<li>第 (MAXCLIENTS + 1) 个 client:<ul>
<li>从 tokens 里拿不到 token 了，当前的 goroutine 在这一点上挂起，等待 token。</li>
</ul>
</li>
<li>有人离开：<ul>
<li>归还一个 token，这样之前被挂起等待 token 的 goroutine 被唤醒，继续执行。 </li>
</ul>
</li>
</ul>
<p>没有使用任何同步机制，代码干净清晰漂亮，我们就完成了一个排队系统。Ura for go!</p>
<hr/>

<p>喘一口气，接下来看 <code>join</code> 的时候调用的 <code>CreateClient</code> 的代码：</p>
<pre><code>func CreateClient(conn net.Conn) *Client {
    reader := bufio.NewReader(conn)
    writer := bufio.NewWriter(conn)

    client := &amp;Client{
        conn:     conn,
        incoming: make(Message),
        outgoing: make(Message),
        quiting:  make(chan net.Conn),
        reader:   reader,
        writer:   writer,
    }
    client.Listen()
    return client
}</code></pre>
<p><code>client.Listen</code> 极其细节：</p>
<pre><code>func (self *Client) Listen() {
    go self.Read()
    go self.Write()
}

func (self *Client) Read() {
    for {
        if line, _, err := self.reader.ReadLine(); err == nil {
            self.incoming &lt;- string(line)
        } else {
            log.Printf(&quot;Read error: %s\n&quot;, err)
            self.quit()
            return
        }
    }

}

func (self *Client) Write() {
    for data := range self.outgoing {
        if _, err := self.writer.WriteString(data + &quot;\n&quot;); err != nil {
            self.quit()
            return
        }

        if err := self.writer.Flush(); err != nil {
            log.Printf(&quot;Write error: %s\n&quot;, err)
            self.quit()
            return
        }
    }

}</code></pre>
<p><code>client.Listen</code> 里我们也生成了两个 goroutine，加上之前的两个，每个 client 有四个 goroutine（所以运行中的Server的 gorutine 的数量接近于 client num * 4）。虽然我们可以做一些优化，但这并不要紧，一个 go 进程里运行成千上万个 goroutine没有太大问题，因为 goroutine 运行在 userspace，其 memory footprint很小（几k），切换代价非常低（没有 syscall）。</p>
<p>这两个 goroutine 正如一开始设计时提到的，一读一写，通过 channel 和外界交互。</p>
<p>这就是整个聊天室的主体代码。接下来的命令行就很简单了。</p>
<p>先看 Server 代码：</p>
<pre><code>package main

import (
    . &quot;chatroom/chat&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    if len(os.Args) != 2 {
        fmt.Printf(&quot;Usage: %s &lt;port&gt;\n&quot;, os.Args[0])
        os.Exit(-1)
    }

    server := CreateServer()
    fmt.Printf(&quot;Running on %s\n&quot;, os.Args[1])
    server.Start(os.Args[1])

}</code></pre>
<p>接下来是 Client 代码：</p>
<pre><code>package main

import (
    &quot;bufio&quot;
    . &quot;chatroom/chat&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;os&quot;
)

func main() {
    if len(os.Args) != 2 {
        fmt.Printf(&quot;Usage: %s &lt;port&gt;\n&quot;, os.Args[0])
        os.Exit(-1)
    }

    conn, err := net.Dial(&quot;tcp&quot;, os.Args[1])

    if err != nil {
        log.Fatal(err)
    }

    defer conn.Close()
    in := bufio.NewReader(os.Stdin)
    out := bufio.NewWriter(os.Stdout)

    client := CreateClient(conn)

    go func() {
        for {
            out.WriteString(client.GetIncoming() + &quot;\n&quot;)
            out.Flush()
        }
    }()

    for {
        line, _, _ := in.ReadLine()
        client.PutOutgoing(string(line))
    }

}</code></pre>
<p>运行一下（起了两个client）：</p>
<pre><code>➜  chatroom git:(master) ./bin/chatserver :5555
➜  chatroom git:(master) ./bin/chatserver :5555
Running on :5555
2014/01/30 09:05:24 Server 0xc2000723c0 starts
2014/01/30 09:05:34 A new connection &amp;{{0xc20008f090}} kicks
2014/01/30 09:05:34 Auto assigned name for conn 0xc200000100: User 0
2014/01/30 09:05:48 A new connection &amp;{{0xc20008f120}} kicks
2014/01/30 09:05:48 Auto assigned name for conn 0xc200000148: User 1
2014/01/30 09:06:39 Got message: Hello from client User 0
2014/01/30 09:06:39 Broadcasting message: User 0 says: Hello
2014/01/30 09:06:48 Got message: :name Tyr from client User 1
2014/01/30 09:06:48 Broadcasting message: Notification: User 1 changed its name to Tyr
2014/01/30 09:06:57 Got message: Hello world! from client User 0
2014/01/30 09:06:57 Broadcasting message: User 0 says: Hello world!
2014/01/30 09:07:01 Got message: Hello from client Tyr
2014/01/30 09:07:01 Broadcasting message: Tyr says: Hello
2014/01/30 09:08:19 Read error: EOF
2014/01/30 09:08:19 Client User 0 is quiting
2014/01/30 09:08:19 Broadcasting message: Notification: User 0 quit the chat room.</code></pre>
<p>其中一个 client：</p>
<pre><code>➜  chatroom git:(master) ./bin/chatclient :5555
User 0 says: Hello
:name Tyr
Notification: User 1 changed its name to Tyr
User 0 says: Hello world!
Hello
Tyr says: Hello
Notification: User 0 quit the chat room.</code></pre>
<p>完整代码请见 <a href="https://github.com/tyrchen/chatroom">github repo</a>。</p>
<p>以上代码能正确运行，不过还有不少问题，比如 server stop 时 goroutine 并未正确 cleanup。但对于理解 <code>goroutine</code> 和 <code>chan</code> 来说，不失为一个很好的例子。</p>
<h2>Lessons learnt</h2>
<h3>使用go test</h3>
<p>我现在写代码已经离不开非常方便的 <code>go test</code> 了。golang 的开发者们非常聪明，他们知道把一个 test framework / utility 放在核心的安装包中是多么重要。这个 chatroom 是迭代开发的，你可以 checkout v0.1/v0.2/v0.3 分别看不同时期的代码。每次添加新功能，或者重构代码时，<code>go test ./chat</code> 就是我信心的保证。代码和test case同步开发，新的 feature 有新的 case 去 cover，这样一点点做上去。拿柳总的话说，就是：『垒一层土，夯实，再垒一层』。</p>
<p>例子：</p>
<pre><code>➜  chatroom git:(master) go test ./chat
ok      chatroom/chat   0.246s</code></pre>
<h3>并发与同步</h3>
<p>golang 在设计时做了很多取舍。其中，对map的操作是否原子就有很多 debate。最终，为了 performance，map 的操作不具备原子性，亦即不是 multithread safe。所以，正确的做法是在从 map 中删除一个 conn 时和使用 <code>range</code> 中读取时做读写同步。由于本例运行在单线程环境下（是的，如果你不指定，golang process 默认单线程），且以教学为目的，实在不忍用难看的同步操作降低代码的美感。</p>
<p>另外一种做法是在读写两个需要同步的地方使用 channel 进行同步（还记得刚刚讲的 token）吧？</p>
<p>如果你对 map 的 thread-safe 感兴趣，可以读读 <a href="http://stackoverflow.com/questions/12938233/is-getting-a-value-using-range-not-thread-safe-in-go">stackoverflow上的这个问题</a>。</p>
<h3>通过close来向所有goroutine传递终止讯息</h3>
<p>在我的代码里，close 做得比较 ugly，不知你是否感受到了。更好的做法是使用 <code>close</code> 一个 channel 来完成关闭 goroutine 的动作。当 close 发生时，所有接收这个 channel 的 goroutine 都会收到通知。下面是个简单的例子：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
    &quot;time&quot;
)

const (
    N = 10
)

func main() {
    quit := make(chan bool)

    for i := 0; i &lt; N; i++ {
        go func(name string) {
            for {
                select {
                case &lt;-quit:
                    fmt.Printf(&quot;clean up %s\n&quot;, name)
                    return
                }
            }
        }(strconv.Itoa(i))
    }
    close(quit)

    for {
        time.Sleep(1 * time.Second)
    }
}</code></pre>
<p>我生成了 N 个 goroutine，但只需使用一个 <code>close</code> 就可以将其全部关闭。在 chatroom 代码中，关闭 server 时，也可以采用相同的方法，关闭所有的 client 上的 goroutine。</p>
<p>下面是上述代码执行的结果：</p>
<pre><code>➜  terminate  go run terminate.go
clean up 0
clean up 1
clean up 2
clean up 3
clean up 4
clean up 5
clean up 6
clean up 7
clean up 8
clean up 9</code></pre>
<h3>尽可能把任务分布在goroutine中</h3>
<p>如果你没有看过 Rob Pike 的 <a href="http://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not parallelism</a>，建议一定要看，不管你有没有 golang 的 background。Concurrency 是你写软件的一种追求，和是否并行无关，但和模块化，简单，优雅有关。</p>
<h3>goroutine不可做无阻塞的infinite loop</h3>
<p>goroutine，至少在 golang 1.2 及之前的版本，都运行在一个 cooperative multitasking 的 scheduler 上。所以你要保证你的任何一个 infinite loop 都要有可能被 block 住，无论是 block 在 IO, chan, 还是主动 block 在 timer 上，总之，infinite loop 要有退出机制。刚才的例子我们稍微改改：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
    //&quot;time&quot;
)

const (
    N = 10
)

func main() {
    quit := make(chan bool)

    for i := 0; i &lt; N; i++ {
        go func(name string) {
            for {
                select {
                case &lt;-quit:
                    fmt.Printf(&quot;clean up %s\n&quot;, name)
                    return
                }
            }
        }(strconv.Itoa(i))
    }
    close(quit)

    for {
        //time.Sleep(1 * time.Second)
    }
}</code></pre>
<p>乍一看，这个例子中的 gorountine应该能收到 <code>close</code> 而自我关闭。在 <code>main</code> 执行的过程中，头十个新创建出来的 <code>goroutine</code> 还未得到调度。虽然在 main 里我们 close 了 quit，但由于接下来的 dead loop 一直不释放 CPU，所以其他 goroutine 一直得不到调度。运行的话没有任何输出：</p>
<pre><code>➜  terminate  go run terminate.go
^Cexit status 2</code></pre>
<p>我们稍稍改改这个程序：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;strconv&quot;
    //&quot;time&quot;
)

const (
    N = 10
)

func main() {
    runtime.GOMAXPROCS(2)
    quit := make(chan bool)

    for i := 0; i &lt; N; i++ {
        go func(name string) {
            for {
                select {
                case &lt;-quit:
                    fmt.Printf(&quot;clean up %s\n&quot;, name)
                    return
                }
            }
        }(strconv.Itoa(i))
    }
    close(quit)

    for {
        //time.Sleep(1 * time.Second)
    }
}</code></pre>
<p>现在允许这个程序运行在两个 thread 上。这样就能正常运行了。但切记，没有阻塞机制的 infinite loop 不是一个好的设计。</p>
<pre><code>➜  terminate  go run terminate1.go
clean up 0
clean up 1
clean up 2
clean up 3
clean up 4
clean up 5
clean up 6
clean up 7
clean up 8
clean up 9
^Cexit status 2</code></pre>
<h3>DRY (Don&#39;t Repeat Yourself)</h3>
<p>写 chatroom 时，我不断重构代码，其目的就是能让代码干净，漂亮。比方我的一次 commit：<code>git diff 39690d9 6851177</code>，就是在做 test case refactor。</p>
<p>DRY 的前提是有完善的 test case，前文也提到。这是项目内部的 DRY。</p>
<p>另外一种 DRY 的方式是（从我途客圈的前同事 @chenchiyuan 那里学到的）：如果两个或以上的项目中都用到类似结构的代码，则考虑将其重构到一个第三方的 lib 里。在 chatroom 中，有两处这样的重构，重构在我的 <a href="https://github.com/tyrchen/goutil">goutil</a> 项目中。</p>
<p>第一处是生成唯一数：</p>
<pre><code>package uniq

var (
        num = make(chan int)
)

func init() {
        go func() {
                for i := 0; ; i++ {
                        num &lt;- i
                }
        }()
}

func GetUniq() int {
        return &lt;-num
}</code></pre>
<p>第二处是正则表达式匹配，将匹配的结果放入一个 map 的 slice 里：</p>
<pre><code>package regex

import (
        &quot;regexp&quot;
)

const (
        KVPAIR_CAP = 16
)

type KVPair map[string]string

func MatchAll(r *regexp.Regexp, data string) (captures []KVPair, ok bool) {
        captures = make([]KVPair, 0, KVPAIR_CAP)
        names := r.SubexpNames()
        length := len(names)
        matches := r.FindAllStringSubmatch(data, -1)
        for _, match := range matches {
                cmap := make(KVPair, length)
                for pos, val := range match {
                        name := names[pos]
                        if name != &quot;&quot; {
                                cmap[name] = val
                        }
                }
                captures = append(captures, cmap)
        }
        if len(captures) &gt; 0 {
                ok = true
        }
        return
}</code></pre>
<p>总结一条铁律：project 级的 DRY 是函数化，package化；cross project的 DRY 是 repo 化。</p>
<h2>后记</h2>
<p>大过年的，我这么嘚吧嘚吧地你也读得挺累，感谢你一路读到这里，新年快乐！</p>
<p><img src="/assets/files/photos/baby20140130.jpg" alt="小宝"></p>
]]></description>
            <link>http://tchen.me/posts/2014-01-27-golang-chatroom.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-01-27-golang-chatroom.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Thu, 30 Jan 2014 15:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[2014年年会节目脚本 - Branch取经记]]></title>
            <description><![CDATA[<p>每年的年会，依team旧例：新员工挑大梁演主角，而且要无耻度无底线。2013我是新员工，所以不得不被安排角色。一不小心大家选了个三国的剧本 <a href="http://www.docin.com/p-111786442.html">三国无间道</a>，重口一致要让我演董卓，说我体态样貌样样俱全。我一看剧本，这是毁人的节奏啊。不行不行，于是毛遂自荐当编剧，卸了主演。话说这三国无间道的剧本有点烂，笑点不多，和内事外事均无半毛钱关系，于是干脆一狠心，推翻重来。正巧13年重读了『西游记』，对唐太宗地府还魂记还记忆犹新，于是以此为蓝本展开故事。剧本着眼于普度众生，让大多数team成员都能上个台，露个脸，于是人物众多，在一个主线故事下，没有绝对的主角，算是本剧的小小遗憾。</p>
<p>以下内容做了些删改，避免暴露一些内部信息。</p>
<!--more-->

<h2>人物</h2>
<p>唐太宗：Tony</p>
<p>武媚娘：Lily</p>
<p>观音姐姐：Halin</p>
<p>黑白无常：Daniel, Leo</p>
<p>王玄奘：Dereck</p>
<p>邵悟空：Yafang</p>
<p>郭悟能：Cliff</p>
<p>郭悟净：Tim</p>
<p>天竺城管：Bo</p>
<p>接引道人：Dongdong</p>
<p>菩提祖师：Colin </p>
<p>举牌，新闻联播口型：Yaling，Hao</p>
<p>P1, P2 Issue: Hao</p>
<p>旁白及音乐播放：Tyr</p>
<h2>第一幕</h2>
<p>（牌子飘过：本故事纯属扯淡，请勿对号入座）</p>
<p>（中宫内，武媚娘正在弹吉他：一闪一闪亮晶晶）</p>
<p>（唐太宗背着手走进来）</p>
<p>唐太宗：抽刀断水水更流，举杯消愁愁更愁，人生在世不称意,明朝散发弄…扁…舟。</p>
<p>武媚娘（起身相迎）：陛下。</p>
<p>唐太宗：媚娘免礼。（走到媚娘旁边的龙榻前，卧在龙榻上，一脸倦容）</p>
<p>武媚娘：陛下满面愁容，是否国事太过繁重？</p>
<p>唐太宗：媚娘，自从天庭将 branch 业务托朕掌管，我就吃也吃不好，睡也睡不着，那些海龙王，河龙王，井龙王，加上女儿国，宝象国等各国国君天天给我开p1 issue，还动不动就escalate到观音姐姐甚至玉帝那里，弄得我好生烦躁。唉～～累觉不爱啊（说罢，闭上眼睛）</p>
<p>武媚娘：陛下莫愁，臣妾刚学会一首『广陵散』，这就弹来，为陛下安安神。</p>
<p>（媚娘弹奏两只老虎，唐太宗随着音乐晃着脑袋扭着身子渐渐入睡，入睡，媚娘放下吉他，拿苍蝇拍给太宗扇风，并打苍蝇）</p>
<p>（灯光转暗，黑白无常在远处现身。道具：招魂幡，一串糖葫芦，一个风车，凸显过年气氛）</p>
<p>（音乐 You drive me crazy）</p>
<audio src="/assets/files/mp3/1-1-you-drive-me-crazy.mp3" controls="controls"></audio>

<p>黑无常：阎王教人三更死，绝不留人到五更。可是就在前两天，地府出了大事！分布在阴曹地府各个角落的firewall不停的crash，真是一塌糊涂啊！</p>
<p>白无常：生死薄信息系统全部瘫痪，原本一帮贪官死期已至，结果到今天还活蹦乱跳的；高丽国三胖子的姑父本来还有十年阳寿，却嗝屁投胎去了。</p>
<p>黑无常：阎王大怒，差我兄弟勾了branch的负责人前去问话，说句公道话，这branch的活真心不好干啊。</p>
<p>白无常：谁说不是呢？以前大家都叫他小白，叫我小黑，叫得人家心里好自卑。自打当了JTAC以后，我就营养不良，脸色越来越白，上次PTO几天去高丽，一堆美女围着我问我用的面膜品牌。我告诉她们：要美白，请接customer issue，谁用谁知道！</p>
<p>黑无常：皇宫已到，那不是就是负责branch的老李？</p>
<p>（黑白上前锁住唐太宗，唐太宗惊醒）</p>
<p>白无常：老李，阎王要你去地府开个secure meeting，速速跟了我们去吧！</p>
<p>（唐太宗反抗，武媚娘上前阻拦，众人闹成一团）</p>
<p>唐太宗：我死也不去！哦，不，我不要死！</p>
<p>黑无常：不去就双规你！</p>
<p>唐太宗：大慈大悲观世音救命啊！</p>
<p>（观音姐姐手持玉净瓶，摆着兰花指出现。）</p>
<p>观音姐姐：善哉善哉，给贫僧一个薄面，大家请住手。</p>
<p>（众人住手，黑白无常原地吐舌头）</p>
<p>唐太宗：欧～巴～（尾音拖三秒），你来得正好。佛说你不入地狱谁入地狱，这个meeting还是你参加吧。你好歹是个喜大普奔的菩萨，阎王爷那说得上话。</p>
<p>（观音姐姐满脸黑线。黑线飘过。）</p>
<p>观音姐姐（塞给黑白一人一个红包）：黑白无常，你等且回去禀报阎罗王，我有个极好的workaround，地府不是有孟婆汤么，浇在那些有问题的盒子上可保十日平安。</p>
<p>黑白：尊法旨，不过我们要留一个人质！（拉着媚娘下场）</p>
<p>媚娘（伸手）：陛下～</p>
<audio src="/assets/files/mp3/1-2-huisekongjian.mp3" controls="controls"></audio>

<p>唐太宗（伸手）：Honey～</p>
<p>（画面定格。唐太宗面部抽搐，凄凄惨惨戚戚，内心独白）</p>
<p>（音乐停）</p>
<p>观音姐姐：随他们去吧。糖糖，目前你还有更重要的事情去做。我这次来就是想告诉你，什么是branch业务的真谛。</p>
<p>唐太宗（回过神来）：真谛？</p>
<p>观音姐姐：很多事情不是你表面上看到的那样。你以为遍布我大唐的沙县小吃仅仅是小吃么？</p>
<p>唐太宗：啊？这和branch有毛关系啊？</p>
<p>观音姐姐：打个比方嘛。你以为我们Juniper是卖硬件的么？你以为将 branch 产品做出来的西天神佛是吃素的么？其实我们是卖服务的。硬件软件不多出点问题，服务怎能做得起来？俗话说的好，一日卖硬件，终身卖服务。这，才是为商之道。</p>
<p>唐太宗：虽然不明白你在说什么，但感觉好厉害的样子。</p>
<p>观音姐姐：我想派你去西天取经。</p>
<p>唐太宗：取经？</p>
<p>观音姐姐：天竺班加罗尔寺的藏经阁里有大量 branch 知识，你组建一个取经团队，到天竺去学习，学好了branch知识就不怕customer issue了。</p>
<p>唐太宗：学习？</p>
<p>观音姐姐：对。贫僧先行告辞，替你们上下打点。</p>
<p>（说罢观音姐姐飘走）</p>
<p>唐太宗：喂，别走啊～天竺？我们没人懂梵文啊～</p>
<p>（众人除唐太宗外均下场）</p>
<p>（音乐 快乐女声）</p>
<audio src="/assets/files/mp3/1-3-xiangchang.mp3" controls="controls"></audio>

<p>旁白：就这样，唐太宗开始了艰苦卓绝的『西游记中人』海选，终于敲定了从超级女声十强赛中脱颖而出的史上最强大取经阵容：王玄奘，邵悟空，以及郭悟能，郭悟净两兄弟。这一天，唐太宗在Everest准备开all hands meeting，检阅取经部队。。。</p>
<h2>第二幕</h2>
<p>（播放运动员进行曲）</p>
<audio src="/assets/files/mp3/2-1-yundongyuan.mp3" controls="controls"></audio>

<p>（唐太宗在场地中央站着，旁边立一个牌子：长安，场地另一次立牌子：天竺）</p>
<p>（玄奘，孙悟空，白龙马，猪悟能，沙悟净列队上台）</p>
<p>玄奘：稍息，立正。向右看齐，向前看！</p>
<p>（玄奘小跑到太宗面前，行军礼）</p>
<p>玄奘：报告陛下，西天取经小分队集结完毕，请指示。</p>
<p>唐太宗（挥挥手）：同志们辛苦了！</p>
<p>玄奘等人：为branch服务！</p>
<p>唐太宗：玄奘，此去你等背负重大责任，branch 能否做好就看你们的了。</p>
<p>玄奘等人：Yes sir！</p>
<p>唐太宗：唉？你们的坐骑白龙马呢？</p>
<p>悟空：陛下，按照天庭规定，本周白马限行，只允许黑马上路。</p>
<p>唐太宗：哦，明白。你们的梵文练得怎样了？</p>
<p>悟净（出列）：前轱辘转后轱辘不转，前轱辘不转后轱辘转思密达（颔首）</p>
<p>唐太宗：（挥手）我大唐有你等高人，branch复兴指日可待！出发在即，大家还有什么问题？</p>
<p>悟空：此番西去，路途遥远，非一年半载不能归来，陛下可否多批些budget供我们旅途中team building？</p>
<p>唐太宗：我靠，这是出差，你当是带薪休假呢。最近手头紧，国库里就够你们两周的钱粮。</p>
<p>悟能：两周？此处离西天十万八千里，现在又是雾霾又是限行的，两周我们都走不出杜家坎啊陛下！</p>
<p>唐太宗：哈哈哈，你们out了。西域刚刚上供了一种灵鸡，叫灰机，骑上它，七八个时辰就到天竺。你们看～</p>
<p>众人：哦？</p>
<p>（Yalin举着灰机-Juniper Rocker-的牌子上场，众人一齐跟在灰机的后面，在场中绕圈子，唐太宗下）</p>
<h2>第三幕</h2>
<p>（灰机带着师徒四人飘过，绕场两圈到天竺，然后飘走）</p>
<p>（音乐 - 天竺少女）</p>
<audio src="/assets/files/mp3/3-1-tianzhu.mp3" controls="controls"></audio>

<p>（师徒四人开始跳印度舞）</p>
<p>（十秒左右，音乐声渐小）</p>
<p>悟能：师父，我们到天竺了～</p>
<p>玄奘：悟空，去打探一下，此处是何地？</p>
<p>悟空（抓耳挠腮，四处张望）：师父，此地正是班加罗尔寺。藏经阁应该就在附近，我们找人问问。</p>
<p>玄奘（大喜）：徒儿们咱们走。</p>
<p>（天竺城突然出现，操一口湖北普通话）</p>
<p>天竺城管：你们这是去哪儿？身份证，暂住证，结婚证，离婚证，独生子女证？没有？罚钱！1w 卢比！</p>
<p>郭悟净（跳出）：喂，大家都是道上的兄弟，给点面子。大哥以前混哪里？</p>
<p>天竺城管：老子洪兴的，来天竺前混铜锣湾，兄弟们都管我叫山鸡。</p>
<p>郭悟净：啊，洪兴啊（翘起大拇指）？小弟不才，混五道口多年，嘿嘿——前轱辘转后轱辘不转，前轱辘不转后轱辘转思密达（颔首）</p>
<p>天竺城管（大惊）：啊，五道口？你才是我大哥！对不起啊，大哥，你们请～请～（低三下四）</p>
<p>（城管大叔做个请的动作，随即离开）</p>
<p>（众人原地做前进状）</p>
<p>（接引道人出场，操一口纯正东北话）</p>
<p>接引道人（举个接机的牌子走过来）：哎呀妈呀，可算等到你们了。俺在这噶哒都被烤秃噜了。你们是从大唐那噶哒来的么？看你们面相，俺寻思应该是来做PTO的吧？啊不，TOI。</p>
<p>（牌子上写：Flight: N.G. 350，Country: Tang，Name: Derek Wang Xuanzang）</p>
<p>悟净：前轱辘转后轱辘不转，前轱辘不转后轱辘转思密达（颔首）</p>
<p>接引道人（转身欲走）：妈呀，接错淫了，丢淫丢大发了～</p>
<p>玄奘：大师莫走。我这徒弟最近解bug解岔脑子了，不太会说人话。弟子正是从东土大唐而来，来班加罗尔求亲的王玄奘，啊，不对，求经，求经。</p>
<p>接引道人：早说呀，你说你们一群大老爷们磨磨唧唧，跟老娘们似的。Let&#39;s go!</p>
<audio src="/assets/files/mp3/3-1-tianzhu.mp3" controls="controls"></audio>

<p>（菩提老祖上台，操一口湖南普通话）</p>
<p>玄奘：弟子玄奘一行五人，参见我佛。</p>
<p>（接引道人飘走）</p>
<p>菩提老祖：佛祖PTO去了，这次由我菩提老祖全程接待，哈哈。</p>
<p>玄奘：善哉善哉～</p>
<p>菩提老祖：我这里有红咖喱，绿咖喱，黄咖喱，黑咖喱，你们想吃哪一种撒？哈哈。</p>
<p>玄奘：感谢祖师恩惠。branch issue太多，我大唐陛下茶饭不思，我等岂敢怠慢？先不谈吃，能否即刻带我们去藏经阁学习经书？</p>
<p>菩提老祖：妥妥的，你们等在这里，我去找找，哈哈。</p>
<p>（菩提老祖离开，众人面面相觑）</p>
<p>（Yaling和Hao上场，准备新闻联播）</p>
<p>悟能：师父你也是的，人家好意请你吃，你却回绝，这一路旅途奔波，老郭我肚子都抑郁了半天了。</p>
<p>悟空：郭师弟，要不我拔根毫毛，变个猪蹄给你补补？</p>
<p>悟能：你看我的口型，哥屋恩。猪蹄我有四只，每天都在舔，我要吃猴脑！</p>
<p>（众人正在玩闹，菩提祖师出现）</p>
<p>菩提祖师：经书找到了，你们请看！哈哈。</p>
<p>（Yalin和Li Hao托着电视框上场，准备。Yalin对口型，表情夸张；Li Hao做手语，神情严肃）</p>
<p>（新闻联播音乐声骤然响起，众人一惊，然后捧着下巴，瞪大眼睛，一脸神往）</p>
<audio src="/assets/files/mp3/3-2-cctv.mp3" controls="controls"></audio>

<p>悟净（新闻联播音乐快结束时）：我靠，前轱辘转思密达！</p>
<p>（众人张大了嘴，瞪大了眼，呆若木鸡）</p>
<p>（播放完毕后，声音停止，众人跌倒，菩提老祖上台，电视机撤）</p>
<p>菩提老祖：这仅仅是我们branch的xx文档的一部分，还有xxx的要不要听？哈哈。</p>
<p>（众人爬起）</p>
<p>玄奘等人（含着热泪，做个长揖）：多谢老祖，人家培训要钱，你们培训要命！且罢切罢，我们回去慢慢学习！悟能，上优盘！</p>
<p>（悟能把猪鼻子凑过去，菩提老祖拿出U盘，插入猪鼻子）</p>
<p>（视频拷贝中，视频拷贝完成！西天取经成功！的牌子飘过）</p>
<p>旁白：就这样，师徒四人终于顺利取到真经。回到大唐后，众人努力学习 branch 视频，开始跟各种种奇葩customer issue斗争。</p>
<p>（音乐霍元甲）</p>
<audio src="/assets/files/mp3/3-3-hyj1.mp3" controls="controls"></audio>

<p>（P2 issue上，一副有恃无恐的样子，唐僧念经，P2 issue头昏欲裂，倒下台去）</p>
<p>（P1 issue上，双手捶胸，秀肌肉，唐僧念经，毫无效果，众人一齐上，将issue赶跑，下场）</p>
<p>（音乐停）</p>
<p>旁白：三个月后，整个branch终于清静了，再也没有customer issue来骚扰。唐太宗带着武媚娘天天哼着小芳，喝着摩卡，在5楼打着台球，小日子过得相当地思密达。</p>
<p>（全剧完）</p>
]]></description>
            <link>http://tchen.me/posts/2014-01-14-my-annual-festival-script.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-01-14-my-annual-festival-script.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Tue, 14 Jan 2014 15:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Sunnyvale trip - 所见，所聊，所感]]></title>
            <description><![CDATA[<p>又是一个一周的短差，来去匆匆。依旧是白天各种开会，各种social，跟所有认识的人打招呼唠家常，跟不认识的但有来往（或者即将来往的）熟悉并打交道。本文没什么主题，就是所见所聊所感，totally personal。</p>
<!--
走之前列了好几个清单，分别是：

* 这次过去老板布置的任务（3个）
* Peer布置的任务（2个）
* 自己想到的任务（4个）
* 要打个招呼，唠唠家常的人（29人）
* 要深入了解和认识的人（5人）
* 要一同工作，寻求帮助的人（6人）

到离开的时候，除了有6个要Say hello的人没见着外，其他都完成得不错。工作上的事情当然不便在博客里透露，但和形形色色的人接触得到的感受却值得说说。
-->

<!--more-->

<p>（一）</p>
<p>先说我老板G君。G君有10个US Patents，10年engineering工作经验，13年management工作经验。</p>
<p>他第一次来CNRD时，我和他曾聊了二十多分钟。他一直作为一个旁听者静静地听我的自我介绍，偶尔会插两句话让我就经历过的一些事提提看法，比如说scrum，python。那时对他印象还不算深。</p>
<p>他第二次来CNRD时，有次我负责领他去餐馆吃饭。他拎着皮箱去的，皮箱里有一本厚厚的书，撑着外侧的兜子合不上。书是上千页的那种大砖头。我问他是什么书？他说是 <strong>SRX cookbook</strong>，他想尽快熟悉我们的产品，就在amazon买了本带在飞机上看。我对他顿时肃然起敬。在途客圈，我喜欢招爱读书的工程师，面试时也会和对方聊聊最近读过什么书。我喜欢爱读书的人，因为读书要么能更新你的思想，要么能更新你的技能。愿意读书，便不会墨守成规。</p>
<p>其他深入接触到他的人，都认为他很注重细节，提问一针见血，并且雷厉风行。这次在Sunnyvale和他前后开了6次会，这个评价我认为恰到好处。一般而言，一个做了十几年管理者，已经离技术有相当的距离，但他似乎不同，还在不断跟踪和了解技术，并琢磨怎么能将这些技术用在daily work上。这也是为什么他总能提出一针见血的问题。具体细节我不便多说，这几次开会我被激发了出了不少新的想法和思路。</p>
<p>说几句题外话。我一直觉得在R&amp;D中，Manager只负责people management和resource planning是行不通的。Manager最好要有扎实的工程师背景，要有很强的技术敏感性，这样才更容易做正确的判断。并且越往上走（直到Engineering VP）这种能力应该越强才对。如果说Manager是县官或师团长，TL充其量也就是师爷或者参谋，出谋划策可以，最终拍板，make decision还是得Manager。很多东西可以delegate，但重要的decision making不能。因为Manager要为手下的弟兄们负责，要为team的成败负责。一个不那么懂技术的Manager很容易被TL蒙蔽（有意或无意），做出并非全局最优的决定。久而久之，能说会道者上去，勤奋木讷者下去，organization渐渐从治世转为乱局（和帝国的兴衰何其相似）。</p>
<p>自从做了途客圈后，我就养成个毛病，总把自己放在某个位置做沙盘推演。我常常会想，如果我是xxx（比如G君），我会怎么做？我会如何make decision？我会如何去让整个organization更优化，更有战斗力和活力？当然，这些推演都是纸上谈兵，乱点鸳鸯谱。</p>
<p>G君还有个特点就是早出晚归。这周经常早上8点左右，晚上7点后都能见到他。他喜欢把会议放在早上9点（不管是和Sunnyvale team还是和CNRD team），这给很多同事整了个大难题：8点多正是堵车的时候，肿么办？</p>
<p>总之，G君值得期待。</p>
<p>（二）</p>
<p>再说说新来的DE K君。K君履历惊人 - Brown小本，Stanford研究生，然后SGI 4年（嘿嘿，Ex-SGIer），NetApp 9年，Zynga 4年（2009-2013)，有6个US patents。Zynga 07年创立，11年上市，所以我猜K君应该发了笔横财（忘记当面跟他验证了）。</p>
<p>第一次见他是在3楼。我跟几个CNRD的老熟人在Pantry聊天，这哥们很唐突地加入并接管了话题，然后讲了个『冷』笑话。我没太听懂，但其他人都哈哈大笑（唉，no slangs，请讲英语普通话）。当时我以为他是 XX team里某个工程师，后来 XX 说他就是刚来的DE。充满活力，爱开玩笑的geek，这就是我对他的第一印象。</p>
<p>第二次见他是莫名其妙被 Program management team 拉进了一个会议。这会议是K君主导。K君一到，就把大家从椅子上拉起来，开站立会议。我顿时觉得这哥们有意思了。我喜欢站立会议，它让大家能集中精神在要讨论的事情上，而不是坐在那里一只耳朵听着，貌合神离。他把要做的事情分成sprint去manage，估计这是在Zynga里养成的习惯。讨论结束后，他立刻在会上就明确action plan和deadline，而且他的deadline是以天为单位，而不是在J记惯常的单位：周。我能感觉得到会上的其他人感觉不那么舒服，至少不适应这种style。</p>
<p>第三次是周五下午去他office跟他聊天。跟他拉家常你绝对不会感到沉闷，他话多，激情四射，玩笑一个接一个。聊到正题后，他展示给我他正在梳理的J记内部的整个process chain。这让我眼前一亮，我怎么从来没想过这么梳理一下呢？我甚至都没想过梳理一下途客圈的process chain呢？</p>
<p>总之，K君是个很好相处的人。我对他在Zynga的这段履历还是很看好（2009年Zynga应该还是startup的氛围吧）—— 我觉得在大公司里混日子，混title比较容易，但在startup里就困难多了。不过他的风格是否适合J记（agile v.s. waterfall），或者说他多大程度上能影响J记（得看他被授予什么样的权责），就看造化了。</p>
<p>（三）</p>
<p>这次出差，KP君跟我一道。我对KP君的第一印象很一般，觉得他是个典型的那种自我感觉良好的蹦蹦跳跳的美国人。虽然上过几次他的课，但我对他并没有太深入的了解。</p>
<p>这次出差我们share一辆车。每天晚上我都工作到比较晚，所以他都把车钥匙留给我，自己步行回酒店。</p>
<p>他这次出差的目的是给这边的team做business training。但是，每天结束时他都显得很沮丧。有次他很郁闷地跟我抱怨事情进行地不那么顺利，因为这边的中国工程师，尤其是dev，不怎么鸟他。我跟他说你得摆正心态。原因大概有这么三个，第一，在CNRD，你是个外国人，大家会对你格外客气，但在这里，大家都是美国人，你不再特别。第二，CNRD平均年龄低一些，对这种training接受程度自然高一些。第三，CNRD你已经有些影响力了，这边却还零基础。</p>
<p>说着我突然想起了06年我来这里出差，参加一个training的场景。那个training是 &quot;The Art of Presentation&quot;，training team花钱请的外边的trainer来做的。大家自我介绍后，我惊讶的发现十几个人中，R&amp;D的人聊聊无几，Dev貌似只有我一人。要知道，这个site，R&amp;D的人应该是占多数的。结果来的尽是PLM，PM，IT，blabla。你不能责备dev不求上进，因为在他们看来，写段代码要比这个有意思得多，这是性格使然。在途客圈里，诸多外事我也是能不参加就不参加，要不是跟投资人pitch我必须参加，我估计也会躲在一旁和工程师在一起快活地写代码（这性格对工程师来说没什么大碍，但对CTO的角色就是硬伤）。所以对一个Trainer来说，清楚地把握audience的性格特点也很重要。CNRD适用的，US未必；大多数人适用的，Dev也未必（dev就是这么个奇怪的群体）。就是这么个浅显的道理。</p>
<p>我与人接触的一个大原则是：不管跟什么人打交道，不管对方有什么缺点，你总能找到他的优点（有意思的是，我们所认为别人的缺点，往往是和自己不一样的地方，就像研发看sales觉得太吵，sales看研发觉得无趣）。KP君估计不太能和dev玩到一块，因为他sales的性格。但深入接触后，他其实是个很不错的人，为他人着想，乐于帮忙等等。周五早上我要给这边的dev和TL做一个presentation，我们8点到办公室后，我找了个会议室请他帮忙帮我看看我present的如何，他欣然同意并提出了很多很有价值的意见。</p>
<p>（四）</p>
<p>周五晚上，我约老上司F君一起聊聊创业。F君心态很好，认为创业『谋事在人，成事在天』，尽最大的努力后，成与不成并不那么重要了。和懵懵懂懂走上创业之路的我相比，他要成熟得多。他深谙『兵马未动，粮草先行』之道，在R&amp;D刚刚起步阶段就开始actively engage customers，天天跑市场。这很好。dev出身的创业者，比如我，marketing/sales的感觉很差，往往光顾研发，忽略产品最终要交到客户手上。</p>
<p>我跟他说，我四十岁前还会不断创业，直到成功，或者时间证明我这号人不管怎么努力，就是不适合创业。说到这里，我突然想起一个问题：F君多大了？我印象中他已经四十好几，但不能确定。</p>
<p>他告诉我他是六二年的。我有点吃惊。在这个年龄，以他的地位，财富，他完全可以退休，每天出海钓钓鱼享受人生。但是，他还在这里追寻创业的理想。这让我十分敬佩。我想，我应该把我的deadline放在五十岁，那时候我依然需要拥有这份闯劲。</p>
<p>F君跟我分享了一个故事。在他的职业早年，他的一个朋友，毕业于清华的很厉害的工程师，介绍他去E公司。因为没有past experience，他最终没能去成E，却成就了在NetScreen一段难得的startup经历。因为大环境的原因和执行层的问题，E不断走下坡路，最终那个朋友离开并加入Cisco。在最近的一次layoff中，他不幸中枪，现在还在艰难地寻找工作 —— 可竞争是如此激烈，他尽管曾经是个非常smart的工程师（现在如何不得而知），可年逾半百，和二三十岁同样smart，又精力充沛的工程师相比，已不具优势。F君说：我们做事要顺势而为，台风吹过的时候猪都能飞起来。炒股如此，工作如此，做startup亦如此。Totally agree。</p>
<p>（五）</p>
<p>这次来Sunnyvale，看到种种问题，我都痛心疾首。但这似乎是大公司的通病。有几个CNRD的工程师在外面转了一圈又回来，发现其实各个公司，EMC，Symantic，Microsoft，bla bla bla都差不多。一个公司就像一个人，从出生（startup），到成人（有些可能中途夭折），到壮年，到老年，到死亡。大家都在提基业长青，可真正存活百年以上屹立不倒的公司有几个呢？这似乎是个颠扑不破的自然规律。想想二十四史，里面发生的事情何其相似！不过话又说回来，如果大公司一直保持startup的状态，没有各种政治，产品不是政治妥协的产物，没有各种奇葩process，没有各种制肘，也不犯那些比较愚蠢的错误，那startup的生存空间何在？冥冥中自有天意，也许唯有这样，经济社会才能正常循环，生生不息。</p>
]]></description>
            <link>http://tchen.me/posts/2014-01-11-sunnyvale-trip.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-01-11-sunnyvale-trip.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Sun, 12 Jan 2014 06:40:00 GMT</pubDate>
        </item>
    </channel>
</rss>