<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[觅珠人 | Tyr Chen的个人博客 | 创意 | 心得 | 经验]]></title>
        <description><![CDATA[本博客提供我个人的想法，创意，经验，心得。你不必认同博主观点。]]></description>
        <link>http://tchen.me</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Sun, 12 Jan 2014 19:31:10 GMT</lastBuildDate>
        <atom:link href="http://tchen.me/rss.xml" rel="self" type="application/rss+xml"/>
        <author><![CDATA[Tyr Chen]]></author>
        <pubDate>Sun, 12 Jan 2014 19:30:26 GMT</pubDate>
        <item>
            <title><![CDATA[Sunnyvale trip - 所见，所聊，所感]]></title>
            <description><![CDATA[<p>又是一个一周的短差，来去匆匆。依旧是白天各种开会，各种social，跟所有认识的人打招呼唠家常，跟不认识的但有来往（或者即将来往的）熟悉并打交道。本文没什么主题，就是所见所聊所感，totally personal。</p>
<!--
走之前列了好几个清单，分别是：

* 这次过去老板布置的任务（3个）
* Peer布置的任务（2个）
* 自己想到的任务（4个）
* 要打个招呼，唠唠家常的人（29人）
* 要深入了解和认识的人（5人）
* 要一同工作，寻求帮助的人（6人）

到离开的时候，除了有6个要Say hello的人没见着外，其他都完成得不错。工作上的事情当然不便在博客里透露，但和形形色色的人接触得到的感受却值得说说。
-->

<!--more-->

<p>（一）</p>
<p>先说我老板G君。G君有10个US Patents，10年engineering工作经验，13年management工作经验。</p>
<p>他第一次来CNRD时，我和他曾聊了二十多分钟。他一直作为一个旁听者静静地听我的自我介绍，偶尔会插两句话让我就经历过的一些事提提看法，比如说scrum，python。那时对他印象还不算深。</p>
<p>他第二次来CNRD时，有次我负责领他去餐馆吃饭。他拎着皮箱去的，皮箱里有一本厚厚的书，撑着外侧的兜子合不上。书是上千页的那种大砖头。我问他是什么书？他说是 <strong>SRX cookbook</strong>，他想尽快熟悉我们的产品，就在amazon买了本带在飞机上看。我对他顿时肃然起敬。在途客圈，我喜欢招爱读书的工程师，面试时也会和对方聊聊最近读过什么书。我喜欢爱读书的人，因为读书要么能更新你的思想，要么能更新你的技能。愿意读书，便不会墨守成规。</p>
<p>其他深入接触到他的人，都认为他很注重细节，提问一针见血，并且雷厉风行。这次在Sunnyvale和他前后开了6次会，这个评价我认为恰到好处。一般而言，一个做了十几年管理者，已经离技术有相当的距离，但他似乎不同，还在不断跟踪和了解技术，并琢磨怎么能将这些技术用在daily work上。这也是为什么他总能提出一针见血的问题。具体细节我不便多说，这几次开会我被激发了出了不少新的想法和思路。</p>
<p>说几句题外话。我一直觉得在R&amp;D中，Manager只负责people management和resource planning是行不通的。Manager最好要有扎实的工程师背景，要有很强的技术敏感性，这样才更容易做正确的判断。并且越往上走（直到Engineering VP）这种能力应该越强才对。如果说Manager是县官或师团长，TL充其量也就是师爷或者参谋，出谋划策可以，最终拍板，make decision还是得Manager。很多东西可以delegate，但重要的decision making不能。因为Manager要为手下的弟兄们负责，要为team的成败负责。一个不那么懂技术的Manager很容易被TL蒙蔽（有意或无意），做出并非全局最优的决定。久而久之，能说会道者上去，勤奋木讷者下去，organization渐渐从治世转为乱局（和帝国的兴衰何其相似）。</p>
<p>自从做了途客圈后，我就养成个毛病，总把自己放在某个位置做沙盘推演。我常常会想，如果我是xxx（比如G君），我会怎么做？我会如何make decision？我会如何去让整个organization更优化，更有战斗力和活力？当然，这些推演都是纸上谈兵，乱点鸳鸯谱。</p>
<p>G君还有个特点就是早出晚归。这周经常早上8点左右，晚上7点后都能见到他。他喜欢把会议放在早上9点（不管是和Sunnyvale team还是和CNRD team），这给很多同事整了个大难题：8点多正是堵车的时候，肿么办？</p>
<p>总之，G君值得期待。</p>
<p>（二）</p>
<p>再说说新来的DE K君。K君履历惊人 - Brown小本，Stanford研究生，然后SGI 4年（嘿嘿，Ex-SGIer），NetApp 9年，Zynga 4年（2009-2013)，有6个US patents。Zynga 07年创立，11年上市，所以我猜K君应该发了笔横财（忘记当面跟他验证了）。</p>
<p>第一次见他是在3楼。我跟几个CNRD的老熟人在Pantry聊天，这哥们很唐突地加入并接管了话题，然后讲了个『冷』笑话。我没太听懂，但其他人都哈哈大笑（唉，no slangs，请讲英语普通话）。当时我以为他是 XX team里某个工程师，后来 XX 说他就是刚来的DE。充满活力，爱开玩笑的geek，这就是我对他的第一印象。</p>
<p>第二次见他是莫名其妙被 Program management team 拉进了一个会议。这会议是K君主导。K君一到，就把大家从椅子上拉起来，开站立会议。我顿时觉得这哥们有意思了。我喜欢站立会议，它让大家能集中精神在要讨论的事情上，而不是坐在那里一只耳朵听着，貌合神离。他把要做的事情分成sprint去manage，估计这是在Zynga里养成的习惯。讨论结束后，他立刻在会上就明确action plan和deadline，而且他的deadline是以天为单位，而不是在J记惯常的单位：周。我能感觉得到会上的其他人感觉不那么舒服，至少不适应这种style。</p>
<p>第三次是周五下午去他office跟他聊天。跟他拉家常你绝对不会感到沉闷，他话多，激情四射，玩笑一个接一个。聊到正题后，他展示给我他正在梳理的J记内部的整个process chain。这让我眼前一亮，我怎么从来没想过这么梳理一下呢？我甚至都没想过梳理一下途客圈的process chain呢？</p>
<p>总之，K君是个很好相处的人。我对他在Zynga的这段履历还是很看好（2009年Zynga应该还是startup的氛围吧）—— 我觉得在大公司里混日子，混title比较容易，但在startup里就困难多了。不过他的风格是否适合J记（agile v.s. waterfall），或者说他多大程度上能影响J记（得看他被授予什么样的权责），就看造化了。</p>
<p>（三）</p>
<p>这次出差，KP君跟我一道。我对KP君的第一印象很一般，觉得他是个典型的那种自我感觉良好的蹦蹦跳跳的美国人。虽然上过几次他的课，但我对他并没有太深入的了解。</p>
<p>这次出差我们share一辆车。每天晚上我都工作到比较晚，所以他都把车钥匙留给我，自己步行回酒店。</p>
<p>他这次出差的目的是给这边的team做business training。但是，每天结束时他都显得很沮丧。有次他很郁闷地跟我抱怨事情进行地不那么顺利，因为这边的中国工程师，尤其是dev，不怎么鸟他。我跟他说你得摆正心态。原因大概有这么三个，第一，在CNRD，你是个外国人，大家会对你格外客气，但在这里，大家都是美国人，你不再特别。第二，CNRD平均年龄低一些，对这种training接受程度自然高一些。第三，CNRD你已经有些影响力了，这边却还零基础。</p>
<p>说着我突然想起了06年我来这里出差，参加一个training的场景。那个training是 &quot;The Art of Presentation&quot;，training team花钱请的外边的trainer来做的。大家自我介绍后，我惊讶的发现十几个人中，R&amp;D的人聊聊无几，Dev貌似只有我一人。要知道，这个site，R&amp;D的人应该是占多数的。结果来的尽是PLM，PM，IT，blabla。你不能责备dev不求上进，因为在他们看来，写段代码要比这个有意思得多，这是性格使然。在途客圈里，诸多外事我也是能不参加就不参加，要不是跟投资人pitch我必须参加，我估计也会躲在一旁和工程师在一起快活地写代码（这性格对工程师来说没什么大碍，但对CTO的角色就是硬伤）。所以对一个Trainer来说，清楚地把握audience的性格特点也很重要。CNRD适用的，US未必；大多数人适用的，Dev也未必（dev就是这么个奇怪的群体）。就是这么个浅显的道理。</p>
<p>我与人接触的一个大原则是：不管跟什么人打交道，不管对方有什么缺点，你总能找到他的优点（有意思的是，我们所认为别人的缺点，往往是和自己不一样的地方，就像研发看sales觉得太吵，sales看研发觉得无趣）。KP君估计不太能和dev玩到一块，因为他sales的性格。但深入接触后，他其实是个很不错的人，为他人着想，乐于帮忙等等。周五早上我要给这边的dev和TL做一个presentation，我们8点到办公室后，我找了个会议室请他帮忙帮我看看我present的如何，他欣然同意并提出了很多很有价值的意见。</p>
<p>（四）</p>
<p>周五晚上，我约老上司F君一起聊聊创业。F君心态很好，认为创业『谋事在人，成事在天』，尽最大的努力后，成与不成并不那么重要了。和懵懵懂懂走上创业之路的我相比，他要成熟得多。他深谙『兵马未动，粮草先行』之道，在R&amp;D刚刚起步阶段就开始actively engage customers，天天跑市场。这很好。dev出身的创业者，比如我，marketing/sales的感觉很差，往往光顾研发，忽略产品最终要交到客户手上。</p>
<p>我跟他说，我四十岁前还会不断创业，直到成功，或者时间证明我这号人不管怎么努力，就是不适合创业。说到这里，我突然想起一个问题：F君多大了？我印象中他已经四十好几，但不能确定。</p>
<p>他告诉我他是六二年的。我有点吃惊。在这个年龄，以他的地位，财富，他完全可以退休，每天出海钓钓鱼享受人生。但是，他还在这里追寻创业的理想。这让我十分敬佩。我想，我应该把我的deadline放在五十岁，那时候我依然需要拥有这份闯劲。</p>
<p>F君跟我分享了一个故事。在他的职业早年，他的一个朋友，毕业于清华的很厉害的工程师，介绍他去E公司。因为没有past experience，他最终没能去成E，却成就了在NetScreen一段难得的startup经历。因为大环境的原因和执行层的问题，E不断走下坡路，最终那个朋友离开并加入Cisco。在最近的一次layoff中，他不幸中枪，现在还在艰难地寻找工作 —— 可竞争是如此激烈，他尽管曾经是个非常smart的工程师（现在如何不得而知），可年逾半百，和二三十岁同样smart，又精力充沛的工程师相比，已不具优势。F君说：我们做事要顺势而为，台风吹过的时候猪都能飞起来。炒股如此，工作如此，做startup亦如此。Totally agree。</p>
<p>（五）</p>
<p>这次来Sunnyvale，看到种种问题，我都痛心疾首。但这似乎是大公司的通病。有几个CNRD的工程师在外面转了一圈又回来，发现其实各个公司，EMC，Symantic，Microsoft，bla bla bla都差不多。一个公司就像一个人，从出生（startup），到成人（有些可能中途夭折），到壮年，到老年，到死亡。大家都在提基业长青，可真正存活百年以上屹立不倒的公司有几个呢？这似乎是个颠扑不破的自然规律。想想二十四史，里面发生的事情何其相似！不过话又说回来，如果大公司一直保持startup的状态，没有各种政治，没有各种奇葩process，没有各种制肘，也不犯那些比较愚蠢的错误，那startup的生存空间何在？冥冥中自有天意，也许唯有这样，经济社会才能正常循环，生生不息。</p>
]]></description>
            <link>http://tchen.me/posts/2014-01-11-sunnyvale-trip.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2014-01-11-sunnyvale-trip.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Sun, 12 Jan 2014 06:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[盘点我的2013]]></title>
            <description><![CDATA[<p>提笔（确切地说，敲下键盘）开始盘点我的2013时，我感觉 <a href="http://tchen.me/posts/2012-12-28-retrospect-of-the-year-2012.html">回顾我的2012</a> 和 <a href="http://tchen.me/posts/2012-12-29-2013-things-to-do.html">展望2013</a> 似乎就在眼前。都说岁月催人，这哪是催，这是赶。无论心智是否更成熟，知识经验是否更丰富，过了一年，就老了一岁，去年的那支影子也渐行渐远。多愁善感并不单是文人的专利，年过三十后，我也染上了这臭毛病。太白说『白发三千丈，缘愁似个长。不知明镜里，何处得秋香！』（好吧，是秋霜 ^_^），本不大懂，但经历了2013这奇特，曲折，煎熬，仿佛过去的十年职场都被挤压收缩的一年后，我很能理解他那种年过半百，壮志未酬，人已衰老的那种痛苦。</p>
<!--more-->

<p>这一年经历了太多太多。</p>
<h2>大事记</h2>
<ul>
<li>1月：创业公司走到十字路口，向左走寻不到『生机』，向右转看不到『光明』。两权相害取其轻，不得已放弃『光明』选择『生机』，忍痛送别一个又一个战友。月底站完最后一班岗，正式自我放逐。</li>
<li>2月：拒绝了不少创业团队的邀请后，整天泡在国图看书，写书（创业回忆录『途客们的旅行梦』），同时思考未来，寻求出国工作的机会，但四处碰壁。离开的战友开始一个个找到工作，看在眼里，暖在心头。</li>
<li>3月：两年来在收入上对自己的吝啬让家里的经济状况开始触及红线，考虑到孩子的奶粉钱，无法留出哪怕一个 gap month。就业之紧迫感，为人父之责任感，应『劫』而生。在老领导的奔走帮忙下，虽应聘PLM无疾而终，但阴差阳错被AK激励重回旧地，重操旧业。一切尘埃落定后，当晚订机票酒店，第二天带着四个月大的小宝飞海南度假。</li>
<li>4月：两年前的3月31日离开，这月8日回归。打开邮箱，看到两年前的goodbye邮件的各种回复，有种时空错乱的感觉。人还是那群人，事还是那些事，仿佛我从未离开，仅仅是休了一周的PTO。那逝去的两年时光，就像一滴水汇入大海，瞬间消散地无影无踪。</li>
<li>5月：为了给小宝做视频，看了几个imovie的教程，拿team building和CNRD spring event练手，阴差阳错地被视为视频编辑能手。所谓劳者多能，我的视频编辑能力就这样一步步成长起来。此外，公司要求招聘要做code exam，于是我便花了个周末（及后续的n个晚上），做了 <a href="https://github.com/tyrchen/vint">vint</a> &amp; <a href="https://github.com/tyrchen/cerf">cerf</a> 这对鸳鸯来提供code exam。自此我个人的开源项目都使用计算机科学家的名字来命名，如：church，kahn，karp，etc.</li>
<li>6月：感觉Cliff track PR很辛苦，team用excel汇报PR状态也很痛苦，做了个爬虫，及其衍生出的网站，来减轻这一负担。同月得到机会去美国出差参加global TL meeting。Staybridge没有变化，North Mathilda似乎还是老样子，不过公司搬到了新楼，会议室门口都挂着ipad，有种土豪的感觉。</li>
<li>7月：迷恋上erlang。飞内蒙给老婆的爷爷过九十大寿。写下长文 <a href="http://tchen.me/posts/2013-07-27-the-remains-of-the-day.html">长日无痕</a>，平日门可罗雀的博客变得宾客盈门。</li>
<li>8月：人生中第一次恐怕也是最后一次因公出差去印度。由于种种原因，停止更新正在写的『途客们的旅行梦』。已写的很多内容也一直未能对外开放。也许明年下半年，这些文档才能逐渐解密。</li>
<li>9月：在茫茫bug中迷茫与彷徨。创业圈离我渐行渐远。更新了 <a href="https://github.com/tyrchen/teamspark">teamspark</a>，让其终于赶上 <a href="http://meteor.com">meteor</a> 0.6.x 的脚步。</li>
<li>10月：和美国一个team吵得不可开交。人生中还从未因工作的事如此愤怒。</li>
<li>11月：小宝满周岁，越南芽庄庆生。度假前后的三周里我每周完成一个feature，找到些成就感，也一扫十月的阴霾。</li>
<li>12月：出乎意料地在reorg中换了老板。接下来的至少一个季度，我将不得不与彼得定律『在一个等级制度中，每个职工趋向于上升到他所不能胜任的地位』抗争，来证明自己还未上升到不能胜任的地位。因为工作的需要，学习golang，一股脑写下了千余行代码，演练各种语言特性。</li>
</ul>
<h2>数字来说话</h2>
<h3>博客和文章</h3>
<p>对比2012年末做的2013展望，除了涉及的计算机书籍基本没读外，其他都做得还可以。博客当然没达到每周更新的频率，但也在抽风似地螺旋前进。</p>
<table>
<thead>
<tr>
<th align="center">Month</th>
<th align="center">Posts</th>
<th align="center">Published</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Jan</td>
<td align="center">7</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">Feb</td>
<td align="center">6</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">Mar</td>
<td align="center">4</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">Apr</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">May</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">Jun</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">Jul</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">Aug</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">Sep</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">Oct</td>
<td align="center">4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">Nov</td>
<td align="center">9</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">Dec</td>
<td align="center">4*</td>
<td align="center">4*</td>
</tr>
<tr>
<td align="center">Total</td>
<td align="center">45</td>
<td align="center">35</td>
</tr>
</tbody>
</table>
<p>实际发表数在每周 0.67 的水平，2014年争取达到 1。此外在 <a href="http://medium.com">Medium</a> 撰写五篇文章，发表两篇：<a href="https://medium.com/i-m-h-o/231d7499a75">Programmer&#39;s Dilemma</a> 和 <a href="https://medium.com/this-happened-to-me/8b2607eed960">Having a harse boss</a>。</p>
<table>
<thead>
<tr>
<th align="left">Title</th>
<th align="center">Views</th>
<th align="center">Reads</th>
<th align="center">Recs</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Programmer&#39;s dilemma</td>
<td align="center">54.1K</td>
<td align="center">45.2K</td>
<td align="center">123</td>
</tr>
<tr>
<td align="left">Having a Harsh boss</td>
<td align="center">911</td>
<td align="center">672</td>
<td align="center">6</td>
</tr>
</tbody>
</table>
<p>两者悬殊巨大，原因在于 [P] 被读者推到了 <a href="https://news.ycombinator.com/item?id=6221117">hacker news</a> 上，并引发激烈讨论。另外，此文更容易引发争议，而争议引发激辩，是眼球的重要来源。</p>
<h2>项目及代码</h2>
<p>2013新创建了不少项目，完成的项目或者说基本功能可用的大致如下：</p>
<table>
<thead>
<tr>
<th align="right">Projects</th>
<th align="right">Commits</th>
<th align="right">LOC</th>
<th align="center">Lang</th>
<th align="left">Intro</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">Vint</td>
<td align="right">22</td>
<td align="right">707</td>
<td align="center">python</td>
<td align="left">exam client</td>
</tr>
<tr>
<td align="right">Cerf</td>
<td align="right">54</td>
<td align="right">26534</td>
<td align="center">python</td>
<td align="left">exam server</td>
</tr>
<tr>
<td align="right">Church</td>
<td align="right">40</td>
<td align="right">24218</td>
<td align="center">python</td>
<td align="left">team bug tracking system</td>
</tr>
<tr>
<td align="right">Gnats</td>
<td align="right">19</td>
<td align="right">350</td>
<td align="center">python</td>
<td align="left">gnats crawler for church</td>
</tr>
<tr>
<td align="right">jd</td>
<td align="right">17</td>
<td align="right">394</td>
<td align="center">python</td>
<td align="left">company directory crawler for church</td>
</tr>
<tr>
<td align="right">kahn</td>
<td align="right">39</td>
<td align="right">421</td>
<td align="center">nodejs</td>
<td align="left">company directory and gnats api for church</td>
</tr>
<tr>
<td align="right">karp</td>
<td align="right">12</td>
<td align="right">6840</td>
<td align="center">python</td>
<td align="left">a set of tools for internal use</td>
</tr>
<tr>
<td align="right">matrix</td>
<td align="right">4</td>
<td align="right">515</td>
<td align="center">python</td>
<td align="left">a hackathon project for downloading internal resources</td>
</tr>
<tr>
<td align="right">tracker</td>
<td align="right">31</td>
<td align="right">33781</td>
<td align="center">python</td>
<td align="left">a hackathon project for easing management tracking problems</td>
</tr>
<tr>
<td align="right">calcapp</td>
<td align="right">45</td>
<td align="right">16540</td>
<td align="center">golang</td>
<td align="left">a breakable project for learning golang</td>
</tr>
</tbody>
</table>
<p>注意: </p>
<p>[1] 获取git diff:</p>
<pre><code>$ git log --author=&quot;YOUR NAME&quot; --pretty=tformat: --numstat | gawk &#39;{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf &quot;added lines: %s removed lines : %s total lines: %s\n&quot;,add,subs,loc }&#39;</code></pre>
<p>这条命令需要gawk，如果你的系统中没有，可以使用 <code>apt-get</code> (ubuntu) or <code>brew</code> (osx) 来安装.</p>
<p>[2] 获取git commits数量:</p>
<pre><code>$ git shortlog --numbered --summary</code></pre>
<p>[3] 代码行数不太准确，有几个web项目偏大。这是因为把第三方的javascript也包含进去了。所以那些超过万行代码的，把前边的一位数去掉就差不多。</p>
<h2>个人奥斯卡颁奖</h2>
<p>以下各大奖项都和我有关，和您无关。我评我的奖，自娱我的乐。</p>
<h3>最刻骨铭心</h3>
<p>没有任何悬念，最刻骨铭心当属我亲手裁去一半的team，并随后离开途客圈。个中滋味，外人是体会不到的。</p>
<p>本想将当时我发的邮件和日记在此公开，但考虑到保密协议，一年后再补吧（如果我还记得的话）。</p>
<h3>最深刻教训</h3>
<p>全年我领悟了很多教训，包括但不限于：</p>
<ul>
<li>北美找工作。如果想申请美国的工作机会，在前一年11月就要动手。近些年H1B基本4月初就被抢光，倒推下来能为你申请H1B的公司，他们内部可能1-2月就已经对H1B申请freeze了，所以早动手没坏处。</li>
<li>创业投融资。（见下）</li>
<li>工作生活的平衡。去年末小宝降临（源于去年初的意外）打破了我工作（创业）与生活的平衡。每周80小时的工作必然引发家庭中的诸多矛盾，这种状态是不可持续的。工作（创业）不是一个人的事，它与家庭息息相关。</li>
<li>...</li>
</ul>
<p>入围教训：创业投融资，工作生活的平衡</p>
<p>获奖教训：创业投融资</p>
<p>在创业投融资方面，刻骨铭心的教训是：</p>
<ol>
<li>如果你投入自有资金创业，在找到 product/market fit 前不要着急融资。对我和我的创业伙伴而言，50万人民币的自有资金只能给我们差不多半年的试错机会。我们要么在挣扎中找到收入来源，建立可持续的商业模式，要么破产清算。前者自不必说，后者能让我们更早更快地失败，最小化时间成本。而在没有做到 product/market fit 前的盲目融资，会让一切变得不再紧迫，大家的专注力下降（因为各种可能性，各种方向增多了），有种温水煮青蛙的感觉。</li>
<li>如果在创业之初有了产品后就奔着融资去，则不要投入自有资金，即使投入，也将其作为公司的债务。相对于融资额而言，个人投入的资金对公司后期的发展而言杯水车薪，而往往对自己的家庭影响巨大。以我为例，25万元人民币的投资在50万美元前不值一提，但这确是我当时家庭可动用的全部积蓄。之前自己有没有投钱，在融资时对创始人的股份，地位影响基本为零，而融资时投资条款中100%会出现的各种优先条款会让你个人的投入变成毫无意义的数字。</li>
<li>目前还不便透露，也许一两年后可以解密。</li>
</ol>
<p>综合以上，更合理的创业公司设置是：使用尽可能少的钱作为公司的注册资本（最新的法规应该已取消最低注册资本的要求，所以理论上1元钱可以注册公司），然后将要投入的钱作为公司向个人的短期借贷，也就是债务。当公司运作良好，融资与否债务都可以收回；当公司破产清算，债权清偿后才轮到股权清偿。这样能最大程度保护创始人自己的利益，不至于一次创业失败，失血过多，短期内很难东山再起。</p>
<p>所以，创业投融资获得最深刻教训奖绝对众望所归。</p>
<h3>最意外事件</h3>
<p>入围事件：</p>
<ul>
<li>回到Juniper。</li>
<li>google I/O 抢到票，行程已定，却在可退票的最后关头因种种原因取消。</li>
<li>在芽庄度假即将结束前一天，小宝高烧至39度。</li>
<li>reorg后被更换老板。</li>
<li>08年和09年申请的两个invention disclosure在今年正式成为US patent。</li>
</ul>
<p>获奖事件：回到Juniper</p>
<p>回归需要勇气，也需要运气。</p>
<h3>最佳阅读</h3>
<p>2013读了不少书，哲学，小说和创业相关的书最多。我有意减少了技术书籍的阅读，一来 online document，<code>wikipedia</code> 和 <code>stackoverflow</code> 足以弥补 99% 的知识，二来我希望涉猎更广些。</p>
<p>入围书籍：『长日留痕』，『西游论心』+ 『西游记』，『Programming Erlang』，『中国哲学史大纲』</p>
<p>获奖书籍：『西游论心』+ 『西游记』</p>
<p>以前读过好几遍『西游记』，但最后一次读西游还在高中。看完吴闲云的『解读西游记』和『再探西游记』，总觉见解虽很新奇，但有诸多漏洞，戏谑成分大些。而我无意中拾起的『西游论心』，从儒释道，易医巫几方面解读西游，很有滋味。边读『西游论心』边对着原文一点点啃，劲道十足。不得不说，是『西游论心』促使我十几年后重拾『西游记』这部巨著。</p>
<h3>最佳个人项目</h3>
<p>入围项目：</p>
<ul>
<li>代码机考系统。<a href="https://github.com/tyrchen/vint">vint</a> &amp; <a href="https://github.com/tyrchen/cerf">cerf</a>.</li>
<li>matrix。一个提供类似git命令行的下载工具。用于下载jive space里的文档。（内部项目）。</li>
</ul>
<p>获奖项目：matrix</p>
<p>vint &amp; cerf 很可惜，虽然我们已经使用它管理和组织了上百次code interview，但它还不是理想中的产品。功能稍嫌薄弱，也不足够简单。所以这个奖项给了matrix —— 这个从产品构想到实现我仅仅花了两三个小时就完成的项目。它足够简单，非常实用。TTI（Time to implementation）趋近于零，而ROI（Return on investment）却非同小可（省了我很多时间）。</p>
<h3>最有价值文章</h3>
<p>入围文章：<a href="http://tchen.me/posts/2013-07-27-the-remains-of-the-day.html">长日无痕</a>，<a href="http://tchen.me/posts/2013-07-22-why-should-c-programmers-learn-erlang.html">Erlang</a>，<a href="http://tchen.me/posts/2013-03-08-career-path-for-software-engineer.html">瞎扯软件工程师的职业生涯</a>，<a href="http://tchen.me/posts/2013-02-06-Making-a-next-generation-home-security-device.html">创建下一代家用防火墙</a></p>
<p>获奖文章：创建下一代家用防火墙</p>
<p>这是年初的一篇文章，大胆地构想了一种全新的智能家用网络（安全）产品的商业模式。从市场的角度来看，一个家庭基本上只会有一个网络设备，所以带有安全功能的网络连接设备最终会不可逆地取代单一功能的路由产品；从可用性来说，家用网络设备要尽可能地将IP/MAC，各种网络协议等术语隐藏起来，代之以人性化的命名。一条安全策略应该是：<code>孩子的ipad 禁止访问 黄色网站</code>，而不是只有专家才能看懂的配置；从智能化角度来说，利用云计算和大数据处理能力，将复杂计算，预测，防护和各种高级功能都云端化；从商业角度来看，硬件厂商最终不通过硬件本身赚钱（甚至免费为用户定期更新硬件），而通过ARPU持续产生收入。</p>
<h3>最有价值知识</h3>
<p>入围知识：<a href="http://en.wikipedia.org/wiki/Lean_Startup">lean startup</a>，<a href="http://steveblank.com/category/customer-development/">Customer development method</a>，<a href="http://paulgraham.com/ds.html">Do things that don&#39;t scale</a>，<a href="http://www.triz40.com/aff_Principles.htm">Triz 40 principles</a></p>
<p>获奖知识：Triz 40 principles</p>
<p>Triz背后的研究团队研究了40, 000个patents，从各个patent中和已有patent的delta中，试图找到创新活动的特征。最终他们得到了这40组principle，对创新很有指导意义。对我而言，知道这个结论产生的过程远比知道这个结论要震撼得多 —— 研究40,000个patents，这得花多大的功夫和毅力？</p>
<h3>最佳程序语言</h3>
<p>入围语言：c，python，golang，javascript，erlang</p>
<p>获奖程序语言：python</p>
<p>这些语言是我在2013年来写过有意义的项目的语言，玩票性质的 io，scala，elixir，emacslisp 不在此列。python获奖实至名归，我这一年来写的80%的代码都是python。尽管我倾注了不少精力向javascript倾斜，但真要甩着膀子大干一场，指尖下流出的还是python。（这就是爱啊）</p>
<p>什么？我的工作语言是C？好吧，大多数时间里C让我有钱花，而Python让我快乐。</p>
<h3>最佳社区贡献</h3>
<p>2013我对社区的贡献少得可怜，虽然写了不少开源的项目，但要么自娱自乐，要么为某一特定目的而作，对社区基本没什么价值。下面两个算是矮子里拔将军，勉强可以充数。</p>
<p>入围社区贡献：<a href="https://github.com/tyrchen/teamspark">teamspark</a>，<a href="http://stackoverflow.com/questions/20671535/why-this-code-generate-very-big-executable-in-go-around-81m">go compiler bug</a></p>
<p>获奖社区贡献：go compiler bug</p>
<p>在学习go语言的过程中，无意中发现在某种特定情况下，go的编译器会生成非常巨大的可执行文件。在stackoverflow上发问后，得到了有意思的答案，并促使我进一步去研究问题的原因和workaround。twitter上有人<a href="https://twitter.com/davecheney/status/413794697966936064">对此讨论</a>，并建议我给go <a href="https://code.google.com/p/go/issues/detail?id=6993">提交bug</a>。所以这个对社区的价值要比我用 <a href="http://meteor.com">Meteor</a> 写的 teamspark 要高。</p>
<h3>最佳进步</h3>
<p>入围事件：</p>
<ul>
<li>从golang hello world新手到写下有价值代码的 <strong>学徒</strong>，仅仅花了一周多的业余时间。在为一个项目写下1339行代码后，我已经正式步入golang学徒生涯。</li>
<li>从对编剧一无所知到写下一个自我感觉还过得去（比百度文档中找到的那些强多了），有故事，有笑点，结合公司内外大小诸事的剧本，仅花了半天时间。从此我正式跨入业余编剧的行列。</li>
<li>看了几个youtube教程后，我便走上了视频制作和剪辑之路。全年产出9个质量还过得去的视频。</li>
</ul>
<p>获奖事件：一周多学会golang</p>
<p>如果说C和python是我的现金奶牛事业部，那么golang则是我的未来发展事业部。至于编剧和视频剪辑嘛，在可预见的未来，他们都还是cost center。所以 &quot;一周多学会golang&quot; 拿下最佳进步奖当之无愧。</p>
<h3>最美滋味</h3>
<p>在劳碌了一天，拖着疲惫的身子回家，有什么能比得上我的心肝宝贝一句酥麻入骨的『爸爸』来得美妙？毫无悬念，这一年最美的滋味就是我那宝贝女儿。从学会翻身，到能坐起来，从勉强行走到奔走如飞，从只会叫大大，到十几个单词量，她带给我数不胜数的美妙感受。工作郁闷且又无法发泄时，想想她萌萌的表情，想想她动听的声音，快乐就从心底涌出，融掉了一切烦恼……</p>
<p>太久没放她的照片，这下一次就是五张！我会努力做一个称职的父亲滴！</p>
<p><img src="/assets/files/photos/baby20131224-1.jpg" alt="小宝">
<img src="/assets/files/photos/baby20131224-2.jpg" alt="小宝">
<img src="/assets/files/photos/baby20131224-3.jpg" alt="小宝">
<img src="/assets/files/photos/baby20131224-4.jpg" alt="小宝">
<img src="/assets/files/photos/baby20131224-5.jpg" alt="小宝"></p>
<h2>尾声</h2>
<p>啰啰唆唆写了这么多，还意犹未尽。暂且停笔，日后再慢慢修葺。千言万语都道不尽的2013，即将从指尖溜走；而我的2014，则注定会多姿多彩。</p>
]]></description>
            <link>http://tchen.me/posts/2013-12-23-my-year-2013.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-12-23-my-year-2013.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Tue, 24 Dec 2013 06:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[建立自己的docker repository]]></title>
            <description><![CDATA[<p>如果你不知道docker是什么，请参考 <a href="http://www.slideshare.net/dotCloud/why-docker">这个slides</a>。</p>
<p>在 ubuntu 下安装 docker 请参考 <a href="http://docs.docker.io/en/latest/installation/ubuntulinux/">官方教程</a> 。注意，由于 docker 的核心技术是 <a href="http://en.wikipedia.org/wiki/LXC">Linux container</a>，所以如果想在 osx 下安装 docker 请使用 vagrant。</p>
<!--more-->

<h2>安装docker-registry</h2>
<p>首先clone docker-registry：</p>
<pre><code>$ git clone https://github.com/dotcloud/docker-registry
$ cd docker-registry

$ cp config_sample.yml config.yml</code></pre>
<p>然后打开 <code>config.yml</code>，设置dev（缺省）的storage路径为 <code>/var/docker/registry</code>：</p>
<pre><code># This is the default configuration when no flavor is specified
dev:
    storage: local
    storage_path: /var/docker/registry
    loglevel: debug</code></pre>
<p>创建这个目录：</p>
<pre><code>$ sudo mkdir -p /var/docker/registry
$ sudo chown -R tchen /var/docker</code></pre>
<p>docker-registry使用了python，需要以下库的支持：</p>
<pre><code>$ sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev</code></pre>
<p>然后建立 <code>virtualenv</code> 并安装requirements：</p>
<pre><code>$ sudo pip install virtualenv
$ virtualenv --no-site-packages venv
$ . venv/bin/activate
$ pip install -r requirements.txt</code></pre>
<h2>配置supervisor</h2>
<p>如果系统没有安装supervisor，请先安装:</p>
<pre><code>$ sudo apt-get install supervisor</code></pre>
<p>安装完成后，配置 <code>supervisor</code>：</p>
<pre><code>$ sudo vim /etc/supervisor/conf.d/docker-registry.conf</code></pre>
<p>填入以下内容：</p>
<pre><code>[program:docker-registry]
directory=/home/dev/deployment/docker-registry
user=dev
command=/home/dev/deployment/docker-registry/venv/bin/gunicorn -b 0.0.0.0:7030 -k gevent --max-requests 100 --graceful-timeout 3600 -t 3600 -w 8 wsgi:application
redirect_stderr=true
stderr_logfile=none
stdout_logfile=/var/log/supervisor/docker-registry.log
autostart=true
autorestart=true</code></pre>
<p>重新加载 <code>supervisor</code> 配置：</p>
<pre><code>$ sudo supervisorctl
supervisor&gt; reread
docker-registry: available
supervisor&gt; update
docker-registry: added process group
supervisor&gt; status
docker-registry                  RUNNING    pid 4371, uptime 0:00:01</code></pre>
<p>这样，<code>docker-registry</code> 服务就正常运行了。</p>
<h2>配置nginx</h2>
<p>接下来把 <code>nginx</code> request proxy 到 <code>docker-registry</code> app 就大功告成了。</p>
<pre><code>$ sudo vim /etc/nginx/sites-available/docker-registry</code></pre>
<p>填入以下内容：</p>
<pre><code>server {
  listen 80;
  client_max_body_size 200m;
  server_name docker.your-domain.com;
  access_log /var/log/nginx/docker-registry.access.log;
  error_log /var/log/nginx/docker-registry.error.log;
  location / {
    proxy_pass http://localhost:7030;
    include /etc/nginx/proxy_params;
  }
}</code></pre>
<p>然后将其加入 <code>sites-enabled</code> 并重启nginx：</p>
<pre><code>$ cd /etc/nginx/sites-enabled/
$ sudo ln -s ../sites-available/docker-registry docker-registry
$ sudo /etc/init.d/nginx restart</code></pre>
<p>把 <code>docker</code> 二级域名加入到你的域名服务器中，然后打开浏览器访问 <code>http://docker.your-domain.com</code> 就可以看到如下页面：</p>
<pre><code>&quot;docker-registry server (dev)&quot;</code></pre>
<p>至此，<code>docker-registry</code> 就正常运行了。</p>
<p>接下来看看系统都有哪些 docker images：</p>
<pre><code>(venv)tchen@docker:~$ sudo docker images
REPOSITORY                            TAG                   IMAGE ID            CREATED             SIZE
colinsurprenant/ubuntu-raring-amd64   latest                2eb422301015        6 weeks ago         91.89 MB (virtual 91.89 MB)
colinsurprenant/ubuntu-raring-amd64   raring-amd64          2eb422301015        6 weeks ago         91.89 MB (virtual 91.89 MB)
colinsurprenant/ubuntu-raring-amd64   ubuntu-raring-amd64   22ca6d4b1576        6 weeks ago         91.89 MB (virtual 91.89 MB)
ubuntu                                12.04                 8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                latest                8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                precise               8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                12.10                 b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
ubuntu                                quantal               b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-12.10          b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantal        b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantl         b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)</code></pre>
<p>我们选择 <code>base</code> 对应的 image，将其 push 到自己的服务器。首先将其标记为要push到自己的服务器：</p>
<pre><code>$ sudo docker tag b750fe79269d docker.your-domain.com/tchen/base</code></pre>
<p>然后push:</p>
<pre><code>$ sudo docker push docker.your-domain.com/tchen/base
The push refers to a repository [docker.your-domain.com/tchen/base] (len: 1)
Sending image list
Pushing repository docker.your-domain.com/tchen (1 tags)
Pushing 27cf784147099545

2013/11/12 03:35:18 Received HTTP code 413 while uploading layer: &lt;html&gt;
&lt;head&gt;&lt;title&gt;413 Request Entity Too Large&lt;/title&gt;&lt;/head&gt;
&lt;body bgcolor=&quot;white&quot;&gt;
&lt;center&gt;&lt;h1&gt;413 Request Entity Too Large&lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx/1.4.3&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>如果出现以上错误，请修改之前nginx配置中的 <code>client_max_body_size 200m;</code>，将其扩大至能够容纳你的image。</p>
<p>成功后可以看到：</p>
<pre><code>$ sudo docker images
REPOSITORY                            TAG                   IMAGE ID            CREATED             SIZE
colinsurprenant/ubuntu-raring-amd64   latest                2eb422301015        6 weeks ago         91.89 MB (virtual 91.89 MB)
colinsurprenant/ubuntu-raring-amd64   raring-amd64          2eb422301015        6 weeks ago         91.89 MB (virtual 91.89 MB)
colinsurprenant/ubuntu-raring-amd64   ubuntu-raring-amd64   22ca6d4b1576        6 weeks ago         91.89 MB (virtual 91.89 MB)
ubuntu                                12.04                 8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                latest                8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                precise               8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                12.10                 b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
docker.your-domain.com/base              latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
docker.your-domain.com/tchen             latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
docker.your-domain.com/tchen/base        latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
ubuntu                                quantal               b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-12.10          b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantal        b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantl         b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)</code></pre>
<p>本地的image就可用了，尝试一下：</p>
<pre><code>$ sudo docker run -i -t docker.your-domain.com/tchen/base /bin/bash</code></pre>
<p>在其他机器上要pull这个image，很简单：</p>
<pre><code>$ sudo docker pull docker.your-domain.com/tchen/base</code></pre>
]]></description>
            <link>http://tchen.me/posts/2013-11-13-local-docker-repo.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-11-13-local-docker-repo.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Thu, 14 Nov 2013 06:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Build Your Own Docker Registry with DigitalOcean]]></title>
            <description><![CDATA[<h1>Build Your Own Docker Registry with DigitalOcean</h1>
<p><a href="http://www.slideshare.net/dotCloud/why-docker">Docker</a> might be the most attracting open source technologies in 2013. By providing a higher level API and management UI, it make linux container much more usable. If you haven&#39;t tried it, <a href="http://www.docker.io/gettingstarted/">try it</a>. You will then feel it is &quot;<a href="http://blog.scoutapp.com/articles/2013/08/28/docker-git-for-deployment">the git for deployment</a>&quot;.</p>
<p>After you played with it for a while, enjoying the git like operation for your software and their dependencies, a natural question will appear: how can I build my own private docker registry that I could leverage for my own IT infrastructure? </p>
<p>The docker-registry comes to help you. docker-registry is a software to provide similar functionality as <a href="http://index.docker.io/">official docker index</a>, which is a central registry for you to commit your new images, pull existing ones, etc. It can let you to build your own docker registry that is private, secure and speedy.</p>
<h2>Install docker-registry</h2>
<p>First of all, let&#39;s clone docker-registry：</p>
<pre><code>git clone https://github.com/dotcloud/docker-registry
cd docker-registry
cp config_sample.yml config.yml</code></pre>
<p>You need then to open config.yml to set the dev (the default profile) storage to something like <code>/var/docker/registry</code>:</p>
<pre><code># This is the default configuration when no flavor is specified
dev:
    storage: local
    storage_path: /var/docker/registry
    loglevel: debug</code></pre>
<p>Then create this directory and grant </p>
<pre><code>sudo mkdir -p /var/docker/registry
sudo chown -R `whoami` /var/docker</code></pre>
<p>As docker-registry uses python and ssl, you need to install the following libraries:</p>
<pre><code>sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev</code></pre>
<p>Then you can setup your virtualenv and install requirements:</p>
<p>(optional) install virtualenv if you haven&#39;t:</p>
<pre><code>sudo pip install virtualenv</code></pre>
<p>setup virtualenv:</p>
<pre><code>virtualenv --no-site-packages venv
. venv/bin/activate
pip install -r requirements.txt</code></pre>
<p>Now your docker-registry should be run via:</p>
<pre><code>gunicorn -k gevent --max-requests 100 --graceful-timeout 3600 -t 3600 -b localhost:8080 -w 8 wsgi:application</code></pre>
<p>You can open your browser on <code>http://localhost:8080</code> to see if it works. It should show you:</p>
<pre><code>&quot;docker-registry server (dev)&quot;</code></pre>
<p>Congratulations! The minimum installation is done. However, if you want to run it like a normal service, you need to configure supervisor and nginx. Let&#39;s continue our journey.</p>
<h2>Run docker-registry as a service</h2>
<p>If you don&#39;t have supervisor installed, please install it firstly:</p>
<pre><code>sudo apt-get install supervisor</code></pre>
<p>Then add a new configuration file:</p>
<pre><code>sudo vim /etc/supervisor/conf.d/docker-registry.conf</code></pre>
<p>In the opened vim editor, copy and paste the following content, save and quit (you need to change dev to your local user):</p>
<pre><code>[program:docker-registry]
directory=/home/dev/deployment/docker-registry
user=dev
command=/home/dev/deployment/docker-registry/venv/bin/gunicorn -b 0.0.0.0:7030 -k gevent --max-requests 100 --graceful-timeout 3600 -t 3600 -w 8 wsgi:application
redirect_stderr=true
stderr_logfile=none
stdout_logfile=/var/log/supervisor/docker-registry.log
autostart=true
autorestart=true</code></pre>
<p>Then reload supervisor to make it take effects.</p>
<pre><code>$ sudo supervisorctl
supervisor&gt; reread
docker-registry: available
supervisor&gt; update
docker-registry: added process group
supervisor&gt; status
docker-registry                  RUNNING    pid 4371, uptime 0:00:01</code></pre>
<p>If you see RUNNING int the status output, then it means your docker-registry is up and running normally. If not, please got to <code>/var/log/supervisor/docker-registry.log</code> to see what happened.</p>
<p>Next you need to use nginx to proxy the requests to docker-registry. If you don&#39;t have nginx installed, please install it firstly:</p>
<pre><code>sudo apt-get install nginx</code></pre>
<p>Then add a new configuration file:</p>
<pre><code>sudo vim /etc/nginx/sites-available/docker-registry</code></pre>
<p>Copy and paste the following content, then save and quite:</p>
<pre><code>server {
  listen 80;
  client_max_body_size 200m;
  server_name your-domain.com;
  access_log /var/log/nginx/docker-registry.access.log;
  error_log /var/log/nginx/docker-registry.error.log;
  location / {
    proxy_pass http://localhost:8080;
    include /etc/nginx/proxy_params;
  }
}</code></pre>
<p>Note that you need <code>client_max_body_size 200m</code> to allow big file post. If later your found error like:</p>
<pre><code>2013/11/12 03:35:18 Received HTTP code 413 while uploading layer</code></pre>
<p>You need to enlarge this value.</p>
<p>Then you need to soft link this file to <code>sites-enabled</code> and restart nginx:</p>
<pre><code>cd /etc/nginx/sites-enabled/
sudo ln -s ../sites-available/docker-registry docker-registry
sudo service nginx restart</code></pre>
<p>Open your browser to visit <code>http://your-domain.com</code>, you should see the same result as previous step:</p>
<pre><code>&quot;docker-registry server (dev)&quot;</code></pre>
<h2>Use your private docker registry</h2>
<p>First of all, let&#39;s see what images we have so far:</p>
<pre><code>$ sudo docker images
REPOSITORY                            TAG                   IMAGE ID            CREATED             SIZE
ubuntu                                12.04                 8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                latest                8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                precise               8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                12.10                 b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
ubuntu                                quantal               b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-12.10          b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantal        b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantl         b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)</code></pre>
<p>If you don&#39;t have any docker images, please use <code>sudo docker pull base</code> to pull base images from docker repository.</p>
<p>We would like to push the base image to our own shiny registry. First of all, tag it to push to your own server:</p>
<pre><code>sudo docker tag b750fe79269d your-domain.com/yourname/base</code></pre>
<p>Then push:</p>
<pre><code>sudo docker push your-domain.com/yourname/base</code></pre>
<p>If push succeeded, you will see your images with <code>docker images</code>:</p>
<pre><code>$ sudo docker images
REPOSITORY                            TAG                   IMAGE ID            CREATED             SIZE
ubuntu                                12.04                 8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                latest                8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                precise               8dbd9e392a96        7 months ago        131.5 MB (virtual 131.5 MB)
ubuntu                                12.10                 b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
your-domain.com/yourname/base        latest                b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
ubuntu                                quantal               b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-12.10          b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantal        b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)
base                                  ubuntu-quantl         b750fe79269d        7 months ago        24.65 kB (virtual 180.1 MB)</code></pre>
<p>It is already available locally, so you can try it：</p>
<pre><code>sudo docker run -i -t your-domain.com/yourname/base /bin/bash</code></pre>
<p>If you want to pull this image from other machine, just use:</p>
<pre><code>sudo docker pull your-domain.com/yourname/base</code></pre>
<p>Have fun!</p>
]]></description>
            <link>http://tchen.me/posts/2013-11-13-local-docker-repo-en.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-11-13-local-docker-repo-en.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Thu, 14 Nov 2013 06:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[使用HTTPS]]></title>
            <description><![CDATA[<p>如今随着网上交易规模不断扩大及API驱动的互联网的出现（如 <a href="https://strip.com">https://strip.com</a> ），互联网的安全性越来越受到重视。本文简单讲述如何将你的nginx配置成支持https的web server。当然，理论上一个合格的https server需要从CA那里获得正式的SSL certificate，但如何购买SSL certificate不在本文讨论之列。本文仅从技术上讨论如何在你的服务器上使能https。</p>
<!--more-->

<h2>生成证书</h2>
<h3>生成RSA key</h3>
<p>首先生成本地的RSA key，我们使用1024 bit的密钥。pass phrase一定要输入，并且输入的pass phrase在接下来的步骤中要使用。</p>
<pre><code>sudo mkdir /etc/nginx/ssl
cd /etc/nginx/ssl
$ sudo openssl genrsa -des3 -out myserver.key 1024
[sudo] password for tchen:
Generating RSA private key, 1024 bit long modulus
.....++++++
.++++++
e is 65537 (0x10001)
Enter pass phrase for myserver.key:
Verifying - Enter pass phrase for myserver.key:
`</code></pre>
<h3>生成csr (Certificate Signing Request)</h3>
<p>CSR包含能够鉴别证书申请人的信息。关于CSR及X.509证书的详细说明，请参考：<a href="http://en.wikipedia.org/wiki/Certificate_signing_request。">http://en.wikipedia.org/wiki/Certificate_signing_request。</a></p>
<pre><code>$ sudo openssl req -new -key myserver.key -out myserver.csr
Enter pass phrase for myserver.key:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter &#39;.&#39;, the field will be left blank.
-----
Country Name (2 letter code) [AU]:CN
State or Province Name (full name) [Some-State]:Beijing
Locality Name (eg, city) []:BJ
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Coderena
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:myserver.com
Email Address []:tchen@myserver.com

Please enter the following &#39;extra&#39; attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:</code></pre>
<h3>为csr签名</h3>
<p>首先要把刚才生成的RSA密钥的pass phrase移除：</p>
<pre><code>$ sudo openssl rsa -in myserver.key.org -out myserver.key
Enter pass phrase for myserver.key.org:
writing RSA key</code></pre>
<p>对CSR进行为期一年（365 days）的授权，生成证书：</p>
<pre><code>$ sudo openssl x509 -req -days 365 -in myserver.csr -signkey myserver.key -out myserver.crt
Signature ok
subject=/C=CN/ST=Beijing/L=BJ/O=Coderena/CN=myserver.com/emailAddress=tchen@myserver.com
Getting Private key</code></pre>
<h3>保护证书</h3>
<p>在当前目录下，把证书相关文件的权限改为只可自己读，防止他人使用或篡改。</p>
<pre><code>$ sudo chmod 600 *</code></pre>
<h2>设置nginx</h2>
<p>接下来就是设置网站使用证书。一般我们的app server（如nodejs或gunicorn）都部署在nginx或apache后，所以SSL可以在用户端和web server端使能，这样免去了为每个app server支持SSL的麻烦。这样做在web server和app server之间存在一定的安全风险，但一般而言，web server / app server都在同一个受信任的网络内，所以问题不大。</p>
<p>本文将讨论在nginx下配置SSL。假设在site-available下你有如下virtual host:</p>
<pre><code>server {
  listen 80;
  server_name myserver.com;
  set $current_root &quot;/home/dev/deployment/myserver&quot;;
  access_log /var/log/nginx/myserver.access.log;
  error_log /var/log/nginx/myserver.error.log;

  location ~* ^/media/ {
    autoindex off;
    root $current_root;
    expires max;
  }

  location ~* ^/static/ {
    autoindex off;
    root $current_root;
    expires 30d;
  }

  location / {
    proxy_pass http://localhost:7010;
    include /etc/nginx/proxy_params;
  }
}</code></pre>
<p>要对其使能https，首先，将所有http请求都跳转到https：</p>
<pre><code>server {
 listen      80;
 server_name myserver.com;
 rewrite     ^ https://$server_name$request_uri? permanent;
}</code></pre>
<p>接着配置https:</p>
<pre><code>server {
  listen 443;
  ssl on;
  ssl_certificate /etc/nginx/ssl/myserver.crt;
  ssl_certificate_key /etc/nginx/ssl/myserver.key;

  server_name myserver.com;

  set $current_root &quot;/home/dev/deployment/myserver&quot;;
  client_max_body_size 32m;

  access_log /var/log/nginx/myserver.access.log;
  error_log /var/log/nginx/myserver.error.log;

  location ~* ^/media/ {
    autoindex off;
    root $current_root;
    expires max;
  }


  location ~* ^/static/ {
    autoindex off;
    root $current_root;
    expires 30d;
  }

  location / {
    proxy_pass http://localhost:7010;
    include /etc/nginx/proxy_ssl_params;
  }

}</code></pre>
<p>我们之前使用的proxy params在 <code>proxy_params</code> 文件中：</p>
<pre><code>proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></pre>
<p>对于https，我们需要一个单独的 <code>proxy_ssl_params</code> 文件:</p>
<pre><code>proxy_redirect off;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto https;</code></pre>
<p>两者有一些差别。</p>
<p>至此，整个证书的生成及使用就完成了，重启nginx后打开浏览器就可以尝试。注意由于我们的证书是在本地签名的，不属于一个合法的CA授权的证书，所以浏览器会报警，继续浏览即可。虽然浏览器认为其安全性存在问题，但整个访问过程都是通过SSL进行加密的。</p>
<h2>补记</h2>
<p>如果要购买被验证的证书，需要花费一大笔美刀（比如Symantac的单服务器任意子域名3年有效的证书要$5095）。这么贵是有原因的：</p>
<ul>
<li>CA需要在技术上做大笔投入来保护自己的data center不被攻破。（想想看上百万的证书私钥对黑客有多大的吸引力，就像银行的金库一样）</li>
<li>CA往往对证书提供保险（上例中的证书有每年 $500, 000的保障，大致意思是如果证书被compromise，对于你的损失，我最高可以赔这些钱）。</li>
<li>SSL certificate是身份和实力的象征，大企业和创业土豪们不差钱。</li>
</ul>
<p>当然，如果你付不起这么多钱，很想使用https保护你的用户（但根本不需要巨额的保险），可以购买那些二三线的CA的证书。几美金到几十美金一年就可以搞定。这就跟把传家宝藏在瑞士银行的保险柜里和放在本地农商行的保险柜一个道理，一分钱一分货。</p>
<p>送上小宝照片一枚：</p>
<p><img src="/assets/files/photos/baby20131110.jpg" alt="小宝"></p>
]]></description>
            <link>http://tchen.me/posts/2013-11-11-https.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-11-11-https.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Mon, 11 Nov 2013 06:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Hatch: 实验]]></title>
            <description><![CDATA[<p>继续 <a href="/posts/2013-11-03-hatch-experiment.html">前文</a> 。熬到了周末，正式开始了 <code>hatch</code> 项目的开发。首先是一个关键问题：如果每个文件的生成由一个单一的shell脚本完成，那么数据库打开/关闭的损耗会不会成为瓶颈？做了个简单的实验，发现每次打开都要花费0.2s，一个不小的数字。</p>
<pre><code>➜  hatch git:(master) ✗ cat test.coffee
#!/usr/bin/env coffee

db = require(&#39;mongojs&#39;)(&#39;hatch&#39;)
col = db.collection(&#39;documents&#39;)

col.findOne {}, (err, doc) -&gt;
    db.close()</code></pre>
<pre><code>➜  hatch git:(master) ✗ time ./test.coffee
./test.coffee  0.20s user 0.03s system 99% cpu 0.226 total</code></pre>
<!--more-->

<p>这意味着照之前的设想，一千个文件如果都单独parse，那么仅数据库打开/关闭就需要200s，这是不可接受的。于是，最初的想法不得不调整。如果在一个大脚本中完成所有事情，显然是最经济的，但这样无法借助 <code>makefile</code> 的优势，于是妥协为：</p>
<ol>
<li>整个系统依旧由 <code>make</code> 驱动，除unix已有的工具外，撰写：<code>hatch-parse</code>，<code>hatch-gen</code>，<code>hatch-tag</code> 和 <code>hatch-index</code>。</li>
<li>所有这些脚本支持 <code>1..n</code> 个参数，为输入的文件名。</li>
<li>由于这样无法使用 <code>makefile</code> 中的依赖，所以需要一个 <code>hatch-diff</code> 为其提供参数。</li>
</ol>
<p>解释一下第三点：</p>
<p>如果 <code>hatch-gen</code> 只处理单个文件，那么 <code>makefile</code> 中的依赖关系很容易推导出需要处理的文件，并依次处理之：</p>
<pre><code>OUT=out
SRC=src
CONTENT_PATH=$(SRC)/contents
OUTS=$(subst $(SRC),$(OUT), $(shell find $(CONTENT_PATH) -type f -name &#39;*&#39;))

$(OUTS): $(OUT)%: $(SRC)%
    @echo &quot;Creating $@.&quot;
    @$(HATCH_GEN) $@ $&lt;</code></pre>
<p>但如果我们要处理大批文件，则不能这么做，所以我做了个 <code>hatch-diff</code> 来返回更改过的文件列表，于是 <code>makefile</code> 变为：</p>
<pre><code>generate:
    @$(HATCH_GEN) $(shell $(HATCH_DIFF) -e .html $(CONTENT_PATH) $(CONTENT_OUT_PATH))</code></pre>
<blockquote>
<p>注：写该代码时我还不知道 <code>makefile</code> 有 <code>$?</code> 这样的神器。所以其实 <code>hatch-diff</code>基本没用。</p>
</blockquote>
<h2>具体实现</h2>
<p>实现代码见：<a href="https://github.com/coderena/hatch">https://github.com/coderena/hatch</a>.</p>
<p>核心代码在 <code>lib/core.coffee</code>。目前实现得很简单，还没有进一步的命令行来帮助使用者创建项目。</p>
<p>测试代码在 <code>test</code> 下。</p>
<p>具体实现很简单，也很直接。就不讨论。</p>
<h2>问题与解决</h2>
<h3>加速，加速，加速！</h3>
<p>打开数据库的时间越滞后越好。</p>
<p>能通过 <code>makefile</code> 的 dependency 解决的就放在那里解决。数据库里的内容和磁盘上的文件谁新谁旧，可以通过建立这样的 dependency:</p>
<pre><code>$(CONTENT_DEPS): $(DEP)/%: $(SRC)/%
    @touch $@

content_depend: $(CONTENT_DEP_PATHS) $(CONTENT_DEPS)</code></pre>
<p>每次 parse 完磁盘文件就更新 dependency，这样一旦文件改变，make就能分析出要重新parse的文件。</p>
<p>牢记 <code>nodejs</code> 单线程的劣势，尽可能用asynchronous的库和代码。需要异步处理一堆事情，但要在所有处理完成后统一操作请使用 <code>async</code> 库。</p>
<p>为了提高速度，所有 <code>jade</code> 模板都预编译好，再和 <code>locals</code> 结合，生成html。</p>
<h3>绑定，绑定，绑定！</h3>
<p>跟 <code>docpad</code> 一样，我希望用户可以定制他们自己的helpers，在模板中使用。比如：</p>
<pre><code>hatchConfig =
    layoutData:
        site:
            # default url of the site
            url: &#39;http://hatch-jade-example.com&#39;
            # default time of the site
            title: &#39;Example website build with hatch&#39;

            getTitle: -&gt;

                if @document.title
                    &quot;#{@document.title} | #{@site.title}&quot;
                else
                    @site.title</code></pre>
<p>然后在模板中可以直接访问：</p>
<pre><code>extends common/default

block prepend title
  | #{ getTitle() }</code></pre>
<p>如果直接把 <code>layoutData</code> 传给 <code>jade</code> 去编译，<code>this</code> 并不存在，必然报错。所以需要为每个helper函数进行 <code>this</code> 的绑定，问题是，<a href="http://stackoverflow.com/questions/5999998/how-can-i-check-if-a-javascript-variable-is-function-type">怎么判断一个值是函数呢</a>？这是 javascript 语言中的又一个坑。我的项目中使用了 <code>lodash</code>，所以自然而然会使用 <code>_.isFunction()</code>:</p>
<pre><code>locals = {document: data}
_.extend locals, self.config.layoutData
    for own key, value of locals
        if _.isFunction value
            locals[key] = value.bind(locals)</code></pre>
<h3>处理teaser和长文的分页</h3>
<p>teaser一般是文章的头一段，在索引页中方便用户领略文章的大致内容。目前大部分静态网站生成器都使用html comment，如 <code>&lt;!--more--&gt;</code> 来达到这一目的，这样做有点问题：如果teaser之前有标题，那么标题也被包含在teaser里，展示效果不好，于是我采用下述方法定义teaser。用户仅需要在想标记为teaser的地方前后进行标注即可，不限于文章的任何部分，灵活性很好。</p>
<pre><code># teaser notation in the document
regexTeaser: /&lt;!--\s*teaser\s*--&gt;\s*([\s\S]*?)\s*&lt;!--\s*teaser\s*--&gt;/i</code></pre>
<p>长文的分页也是类似的想法。定义了 <code>&lt;!--page--&gt;</code>：</p>
<pre><code># page notation in the document
regexPager: /&lt;!--\s*page\s*--&gt;/</code></pre>
<p>可以这样来生成页面：</p>
<pre><code>@adapter.findOne src: src, (err, doc) -&gt;
    return cb(err) if err

    if doc
        generate_doc = (i, callback) -&gt;
            data = {}
            _.extend data, doc
            data.content = doc.contents[i]
            delete data.contents

            locals = {document: data}
            _.extend locals, self.config.layoutData
            for own key, value of locals
                if _.isFunction value
                    locals[key] = value.bind(locals)
            html = self.layouts[doc.layout] locals
            if i is 0
                filename = &quot;#{dst}.html&quot;
            else
                filename = &quot;#{dst}.#{i}.html&quot;
            fs.writeFile filename, html, (err) -&gt;
                callback err, filename

        async.map _.range(doc.contents.length), generate_doc, (err, data) -&gt;
            cb err, data</code></pre>
<h3>在jade里处理回调</h3>
<p>由于用户可以自定义helper，如果要访问数据库，理论上可以这样做：</p>
<pre><code>getRelated: (tags, cb) -&gt;
    @adapter.findTag tags: $in: tags, 10, (err, docs) -&gt;
        return cb(err) if err

        # blablabla</code></pre>
<p>但在 <code>jade</code> 中，helper是不允许回调的，所以，除了把数据库访问变成同步模式，这个现在貌似无解。</p>
<h2>测试</h2>
<p>在我的本地环境中，我创建了一个有1k+ <code>markdown</code> 源文件的项目，测试结果还不赖：</p>
<pre><code>➜  hatch-jade-example git:(master) ✗ make fullclean
➜  hatch-jade-example git:(master) ✗ time make
Creating dependency paths .dep/layouts.
Creating dependency paths .dep/layouts/common.
Creating dependency paths .dep/layouts/common/includes.
Creating dependency paths .dep/layouts/common/includes/asides.
Creating dependency paths .dep/layouts/common/mixins.
    Too many layouts changed, clean all outputs.
Parsing the documents into database.
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc  1118 docs parsed.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Creating output paths.
Generate documents.
    1118 docs generated.
Creating dependency paths .dep/contents.
Creating dependency paths .dep/contents/docs.
Creating dependency paths .dep/contents/post1.
Creating dependency paths .dep/contents/post10.
Creating dependency paths .dep/contents/post11.
Creating dependency paths .dep/contents/post12.
Creating dependency paths .dep/contents/post13.
Creating dependency paths .dep/contents/post14.
Creating dependency paths .dep/contents/post15.
Creating dependency paths .dep/contents/post16.
Creating dependency paths .dep/contents/post17.
Creating dependency paths .dep/contents/post18.
Creating dependency paths .dep/contents/post19.
Creating dependency paths .dep/contents/post2.
Creating dependency paths .dep/contents/post20.
Creating dependency paths .dep/contents/post21.
Creating dependency paths .dep/contents/post22.
Creating dependency paths .dep/contents/post23.
Creating dependency paths .dep/contents/post24.
Creating dependency paths .dep/contents/post25.
Creating dependency paths .dep/contents/post3.
Creating dependency paths .dep/contents/post4.
Creating dependency paths .dep/contents/post5.
Creating dependency paths .dep/contents/post6.
Creating dependency paths .dep/contents/post7.
Creating dependency paths .dep/contents/post8.
Creating dependency paths .dep/contents/post9.
Build completed!
make  5.93s user 1.65s system 100% cpu 7.540 total
➜  hatch-jade-example git:(master) ✗ touch src/contents/docs/2013-01-01-atanasoff-implementation.markdown
➜  hatch-jade-example git:(master) ✗ time make
Parsing the documents into database.
u   1 docs parsed.
Generate documents.
    1 docs generated.
Build completed!
make  2.28s user 0.24s system 101% cpu 2.477 total</code></pre>
<h2>后记 &amp; 未完待续</h2>
<p>这个项目目前仅仅实现了POC，比我预期的进展要缓慢一些。但这毕竟是我第一次跳出 <code>express</code> 的框框去写 <code>nodejs</code> 代码，所以可以原谅。</p>
<p>写 <code>makefile</code> 是种享受，尤其是几行很直观的代码下来就达到用编程语言几十甚至上百行的效果。不信，看看项目中我为了实现类似查找 dependency 变化的代码：</p>
<pre><code>$ cat lib/diff.coffee
fs = require &#39;fs&#39;
file = require &#39;file&#39;
path = require &#39;path&#39;
async = require &#39;async&#39;
_ = require &#39;lodash&#39;

# params should contain src, dst and ext
diffPath = (src, dst, ext, callback) -&gt;
    fileTimeDiff = (src_file, cb) -&gt;
        old_ext = path.extname(src_file)
        dst_file = src_file.replace(src, dst)
        if ext
            dst_file = dst_file.replace(old_ext, ext)

        fs.stat src_file, (err, src_stat) -&gt;
            return cb(err) if err

            fs.exists dst_file, (exists) -&gt;
                return cb null, src_file if not exists

                fs.stat dst_file, (err, dst_stat) -&gt;
                    cb(err) if err

                    if src_stat.mtime &gt; dst_stat.mtime
                        cb null, src_file
                    else
                        cb null, null


    file.walk src, (err, dirPath, dirs, files) -&gt;
        async.map files, fileTimeDiff, (err, results) -&gt;
            callback err, _.compact(results)

module.exports.diffPath = diffPath

$ cat scripts/hatch-diff.coffee
#!/usr/bin/env coffee
diffPath = require(&#39;./../lib/diff&#39;).diffPath

argv = require(&#39;optimist&#39;)
    .usage(&#39;&#39;&#39;
           Compare two folders
           Usage: $0 [--ext html] src_dir dst_dir
           &#39;&#39;&#39;)
    .demand(2)
    .alias(&#39;e&#39;, &#39;ext&#39;)
    .describe(&#39;e&#39;, &#39;destination file extention&#39;)
    .argv


[src, dst] = argv._
ext = argv.e

diffPath src, dst, ext, (err, data) -&gt;
    for item in data
        console.log item</code></pre>
<p>这么复杂的逻辑仅仅实现了 <code>makefile</code> 中 <code>$?</code> 的功能而已。。。</p>
<p>送上小宝照片一枚。</p>
<p><img src="/assets/files/photos/baby20131103.jpg" alt="小宝"></p>
]]></description>
            <link>http://tchen.me/posts/2013-11-03-hatch-experiment.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-11-03-hatch-experiment.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Tue, 05 Nov 2013 06:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Hatch: 又一个建站工具]]></title>
            <description><![CDATA[<p>在 <a href="/posts/2013-10-28-blog-reborn.html">前文</a> 中，我尝试了 <a href="http://docpad.org">docpad</a> 做为新的建站工具。<code>docpad</code> 有很多优点，但最大的缺点是效率。在我看来，一个好的静态网站生成工具最好能在秒级处理成千上万文档，这样才能真正满足个人博客外的中等规模网站的需求。要做到这一点，工具必须将full build和incremental build区别开来。这样，即使一个full build要花几十秒甚至几分钟，incremental build还能控制在秒级。当用户修改某个文件时，incremental build能够保证用户有良好的体验 —— 无需等待，改动立即可见。而这一点，则恰恰是 <code>docpad</code> 所欠缺的。本文讲述的 <code>hatch</code> 项目将尝试在保留 <code>docpad</code> 的诸多优点外，通过更智能的build过程将编译速度尽最大可能提高。</p>
<!--more-->

<h2>目标</h2>
<p><code>hatch</code> 的目标是实现如下功能：
1. 支持任意模板类型。官方可仅支持 <code>jade</code>，但用户可以轻松扩展。
2. 支持任意格式的源文件。官方可仅支持 <code>markdown</code> 和 <code>jade</code>，但用户可以轻松扩展。
3. 支持复杂页面的生成，如标签聚合页面（docpad-plugin-tagging）和每个文档的相关文档（docpad-plugin-related）的功能。
4. 支持less/coffeescript，及compress。
5. 支持live preview。</p>
<h2>工具选择</h2>
<p>有了目标，我们需要选择合适的工具去完成目标。</p>
<p>在web时代，尽管 <code>rake</code>，<code>jake</code>，<code>grunt</code> 等等task runner大行其道，我还是偏爱 <code>make</code>，因为它最能体现unix的哲学：</p>
<blockquote>
<p>write programs that do one thing and do it well.</p>
</blockquote>
<p>比如说将less生成css并打包，然后上传到服务器上这样的工作：</p>
<pre><code>CSS_SOURCE=$(CSS_PATH)/app.less
CSS_DEPS=$(shell find $(CSS_PATH) -type f -name &#39;*.less&#39;)
CSS_TARGET=app.min.css
SYNC_TARGET=tchen@my-awesome-server.com:/homes/tchen/deployment/css

$(CSS_TARGET): $(CSS_DEPS)
    lessc $(CSS_SOURCE) --yui-compress  &gt; $(CSS_TARGET)

sync: $(CSS_TARGET)
    rsync -au $(CSS_TARGET) $(SYNC_TARGET)</code></pre>
<p>这段代码很简单，目标任务 <code>sync</code> 依赖于 <code>$(CSS_TARGET)</code> 的构建，而 <code>$(CSS_TARGET)</code> 依赖于 <code>$(CSS_DEPS)</code> 的构建。</p>
<p>使用 <code>make</code> 简单明了，且不会做任何无用功。比如说：</p>
<pre><code>$ make sync</code></pre>
<p>在第一次执行后，如果less文件没有修改（ctime没有改变），则不会做任何事就结束了，节省大量的重复劳动。</p>
<p>使用 <code>make</code> 加上合适的shell命令（如果特定功能的命令不存在，我们需要自己创建），我们就可以构建一套完整的编译系统，将 <code>markdown</code> 文件（或者其他类型的文件），经过一系列处理，生成 <code>html</code>。</p>
<h2>依赖处理</h2>
<p>如前文所述，我们要解决的问题归化成一个如何构建合适的 <code>makefile</code>，让源文件（如markdown）高效地（且正确地）编译成目标文件（如html）。而这其中的重点，则在如何处理依赖。</p>
<p>最简单的依赖处理莫过于一个文件发生改变，整个项目都会重新编译。正确性得以保证，但显然不高效。<code>docpad</code> 采用这样的策略，以至于对css的改动会引发html的重编。很不科学，漫长的等待让我这样的用户很受伤。</p>
<p>所以我们要设定合理的依赖规则。</p>
<p>对于目标中我们想要实现的功能，5暂且放在一边，1/2/4很好实现。3是一个难点，需要两次build才能正确处理：
1. make parse。每个修改过的文档单独parse，中间结果保存在 <code>mongodb</code> 中，如果 <code>tags</code> 信息有改变，则删除对应的标签聚合页（会触发重新生成），及受影响的文档页面。
2. make generate。调用整个正式的生成过程，生成所有需要重新生成的页面。</p>
<p><img src="/assets/files/posts/hatch_dep.jpg" alt="博客截图"></p>
<p>如上图，如果删除了标签 <code>docpad</code> ，并添加了标签 <code>hatch</code>，那么 <code>make parse</code> 时会将该文档的最新内容保存在db里，删除 <code>docpad</code> 和 <code>hatch</code> 的标签聚合页面，删除已经生成的所有包含 <code>docpad</code> 和 <code>hatch</code>标签的页面（包括自己），然后进入到第二阶段的页面生成。</p>
<h2>系统结构</h2>
<p>有了上面的思考，<code>hatch</code> 的系统结构也就付出水面，整个系统围绕着 <code>make</code> 展开，尽可能使用已有的unix工具（sorry，为了保证小而美，windows不在这样一个系统的考虑之列）。如果没有合适的工具，则撰写之。</p>
<p>可以直接leverage的工具：</p>
<ul>
<li>lessc/sass，用于生成css。</li>
<li>coffee，用于生成js。</li>
<li>yuicompressor，用于compress css和js。</li>
<li>jade，用于将jade template生成html。</li>
<li>marked，用于将markdown文件生成html。</li>
<li>js-yaml，用于parse metadata。</li>
</ul>
<p>需要撰写的工具：</p>
<ul>
<li>hatch-parse，用于parse一个文档，将中间结果存入数据库中。例如：<code>hatch-parse test.md</code>。hatch-parse会根据扩展名自动使用相应的parser。</li>
<li>hatch-gen，用于生成一个页面，生成过程中可能需要读取数据库。例如：<code>hatch-gen -o test.html test.md</code>，<code>hatch-gen -o index.html index.jade</code>。如果文章需要分页（定义了<code>&lt;!--page--&gt;</code>），则进行分页处理。</li>
<li>tag-gen，用于生成标签索引页。例如：<code>tag-gen -o hatch.html -t tag.jade hatch</code>。将会查询数据库中标签是 <code>hatch</code> 的文档，将其写入hatch.html。如果 <code>tag-gen -o &lt;dir&gt; -t tag.jade *</code>，将会生成所有标签索引。如果生成过程中需要分页，则进行分页。</li>
<li>index-gen，用于生成索引页。例如：<code>index-gen -o index.html index.md</code>。如果生成过程中需要分页，则进行分页。</li>
</ul>
<h2>数据结构</h2>
<p>我用过的 <a href="http://wintersmith.io">wintersmith</a>，<a href="http://docpad.org">docpad</a> 都使用memory db存放文档的中间结果，为特殊需求（如related documents）提供接口。由于采用 <code>make</code> 来组织整个系统，每个运行的命令都是自己的进程空间，所以无法用in process memory db，另外我也不希望每次build都重新生成这个DB，所以一个可以persistent的DB就是我的第一选择。考虑到我有如下需求：</p>
<ul>
<li>数据库中的字段来源于文档的metadata，所以随意性很大，必须schemaless。</li>
<li>需要支持一些复杂的查询，比如，找出6篇标签为：<code>hatch</code> 或 <code>tool</code> 的文档。</li>
</ul>
<p>所以权衡之后，本文决定使用mongodb来保存中间结果。当然，每次build时可能涉及很多次数据库的open/close，至于performance如何，只有实测后才有结论。</p>
<p>mongodb中存储的是文档（template无须存储），大概长这个样子（<code>createdAt</code>，<code>tags</code>，<code>ignored</code>，<code>src</code> 上建有索引）：</p>
<pre><code>{
    &quot;_id&quot;: ObjectId(`blablabla`),
    &quot;template&quot;: &quot;posts.jade&quot;,
    &quot;createdAt&quot;: ISODate(&quot;2013-10-30T20:20.000Z&quot;),
    &quot;updatedAt&quot;: ISODate(&quot;2013-10-30T20:25.000Z&quot;),
    &quot;tags&quot;: [&quot;hatch&quot;, &quot;tool&quot;],
    &quot;ignored&quot;: true,
    &quot;comments&quot;: true,
    &quot;cover&quot;: &quot;/assets/files/posts/hatch.jpg&quot;,
    &quot;src&quot;: &quot;/documents/posts/hatch.md&quot;,
    &quot;outputs&quot;: [&quot;/posts/hatch.html&quot;, &quot;/posts/hatch.1.html&quot;],
    &quot;title&quot;: &quot;Hello Hatch&quot;,
    &quot;rawContent&quot;: &quot;This is a great document\n\nHello hatch!\n&quot;,
    &quot;teaser&quot;: &quot;&lt;p&gt;This is a great document&lt;/p&gt;&quot;,
    &quot;content&quot;: &quot;&lt;p&gt;This is a great document&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;Hello hatch!&lt;p&gt;&quot;
}</code></pre>
<p>对应在磁盘上的文件是这个样子：</p>
<pre><code>---
template: posts.jade
title: Hello Hatch
date: 2013-10-30 20:20
tags: [hatch, tool]
comments: true
ignored: true
cover: /assets/files/posts/hatch.jpg
---

This is a great document

Hello hatch!</code></pre>
<p>这引入一个问题：当磁盘文件修改时，如何找到数据库中对应的文档？源文件名是少数不那么容易修改又具备唯一性的字段，所以在数据库文档中我们放入了 <code>src</code> 这个域。在 <code>makefile</code> 里，我们需要提供 <code>make dbclean</code>，以便用户在需要时，可以将数据库中的文档清除干净。</p>
<h2>实现</h2>
<p>从构思的角度，基本的障碍已经消除，大致的设计也有了，剩下的就是如何实现。这个周末，争取能把最基本的功能实现出来，然后在讨论实现过程中遇到的问题，看看和我的构思/假设有什么明显的偏差。</p>
<p>顺手做了个 Lean Canvas: <a href="/canvases/2013-10-30-hatch.html">hatch project lean canvas</a>，感兴趣可以看看。</p>
<p>这几天没怎么照相，还是送上之前照的一张照片：</p>
<p><img src="/assets/files/photos/baby20131030.jpg" alt="小宝快一岁了"></p>
<!--
* index-gen，用于生成索引页，比如说标签索引页，首页等。用户传入一个查询条件，和一个排序条件，从数据库中读取对应的数据，生成html。例如：index-gen -e '[{"q": {"tag": "hatch"}, "s": {"date": -1}, "name": "dataset1"}, ...]'  > hatch.html。

比如说我们要生成 ``index.html``。它通过 ``documents/index.md`` 和 ``templates/index.jade`` 生成，并能展示 ``documents/posts`` 和 ``documents/slides`` 目录下的最新10篇文章。
-->]]></description>
            <link>http://tchen.me/posts/2013-10-30-the-hatch-project.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-10-30-the-hatch-project.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Wed, 30 Oct 2013 14:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[觅珠人：浴火重生]]></title>
            <description><![CDATA[<p>很久没有更新博客了。最近几个月写了三篇文章：</p>
<ul>
<li>8月底：『软件公司如何有效地组织和运作?』</li>
<li>9月中：『班加罗尔初体验』</li>
<li>10月：『nodejs callback hell的解决之道』</li>
</ul>
<p>因为种种原因都烂尾，没有继续下去，所以也就没有发表出来。绵绵不断的工作压力和为人父的家庭责任让我心力交瘁，眼一睁一闭，一睁一闭的，一天天就过去了。</p>
<p>这两天闲逛hn时，无意中发现了 <code>docpad</code>，又一个静态网站生成器。由于我目前使用的 <code>wintersmith</code> 是一个hack版，将其升级到2.x太麻烦，而且随着我文章的增多，分页，标签管理等都成为麻烦事。在尝试了 <code>docpad</code> 后，我发现这是个好东西，干脆心一横，就把整个博客的底层系统升级过去了。</p>
<!--more-->

<p>看过我之前博文的童鞋可能注意到，我的博客自诞生起，历经 <code>wordpress</code> -&gt; <code>octopress</code> -&gt; <code>wintersmith</code> -&gt; <code>docpad</code>。原因很简单，我需要一款能够支持以下功能的静态网站生成工具：</p>
<ul>
<li>能使用 <code>markdown</code> 或任何其他语言撰写文章（posts）。</li>
<li>支持尽可能多的模板，如jade，haml。</li>
<li>能生成标签索引页。</li>
<li>能生成文章索引页。</li>
<li>索引页支持分页。</li>
<li>支持local server，能在本地展示生成出来的网站的感觉。</li>
<li>生成速度尽可能快（不要超过10s），并且不要做无意义的重复生成。</li>
<li>是CMS，而非blog engine。</li>
</ul>
<p>在这个过程中，我不断寻觅，不断更新工具，直到我找到了 <code>docpad</code>。除去对性能的要求外，<code>docpad</code> 满足我上述所有需求。</p>
<p>所以我便开始了艰难的升级之旅。由于本文非 <code>docpad</code> 入门文档，重点描述我升级遇到的问题，所以要学习 <code>docpad</code> 请移步：<a href="http://docpad.org。">http://docpad.org。</a></p>
<h2>模板</h2>
<p>这次升级，UI全部重写。我放弃了bootstrap 2，选择了bootstrap 3，亦即意味着完全放弃了IE7，基本放弃了IE8。我的博客读者并不很多，在百度统计中，IE7/IE8占比不到15%（IE7及以下不到1%），所以对整体用户影响不太大。</p>
<p>UI的设计购买自wrapbootstrap，花四十美刀买了个multiple license，很划算。如果从设计做起，我未必能做出这样的设计，而且短期内不可能升级完成。</p>
<p>购买后前端的主要工作就是把html变成template。由于 <code>docpad</code> 对 <code>eco</code> 支持比较好，所以我花了些时间学习eco。</p>
<h2>文档</h2>
<p>文档的改动主要在文件名和metadata上。<code>docpad</code> 借鉴了rails的pipeline，根据文件名判断该如何转化，比如：<code>test.css.less</code>，<code>eco</code> 会先通过 <code>eco</code> 处理转换成 <code>test.css.less</code>，再通过 <code>lessc</code> 转换成 <code>test.css</code>。</p>
<p>metadata的转换主要是 <code>wintersmith</code> 和 <code>docpad</code>的命名不同，比如：</p>
<pre><code>---
template: default.jade
published: false
---</code></pre>
<p>在 <code>docpad</code> 中需要转换为：</p>
<pre><code>---
layout: default // default.html.eco
ignored: true
---</code></pre>
<p>这都不是什么大问题。</p>
<h2>分页</h2>
<p>之前的博客不支持分页，在首页我塞了40篇文章。如果我的博客超过了40篇文章，那么之前的就无法被直接索引到。使用 <code>docpad</code> 后，只要安装 <code>paged</code> 插件，并按例子写一小段代码，就能完美支持分页：</p>
<pre><code>$ docpad install paged</code></pre>
<p>我写的支持分页的partial：</p>
<pre><code>&lt;% if @document.page.count &gt; 1: %&gt;
&lt;ul class=&quot;paginator text-center&quot;&gt;
    &lt;!-- Previous Page Button --&gt;
    &lt;% unless @hasPrevPage(): %&gt;
        &lt;li class=&quot;disabled&quot;&gt;&lt;span&gt;上一页&lt;/span&gt;&lt;/li&gt;
    &lt;% else: %&gt;
        &lt;li&gt;&lt;a href=&quot;&lt;%= @getPrevPage() %&gt;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;
    &lt;% end %&gt;

    &lt;!-- Page Number Buttons --&gt;
    &lt;% for pageNumber in [0..@document.page.count-1]: %&gt;
        &lt;% if @document.page.number is pageNumber: %&gt;
            &lt;li class=&quot;active&quot;&gt;&lt;span&gt;&lt;%= pageNumber + 1 %&gt;&lt;/span&gt;&lt;/li&gt;
        &lt;% else: %&gt;
            &lt;li&gt;&lt;a href=&quot;&lt;%= @getPageUrl(pageNumber) %&gt;&quot;&gt;&lt;%= pageNumber + 1 %&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;% end %&gt;
    &lt;% end %&gt;

    &lt;!-- Next Page Button --&gt;
    &lt;% unless @hasNextPage(): %&gt;
        &lt;li class=&quot;disabled&quot;&gt;&lt;span&gt;下一页&lt;/span&gt;&lt;/li&gt;
    &lt;% else: %&gt;
        &lt;li&gt;&lt;a href=&quot;&lt;%= @getNextPage() %&gt;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;
    &lt;% end %&gt;
&lt;/ul&gt;
&lt;% end %&gt;</code></pre>
<h2>标签</h2>
<p>在 <code>docpad</code> 里支持标签很容易，安装两个plugin就好：</p>
<pre><code>$ docpad install related
$ docpad install tagging</code></pre>
<p>前者提供『相关文档』的功能，后者能生成类似 <code>/tags/:tag</code> 的索引页。</p>
<p>我们先看如何显示相关文档：</p>
<pre><code>&lt;div class=&quot;widget widget-cats&quot;&gt;
  &lt;h4 class=&quot;widget-title&quot;&gt;
    相关文章
  &lt;/h4&gt;
  &lt;ul&gt;
    &lt;% if @document.relatedDocuments : %&gt;
    &lt;% for document in @document.relatedDocuments: %&gt;
      &lt;li&gt;&lt;a href=&quot;&lt;%= document.url %&gt;&quot;&gt;&lt;%= document.title %&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;% end %&gt;
    &lt;% else : %&gt;
      &lt;li&gt;&lt;a&gt;无&lt;/a&gt;&lt;/li&gt;
    &lt;% end %&gt;
  &lt;/ul&gt;
&lt;/div&gt;</code></pre>
<p>这样，只要文档中使用了 <code>tags: [tag1, tag2]</code> 这样的metadata，所有定义了 <code>tag1</code> 或 <code>tag2</code> 的文章就被聚合在此。</p>
<p>生成标签索引页也不难，只要做一个template：</p>
<pre><code>---
layout: default
---
&lt;div class=&quot;container&quot;&gt;
    &lt;h1&gt;文章列表：『&lt;%= @document.tag %&gt;』&lt;/h1&gt;
    &lt;hr/&gt;

    &lt;ul&gt;
    &lt;% for doc in @getCollection(&#39;documents&#39;).findAll({tags: &#39;$in&#39;: @document.tag}).toJSON(): %&gt;
        &lt;%- @partial(&#39;posts/post_loop_item&#39;, {item: doc}) %&gt;
    &lt;% end %&gt;
    &lt;/ul&gt;

&lt;/div&gt;</code></pre>
<p>显示效果如：<a href="http://tchen.me/tags/technology.html。">http://tchen.me/tags/technology.html。</a></p>
<h2>问题</h2>
<p><code>docpad</code> 功能很强大，但其速度让人难以忍受。之前 <code>wintersmith</code> 生成全站只需要3s左右，<code>docpad</code> 则要40s。而且</p>
<p>为了加快速度我做了很多尝试：</p>
<ol>
<li>使用standalone metadata。<a href="https://docpad.org/docs/meta-data。效果一般，很多地方不适用，而且在诸如app.css.less里加这么个东西很不伦不类。">https://docpad.org/docs/meta-data。效果一般，很多地方不适用，而且在诸如app.css.less里加这么个东西很不伦不类。</a></li>
<li>对静态文件使用raw plugin。效果不明显，我往raw目录中拷一个文件还会trigger regenerate。</li>
<li>停用live-reload插件。我不希望加了一个回车，保存后就要话40s才能访问本地服务器。</li>
<li>使用 <code>docpad watch</code>，而不是 <code>docpad run</code>，同时启动一个 <code>python -m SimpleHTTPServer 8210</code>，来serve静态文件。这样，改动能够被重新生成，且生成时我还能浏览已有的页面。</li>
</ol>
<p>但这些都不太理想。<code>docpad</code> 蠢到我改一行less，整个网站就全部重编。你可想而知在迁移阶段我有多少时间耗费在等待中。</p>
<p>于是我把所有的静态文件都拿出来放在 <code>src</code> 外，不让 <code>docpad</code> 干蠢事。完全抛弃 <code>raw</code> 插件，我写了个几行的 <code>Makefile</code> 干这些事：</p>
<ul>
<li>将less生成css，并使用yuicompressor压缩。</li>
<li>将js用yuicompressor压缩。</li>
<li>将整个 <code>raw</code> 目录rsync到 <code>out</code> 目录。</li>
</ul>
<p>在 <code>raw</code> 目录下的Makefile如下：</p>
<pre><code>CHECK=\033[32m✔\033[39m
DONE=&quot;\n${CHECK} Done.\n&quot;
ECHO=echo
ROOT=assets

CSS_COMPRESSOR=lessc
JS_COMPRESSOR=yuicompressor
SYNC=rsync
CAT=cat
RM=rm

CSS_PATH=$(ROOT)/less
CSS_SOURCE=$(CSS_PATH)/app.less

JS_PATH=$(ROOT)/scripts
JS_PLUGIN_PATH=$(JS_PATH)/plugins
JS_SOURCE=$(JS_PLUGIN_PATH)/jquery.js $(JS_PLUGIN_PATH)/bootstrap.min.js $(JS_PLUGIN_PATH)/jquery.visible.min.js $(JS_PLUGIN_PATH)/jquery.isotope.min.js $(JS_PLUGIN_PATH)/jquery.knob.js $(JS_PLUGIN_PATH)/jquery.scrollUp.min.js $(JS_PLUGIN_PATH)/highlight.pack.js $(JS_PATH)/application.js

CSS_TARGET=$(ROOT)/css/app.min.css
JS_TARGET=$(ROOT)/js/app.min.js

SYNC_TARGET=../out


sync: $(CSS_TARGET) $(JS_TARGET)
    $(SYNC) -au --exclude $(CSS_PATH) --exclude $(JS_PATH) --exclude Makefile . $(SYNC_TARGET)
    @$(ECHO) $(DONE)

$(CSS_TARGET):
    $(CSS_COMPRESSOR) $(CSS_SOURCE) --yui-compress  &gt; $(CSS_TARGET)

$(JS_TARGET):
    @$(CAT) $(JS_SOURCE) &gt; tmp.js
    $(JS_COMPRESSOR) -o $(JS_TARGET) tmp.js
    @$(RM) tmp.js

clean:
    $(RM) -f $(CSS_TARGET) $(JS_TARGET)</code></pre>
<p>在根目录下的Makefile如下：</p>
<pre><code>generate:
    docpad generate
    @cd raw; make; cd ..

deploy:
    cd out; make; cd ../..

clean:
    cd raw; make clean; cd ../..</code></pre>
<p>这样，css/js的改动和 <code>docpad</code> 完全没关系，<code>docpad</code> 只需要帮我生成文档即可。这样下来，60%的修改都能够在1s内完成。剩下40%的修改，耗时稍微少了一些，可还要用三十多秒。没有本质差别。</p>
<h2>部署</h2>
<p>强烈不建议使用 <code>ghpages</code> 插件部署。我安装了这个插件，也使用了，但使用第二次的时候就将其卸载了。原因很简单：每次 <code>git push -f</code> 全部重新push，写这个plugin的作者之前没生成过大一些的网站吧？我的博客现在几十篇文章，不足百张图片，总共几十M的repo，每次都全部重新push要十多分钟，一天push十几次我还干不干活了？</p>
<p>所以还是自己解决部署问题吧：</p>
<pre><code>$ rm -rf out
$ git clone &lt;your repo url&gt;
$ make deploy # 这个我已经做进了上文中的Makefile中</code></pre>
<p>在要部署的repo中添加一个Makefile:</p>
<pre><code>DATE=$(shell date)
CHECK=\033[32m✔\033[39m
DONE=&quot;\n${CHECK} Done.\n&quot;

deploy:
    @echo &quot;Deploy the blog to github pages.&quot;
    git add --all .
    git commit -a -m &quot;Deploy to github pages on $(DATE).&quot;
    git push
    @echo $(DONE)</code></pre>
<p>也是简单之极。</p>
<h2>心得</h2>
<p>这次博客升级花费了我两个晚上和一个周日。按我晚上9点开工到12点，周日工作了至少6小时，总共耗时12+小时，耗资USD40。</p>
<p><code>docpad</code> 是个功能丰富的工具，值得试用，但要忍受极慢的编译速度。撰写者（尤其是plugin的撰写者）显然水平一般，不懂得用unix的设计哲学来设计这样工具。</p>
<p>在经历了这么多工具后，我有强烈的意愿写一个自己的静态网站生成器，来更好地支持我的需求。想法很简单：</p>
<ol>
<li>使用Makefile和现成的工具完成静态文件的处理。</li>
<li>高度组件化 - 撰写小脚本来完成单一的功能。用Makefile粘合这些脚本。</li>
<li>脚本解析的中间结果存储在redis/mongodb中，供其他附加功能使用，比如tagging/paging。</li>
<li>任何一个工具可以对全站使用，也可对部分文件使用。</li>
<li>尽可能并发处理，全站的生成速度控制在秒级。</li>
<li>如果可以，提供development模式，动态生成当前访问的页面。</li>
</ol>
<p>送上小宝近照一张。</p>
<p><img src="/assets/files/photos/baby20131028.jpg" alt="小宝"></p>
]]></description>
            <link>http://tchen.me/posts/2013-10-28-blog-reborn.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-10-28-blog-reborn.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Mon, 28 Oct 2013 14:40:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[长日无痕]]></title>
            <description><![CDATA[<h2>（一）</h2>
<p>又是一个闷热的周六，灰霾就像粘在天空一样，依旧笼罩着这个城市。带着小宝，我们三人游荡在蓝色港湾的儿童城中，为小家伙的未来打算着。老婆和丈母娘穿梭于一个又一个玩具店，而我，因为推着童车，不便走来走去，就带着小宝静静地欣赏楼下冰场里玩耍的孩子们。很快，我们的注意力就被冰场上两个正在进行对抗训练的小男孩吸引住了。小宝快乐地随着冰球转动脖子，双眼紧紧地捕捉着黑色的冰球，不时发出愉悦的『喝彩』；而我，默默地看着两位『男子汉』一次次跌倒，又一次次爬起，对抗虽然异常激烈，但任何一方都没有脏动作，这足以让真正的冰球赛场上的成年人汗颜。</p>
<!-- more -->

<p>连日来，对环法自行车赛兴奋剂丑闻的追踪报道，让曾经的英雄们纷纷落马。成人世界里，人们对于名利的渴望，对成功的追逐已经远远超出了能力或是道德的底线。我们不得不承认，这个世界正变得越来越浮躁。会爬的恨不得立即会走，踉踉跄跄走着的，又恨不得能撒腿就跑。前两天我在卓越亚马逊上随便查了查『小时学会』和『天学会』，结果发现分别有65条和157条结果之多。『Java程序设计24小时轻松掌握 』，『21天学会javascript』，『30天学会Visual C++』，...看着那列出的一大堆需要花很大力气学习和使用的语言，我不得不感慨这种浮躁已经无处不在。</p>
<p>小宝还在咯咯地乐。那种发自内心的，如雪花般洁净的快乐让我由衷地羡慕。如果不是上周日LP跟我严肃地讨论了一下在未来我如何更好地履行父亲的责任，此刻（周六的下午）我应该端坐在办公室里思考某段代码该如何去写，而不是在这样一个放松的环境下，任由我的思想翱翔。</p>
<p>我们讨论的结果是，一周里大礼拜我能不去公司工作就不去，并且工作日最好有两天赶在七点前回到家，这样，可以大大增加我在家中陪伴小宝的时间，提升她对『父亲』这个角色的认知。在北京这样一个拥挤到几乎处于崩溃边缘的城市，以公司到我家长达三十五公里的距离来算，晚上七点前回到家就意味着至少提前两个从公司出发，还得祈求一路上 1）没有事故（小概率事件），2）没有管制，3）没有幽灵堵车。两个小时的车程对很多北京人来说还在忍受的极限内，但对我来说，开车上/下班的时间超过一小时我就已经浑身难受，更遑论两小时这一让人绝望的数字。所以，我决定在提前回家的那两天搭乘地铁，这样，只消花一个半小时，我就能回到家中；而且，在地铁里，我可以暂时远离代码和互联网，翻几十页和技术毫不相干的书。巧的是，上周不开车的两天上下班时间里，我翻的书是《长日留痕》——一本我买了很久，翻了几次却都没看进去的小说。史蒂文斯先生，书中的主人公，利用一次旅行的机会回顾了他漫长的管家生涯。在整部书中，他始终在回忆过去的人生，并且不断地探讨一个严肃的问题：一位杰出的男管家究竟是什么样子的？</p>
<p>感谢这本书，让我开始严肃地回顾我自己的职业生涯。这思考断断续续游走了好几天，很多时候干脆藏身在潜意识中，以至于每每我工作累了，对着窗外中关村东路和成府路交叉的路口发呆时，它就会蹦出来，让我暂时从繁重的工作中解脱出来，在回忆中尽情徜徉。</p>
<h2>（二）</h2>
<p>教练一声哨响，把我暂时拉回。此时此刻，两个小家伙开始了一攻一守的对抗，场面也变得好玩起来——两个小愣头青从场地的两端以几乎相同的路线滑向中圈，砰的一声，重重地撞到了一起，一同倒地。教练上前，把攻方的小家伙拉到一旁耳语几句，并比划了几下，随即恢复了比赛。两人从场地的两头快步冲向中圈，守方将重心控制地很低，高速滑动中，目不转睛地盯着冰球。就在两人要接触的一刹那，攻方一个急停，然后迅速切向斜前方。由于扑得太猛，守方来不及调整，无奈让攻方轻松绕过自己，打进一球。不知是看懂了比赛，还是单纯开心，小宝挥舞着双手，发出欢畅的尖叫声。</p>
<p>这就是教练的作用。他们告诉你什么是基本功，如何应对局势，以及一名优秀的球员应该具备什么素养。在一个人职业生涯的早期，一位好的导师比什么都重要。一晃我的程序员生涯已经过去了十年，在这十年里，我一直在不断探索<strong>一位优秀的程序员究竟该具备什么素养</strong>，如果当时有个教练能给予我指导，给予我探索的方向，那该多好啊。</p>
<p>可惜没有。软件行业没有教练，也没有拜师学艺的传统。也许曾经有，但自从程序员从手工艺人变成了工程师，教练或者师傅就不再重要。你基本不需要像手工艺人那样具备从无到有做出点什么的技术，你需要的仅仅是解决某个或者某些特定问题的能力 —— 某种意义上说，这和流水线上的工人并无二异。这也导致了那些速成的图书的畅销，因为它们试图让你学习到的是<strong>如何完成任务，而非如何编程。</strong>当然，互联网正在粉碎这一切，程序员似乎又在回归手工艺人的传统，这很好。</p>
<p>虽然没有教练，但每个软件公司基本都会为新员工指定一名资深的同事提供『象征』意义上的 &quot;mentor&quot;。我说『象征意义』，并不是否定mentor的作用，而是说这些mentor并非职业化的mentor，『传道授业解惑』的为师之道，mentor们勉强在解惑上提供了些许帮助。当然，对于公司来说，mentor最重要的作用是成为一个榜样（Role Model），通过他们的工作态度，工作习惯，工作能力，对新员工，尤其是处在职业生涯早期的员工产生潜移默化的影响。</p>
<p>我职业生涯起始的公司是神州数码网络公司（DCN）。如果将google或者twitter定义为『优秀』公司，那么，DCN显然处在平庸公司的行列。好在DCN继承了老联想的底子，还有一批有理想的做系统的牛人。Z君就是这样一个人。碰巧我被分在了他所在的团队。当我把『一位优秀的程序员究竟该具备什么素养』这样的问题抛给我的mentor，即将离职的X君时，他让我多看，多学Z君。之后，有意无意地，我都会多去劳烦Z君，他总会抛开手头的事，爽快地为我答疑。为了解决某个问题，他经常工作到深夜；跟他讨论代码如果没揪到根上他绝不善罢甘休。拿code review来说，当你看到一堆逻辑上无比正确但写作上WTF的代码时，即使想骂娘，但屈服于release的压力或人情世故，你总会妥协。但Z君不太会妥协。他会笑眯眯地，毫不留情地指出你代码上十多处毛病，让你整改。很多人认为代码逻辑对了就足够，但Z君期待代码（算法）在时间空间上的合理（和谐），以及是否做到了SoC。工作之外，他又是个吊儿郎当的人，经常爆发出的爽朗的笑声，浑身浓重的烟味，让你即使在很远的地方，也能感受到他独特的气场。</p>
<p>从Z君身上，我找到了一直追寻的问题的第一个答案：</p>
<p><strong>真心喜爱你所做的事情。</strong></p>
<p>真心喜爱你所做的事情。之所以斟酌出这个句子，是因为我觉得诸如『敬业』，『有韧劲』，『钻研』，『爱学习』等词语或多或少都被它涵盖，或者说，是它的自然而然的结果。</p>
<p>那时对我而言，『真心喜爱』就意味着每天超过12个小时泡在公司里努力搞明白遇见的每一个技术问题。很快，我搞透了OSPF，填补了X君走后OSPF上的空缺，之后又独立开发了IGMv3，SNTP，接着完成了极其重要的linux 2.4 kernel的移植。</p>
<h2>（三）</h2>
<p>由于工作的原因，我逐渐与另一个团队的S君打交道很多。S君兴趣很广，他帮着公司内部搭建了团队的wiki，使得信息的交流，知识的分享大大地系统化。以前我们知识的交流以邮件为主，这很被动，当下有用的，还是无用的知识，都一股脑成了一封封亟待打开的邮件。打开看吧，浪费时间；不打开吧，以后需要时都不知道自己的邮箱里还有这么份东西。在S君的推广和维护下，团队的wiki大大提高了大家获取知识的效率。</p>
<p>从S君那里得知，他使用了一个叫mediawiki（wikipedia使用的软件）的开源软件。我开始把玩mediawiki，进一步，我接触了LAMP，并且逐渐意识到像linux，Mediawiki这样的开源软件的重要性。如果说林则徐魏源是近代中国开眼看世界的第一人，那么他也许是DCN内部拥抱更广阔的世界的第一人。做system的，很少关注application的动向，有种天朝藐视番邦的傲娇；而做application的，则放低姿态谦卑地注视着system的变化。现在随便拉一个做路由器的人，你问问他对web application的看法，十有八九还停留在对LAMP的认知上；而做web application的人已经把触角伸向了user space data plane。究其原因，是做system越做越掌控一切，倾向于封闭；而做application越做越依赖生态圈，所以拥抱开放。</p>
<p>S君让我认识到了开源的力量和开放的社区的伟大之处。怀着对mediawiki的敬畏，我开始学习PHP，进而在他的影响下，学习据说是『聪明的程序员』使用的Python。我想我已经是『真正的程序员』了，如果能成为『聪明的程序员』，何乐而不为？</p>
<p>在这个过程中，我找到了第二个答案：</p>
<p><strong>拥抱开源和自由软件，拥抱社区。</strong></p>
<p>大学期间，我曾经是一个坚定的微软主义者：凡是微软推出的，我都拥护；凡是微软反对的，我都反对。直到毕业时，我还天真的认为C#就是我们这代程序员的终极武器。S君及时把我从这种盲从中拉了出来，让我看到了一个不一样的世界。现在棱镜门事件的热度在渐渐褪去，但是，它让人们开始意识到Richard Stallman的思想的重要性：<strong>开源软件关乎着人类的自由。</strong>遗憾的是（也许我不该这么评价），我的两任雇主，对开源软件的贡献要远小于其索取。</p>
<p>PHP和Python对于我所做的开发任务似乎毫无帮助，学习它们地目的是为了了解更广阔的世界，了解为什么最流行的软件会被用这样的语言开发出来。为了更好的实践我的所学，我用PHP和Python做了一个工具：开发人员可以通过一个PHP撰写的web页面提交一项测试任务，后台的python脚本拿到这个任务后会拉下指定版本的代码，编译，并将编译好的image传到直连的交换机上，然后开始运行测试团队提供的regression脚本。我的工具带来的效率的提升引起了老板的重视，我被批准使用一台PC和两台交换机，组成一个完整的环境，供开发团队践行CI（Continuous Integration）。</p>
<p>在这个过程中，我发现了第三个答案：</p>
<p><strong>能够通过自身所掌握的技术，不断提高自己和团队的效率。</strong></p>
<p>容我再解释两句。一个真正的程序员，在那些每天重复低效的干活方式展现在你面前时，很难抑制住利用自己的技能做点什么改变现状的心情。工作中（当然生活中也是），这样的低效比比皆是。比如说从X系统中定期导出一些数据到excel中做报表，比如说一级一级收集weekly report进行工作汇总。</p>
<p>这种低效在我工作过的第二家公司，Juniper，也广泛存在。</p>
<p>回顾我目前的整个职业履历，我在DCN工作了两年零两个月，在Juniper China R&amp;D(CNRD)工作了五年半，在途客圈作为创始人和CTO工作了两年，然后回到Juniper CNRD工作至今。所以，作为雇员，我总共就工作过两家公司，因此，是否每家软件公司都存在类似的低效，我不得而知。但我觉得，工作中的低效场景无处不在，问题在于有没有被发现，发现后值不值得为此做点什么。</p>
<h2>（四）</h2>
<p>冰球场上的对抗结束了，小家伙们离场休息去了。我松开手上的童车腕带，把脑袋凑过去，轻唤小宝的名字。小宝显然还全神贯注于冰场，被我这突然的举动吓了一跳。当她惶恐地转过头来看到是我，便放下心来，微微笑了笑，又回过头去欣赏冰场上的运动。循着她的目光，我看到冰场上一个也就六七岁大的小女孩一个人在认真地练习花滑。她的动作如此纯熟，姿态那么优美，让你几乎忘了她的年龄。我想，她大概这么练了有很长一段时间了吧。</p>
<p>看到这里我不禁想起在Juniper曾经跟Y君讨论过我们招人的准则。我不解为何我们不给年轻员工，甚至应届毕业生一些机会。Y君认为我们需要的是专家，而某个领域的专家，根据研究，需要经过10000个小时的培养。我算了一下，假使每周四十个小时，一年五十周扑在某个或者某些特定的领域，那么，五年的时间就可以造就一个专家。这也是为何很多公司对于senior的职位，都要求至少五至七年的相关工作经验。但现实是，在面试中，很多五年，甚至十年工作经验的人都未必对得起自己逝去的年华。我曾经遇见过一个工作了8年之久的程序员，在提供了vim，gcc等编辑编译环境的情况下，连一个非常简单的链表操作的程序都无法正确完成。这是怎么回事？</p>
<p>我查了查&quot;10,000 hour rule&quot;的原文，是这么说的 —— &quot;it takes approximately 10000 hours of deliberate practice to master a skill&quot;。</p>
<p>问题出在了<strong>&quot;deliberate practice&quot;</strong>上。</p>
<p>何谓&quot;deliberate practice&quot;？钢琴考级有九个等级，每个等级都有要求的技法和曲谱。这是一系列刻意设计的练习，每一个级别都比上一个难度大一些，但经过努力还是可以掌握的。当你对车尔尼驾轻就熟后，可以尝试一点巴赫，也许也可以是贝多芬，但绝不能倒着来，也不能跳着来。跳着来意味着你当前的水平和期望的结果之间的鸿沟太大，也许已经超过了单凭努力就可以到达的境地。</p>
<p>可惜软件行业鲜有这样的&quot;deliberate practice&quot;，学校和培训机构也没有类似的体系。所以这个社会能够批量造就钢琴9级获得者，却无法批量培养出合格的程序员。很多拥有五年工作经验的人，折合成有效的经验，也许就只剩一年，剩下的四年只不过在重复自己第一年的收获。这就好比一个人掌握了车尔尼《钢琴简易练习曲》后，还在刻苦反复练习相同的内容，即使练到脱离曲谱信手拈来，又有何用？</p>
<p>想想我们的境地，挺悲惨的。没有合适的导师指引方向，没有成型的体系来培养专家。但是我们还得不断地学习，不断地更新知识。对于那些还尚未『开窍』的程序员来说，职业生涯就像《富爸爸穷爸爸》所谓的老鼠赛跑，在蹉跎中耗尽光阴。</p>
<p>所以自我救赎的最好方法就是不断地给自己增加挑战，让自己脱离舒适区域。具体方法是：用那些刚好超过自己能力的任务挑战自己，build（尝试） - measure（分析） - learn（学习总结）。然后不断重复。这是lean startup一书中建议的精益创业模式，同样也适用于这个场合。</p>
<p>不要去看那些多少小时或者多少天就能掌握XYZ的书。生命苦短，多读读大师的著作和文章，他们能让你跨越到新的台阶；多写代码，多写能让你有征服感的代码。</p>
<p>这就是我找寻到的第四个答案：</p>
<p><strong>不断跳出舒适区，有目的地挑战自己。</strong></p>
<p>让我倍感欣慰的是，在Juniper的这五年半时间里，公司提供了各种机会让我在三个不同的team里学习和掌握data plane，kernel，以及application。托L君rellocate到US的福，我还有机会lead一支团队，来践行我在leadership上所学的理论知识。</p>
<p>冰场里依旧人声鼎沸。怕寒气把小宝冻着，我不敢在此过度停留，我把车推着往里靠了靠，坐在一张椅子上稍稍休息。小宝举着双手似乎在抗议，但当她发现从她坐着的角度依旧能看到冰场的一角时，就渐渐安静下来，双手自然搭在童车的护栏上。</p>
<p>说来好笑，就在我离开Juniper的前夕，L君主持了一场小规模的英文演讲训练，以此来提高manager们用英文当众发言的能力。我的主题就是&quot;Move yourself out of comfort zone&quot;。后来偶然的机会，我遇到了同样也离开Juniper的L君，他说他那时就感到我要离开。我问为什么。『因为CNRD对你而言已经成为一个confort zone，你只需不犯错误，静静等待，就能一点点向上爬，而这又和你的性格，尤其是你的演讲传达出来的感觉不同。』L君回答道。</p>
<p>想想也真是。我的性格里流淌着不安分的血液，它源自我的父亲。一九九三年，父亲只身前往海南和广东，像那个时代的所有朝气蓬勃的年轻人一样，希望能够在改革开放的最前沿，寻找工作机会，潇洒走一回。和其他人不同的是，父亲当时已接近不惑之年，有家有口，还捧着医生这样一个金饭碗。如今我已过而立，晋升为爷爷的父亲年逾古稀，在这个本该安享天年的时刻，仍然奋斗在第一线，业余时间还以编者的身份出了个人的第一部书，同时正在紧张地编撰第二部。父亲就是我的榜样，能够全面超越他是我的一大理想（当然这也是一个达尔文主义者必须做到的，总不能一代更比一代差吧^_^），可惜至今我还未能完成这一理想。</p>
<h2>（五）</h2>
<blockquote>
<p>A language that doesn&#39;t affect the way you think about programming, is not worth knowing.  - Alan Perlis</p>
</blockquote>
<p>离开Juniper，我选择了创业，创建了途客圈。那是一段奇妙的旅程，一段让我成熟很多的征途。有史以来第一次，我写软件，不是为了我的雇主，我的payroll，而是为了我的梦想。虽然这段旅程仅仅走了两年我就不得不因为一些个人的原因选择了自我放逐，但这两年，如乔帮主所言，是我开始去连接那一个个&quot;disconnected dots&quot;。我的编程水平开始极大地发展，我的软件开发思想在不断走向成熟，我越来越觉得自己像是一个真正的程序员了。</p>
<p>重要的是，我开始学习新的语言了。你也许注意到，自从从DCN学习了PHP和Python后，在Juniper我就不再学习新的语言了，部分原因是我在夯实我这两门语言的水平，尤其是Python的水平，但更关键的原因是我开始固步自封了。C让我成为真正的程序员，Python让我成为聪明的程序员，我似乎找不到继续学习新语言的理由。</p>
<p>但是，创业改变了这一切。我不得不学习javascript，因为这是客户端唯一的标准。尽管在十多年前我就接触了javascript，并用它做过一些效果，但那时对javascript的使用，与其说是使用，不如说是误用。在途客圈，我才真正重新认识这门prototype based language。另外，为了权衡究竟什么样的架构更利于未来的发展，我花了很多功夫深入了解ruby，在ruby和python之间进行对比。通过《松本行弘的程序世界》，我了解了设计ruby时的很多思想。尽管途客圈最终选择了python/django，但这是一次非常有益的对比和思考，它让我进一步找到了第五个答案：</p>
<p><strong>学通超过一种编程语言，了解尽可能多的编程语言及其优劣，知道解决某个问题的可能的最佳路径。</strong></p>
<p>注意学通和学会是两个概念。学会意味着你能够使用这门语言，会写程序，而学通则意味着更多：</p>
<ul>
<li>了解语言被创建之出的动机，深刻理解语言背后的<strong>思想</strong>。</li>
<li>掌握如何在线调试（online debugging）和事后分析（coredump analysis）。</li>
<li>掌握语言外延/周边的技术。如JVM之于java，OS/CPU EABI之于C。</li>
<li>掌握如何提升关键代码的效率，如何能够扩充语言的能力。如NIF之于Erlang。</li>
<li>...</li>
</ul>
<p>很多在简历中号称精通C的人不知道malloc背后都发生了什么，精通Python的人却无法用meta programming写出干净漂亮的代码。这样的精通其实也就是勉强学会。</p>
<p>按照这个标准，摸爬滚打了十年后，我在C语言上勉强算学通，Python和Javascript只能说学会，Erlang/Ruby刚算了解。</p>
<p>容我再解释一下为何要了解尽可能多的编程语言极其优劣。比如说新开发的软件并发模式要采用STM（Software Transactional Memory），如果在技术选型前，你知道clojure在语言层面，haskell在GHC层面实现了STM，那么，你的选择可能不会局限于你之前所用的语言。</p>
<h2>（六）</h2>
<blockquote>
<p>总而言之，现在完全不可能让时钟倒转了。你不能永远总是对过去也许会发生的事耿耿于怀。你应该认识到你与大多数人一样地过得很好，或许还要好得多，那就应该心满意足了。  - 《长日留痕》</p>
</blockquote>
<p><br/></p>
<blockquote>
<p>Life is short, 
[the] craft long, 
opportunity fleeting, 
experiment treacherous, 
judgment difficult. 
  - Hippocrates</p>
</blockquote>
<p>也许是之前的凝视耗费了太多的精力，小宝开始打着哈欠揉眼睛。她回过头来，张开双臂，满眼期待地望着我。我知道，小家伙想要抱抱了。</p>
<p>十年前我根本无法想象十年后我能如此幸运而又意外地拥有她，正如十年后我无法预料她会变成什么样子。我可以为我的职业生涯，还有她的人生做&quot;deliberate&quot;的打算，但我无法控制结果。过去的十年，我遇到了很多很多十字路口。就像《长日留痕》里说的那样，『你不能永远总是对过去也许会发生的事耿耿于怀』。重要的是，我做出了选择。我很高兴我的人生经历与大多数人一样丰富，或许还要丰富得多，我很高兴我有很多很多故事讲给我的孩子听。</p>
<p>哦，忘了说另外一个答案，也就是第六个 —— 当然，仅仅对非英语母语的人有效：</p>
<p><strong>能用英文自如地阅读，写作和交流。</strong></p>
<p>一位优秀的程序员究竟该具备什么素养？</p>
<p>在用了近8年的vim之后，我决定，尝试emacs。</p>
]]></description>
            <link>http://tchen.me/posts/2013-07-27-the-remains-of-the-day.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-07-27-the-remains-of-the-day.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Sun, 28 Jul 2013 04:24:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Why should C programmers learn Erlang?]]></title>
            <description><![CDATA[<h2>Prologue</h2>
<p>If somebody says X language is better than Y language, usually there will be a fierce quarrel between two sides. If you&#39;re using certain language for a long time, you will be the evangelist of that language, and try to protect it unconsciously. Admitted or not, you have been trapped in a tunnel, that what you can see is constraint greatly. &quot;The Shawshank Redemption&quot; gives a good footnote on it:</p>
<p><img src="/assets/files/snapshots/institutionalized.jpg" alt="institutionalized"></p>
<blockquote>
<p>[Red] These walls are funny. First you hate &#39;em, then you get used to &#39;em. Enough time passes, you get so you depend on them. That&#39;s institutionalized.</p>
</blockquote>
<p>So before we&#39;re institutionalized too deep, let&#39;s learn something completely different - a language that not derived from C family, a language that leads you to a totally different mindset.</p>
<p>Erlang seems to be a good candidate.</p>
<!-- more -->

<h2>Why Erlang?</h2>
<p>Erlang is a languages more than 20 years old, developed initially by Ericsson, for the purpose of their &quot;next-gen&quot; switch. It&#39;s a really weird language with &quot;clumsy&quot; grammar which mixed with the functional programming into Prolog. However it adopts almost the best design philosophy, which is still ahead of the current era at least 10 years. Let me show you gradually.</p>
<h3>No side effects (almost)</h3>
<p>As a functional programming language, Erlang eliminates the shared states. Variables can only be bound to, but not changed. </p>
<pre><code>1&gt; X = 1.
1
2&gt; X = X + 1.
** exception error: no match of right hand side value 2
3&gt; X = 2.
** exception error: no match of right hand side value 2</code></pre>
<p>This makes sure that you can write functions that has no side effects - which means, with the same parameters, even if you call the function a thousand times the return value is the same. Writing code that has no side effects is a fundamental advantage in Erlang, it has these benefits:</p>
<ul>
<li>There&#39;s (almost) no critical sections you need to protect. Think of C code under concurrent environment, you have to use various synchronous primitives to prevent data from corruption. Poor synchronization leads to poor performance and instability of the system. This is a great headache for C programmers.</li>
<li>It makes low level optimization easier. The compiler can aggressively optimize the register usage since it knows once a variable is set it will not be changed.</li>
<li>It makes garbage collection easier. Think of poor Java VM. To determine if a variable is garbage or not is not a easy thing since it might be reference by others, and it might be used or changed later. But Erlang not. A variable is only in the scope of the outer function. Nobody else will use it. Nobody will change it. (read more about <a href="http://stackoverflow.com/questions/10221907/garbage-collection-and-memory-management-in-erlang">Erlang garbage collection</a> if you&#39;re interested).</li>
</ul>
<h3>Asynchronous / Concurrent built in language</h3>
<p>Erlang has built-in support of concurrent / asynchronous in its language. The theory backed Erlang&#39;s idea is <a href="http://en.wikipedia.org/wiki/Actor_model">Actor Model</a>. This is a great vision in 1986 since at that time multi-core, multi-thread, or even SMP is not a known terminology.</p>
<h4>Light weighted process</h4>
<p>To support concurrent, Erlang has its own light weighted process on its VM. You can spawn tens of thousands of processes simultaneously without hitting the limitation of the OS. Furthermore, the creation of the processes are super-fast - <a href="http://www.lshift.net/blog/2006/09/10/how-fast-can-Erlang-create-processes">350,000Hz for an old Pentium 4 CPU</a>. The memory footprint of Erlang process is quite small - in the granularity of kilobytes (minimum ~300 bytes), rather than megabytes for OS level processes. As for scheduler, Erlang support soft realtime scheduler, and the cost of context switch is very low - <a href="http://stackoverflow.com/questions/2708033/technically-why-is-processes-in-Erlang-more-efficient-than-os-threads">Switching between processes, takes about 16 instructions and 20 nanoseconds on a modern processor</a>. If you&#39;re interested in scheduling, read <a href="http://jlouisramblings.blogspot.com/2013/01/how-Erlang-does-scheduling.html">how Erlang does scheduling</a>.</p>
<h4>Message passing</h4>
<p>Erlang use message passing for inter process communication, which inherits the idea of Actor model. Each process has its own mailbox to hold messages that cannot be processed immediately.</p>
<p>With built-in process and message passing between processes, Erlang made itself full asynchronous.</p>
<h4>Example</h4>
<pre><code>-module(echo_server).
-export([rpc/2, loop/0]).

rpc(Pid, Request) -&gt;
    Pid ! {self(), Request},
    receive
        Response -&gt;
            Response
    end.

loop() -&gt;
    receive
        {From, {message, Message}} -&gt;
            From ! {ok, Message},
            loop();
        {From, Request} -&gt;
            From ! {error, Request},
            loop()
    end.

%% in shell:

1&gt; c(echo_server).
{ok,echo_server}
2&gt;  Pid = spawn(fun echo_server:loop/0).
&lt;0.42.0&gt;
3&gt; echo_server:rpc(Pid, {message, &quot;Hello world!&quot;}).
{ok,&quot;Hello world!&quot;}
4&gt; echo_server:rpc(Pid, {message1, &quot;Hello world!&quot;}).
{error,{message1,&quot;Hello world!&quot;}}</code></pre>
<p>Hope you&#39;re not overwhelmed by the grammar and the details on functional programming. I&#39;m not going to go into details of this code - it basically create a echo server then send message to the echo server. By using <code>spawn</code>, <code>!</code> (keyword for message passing) and <code>receive</code> we created echo server with only several lines of code. Think about how you achieve this by using C, Java, Python, Ruby or node.js. You will find the beauty of Erlang.</p>
<p>As actor model is so important to the concurrent world, modern languages like Golang support it in the language level as well. I&#39;m not familiar with Golang, but as it does allow you share memory, doing concurrent in Golang may still need synchronous primitives. Furthermore, I don&#39;t think Golang support software real-time since this is the goal of Erlang but not the goal for Golang.</p>
<p>For other languages, such as Java, Python and Ruby, who supports Actor model in the form of the library, I doubt its efficiency. Only putting coroutine and it&#39;s scheduler in the VM level, you can get the maximum performance.</p>
<h3>Scale out</h3>
<p>From previous example we can see that you&#39;re more likely to write loosely coupled applications in Erlang. With the built-in concurrency support, Erlang application is fairly easy to scale out. You can distribute your code from one node to multiple nodes, to different machines in same LAN, or even to servers in the other side of Internet, with only a little extra coding cost. This is because:</p>
<ol>
<li>Erlang allows you to spawn process in a remote node.</li>
<li>Erlang allows you to interact with remote process, just like what you do for local process.</li>
</ol>
<p>With a little change of previous program (added a new function), we can distribute it in two different Erlang nodes:</p>
<pre><code>start() -&gt; register(?MODULE, spawn(fun loop/0)).</code></pre>
<pre><code>➜  Erlang-programming-examples  erl -sname weasley
Erlang R16B (erts-5.10.1) [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V5.10.1  (abort with ^G)
(weasley@cnrd-tchen-mbp)1&gt; c(echo_server).
{ok,echo_server}
(weasley@cnrd-tchen-mbp)2&gt; echo_server:start().
true

➜  Erlang-programming-examples  erl -sname potter
Erlang R16B (erts-5.10.1) [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V5.10.1  (abort with ^G)
(potter@cnrd-tchen-mbp)1&gt; rpc:call(&#39;weasley@cnrd-tchen-mbp&#39;, echo_server, rpc, [{message, &quot;Hurry up, Harry!&quot;}]).
{ok,&quot;Hurry up, Harry!&quot;}</code></pre>
<h3>Hot code reload</h3>
<p>This is really a dream feature every system programmer wants. Think about all kinds of tedious hot patching solutions you provided to your customer. It&#39;s about hacking, dirtiness and limitations. But Erlang, on the contrary, supports hot code reload in an elegant manner.</p>
<p>Still use the echo server as an example, let&#39;s revise the code so that we could swap the code later:</p>
<pre><code>-module(echo_server_general).
-export([start/2, rpc/2, swap_code/2]).

start(Name, Mod) -&gt;
    register(Name, spawn(fun() -&gt; loop(Name, Mod) end)).

swap_code(Name, Mod) -&gt;
    rpc(Name, {swap_code, Mod}).

rpc(Name, Request) -&gt;
    Name ! {self(), Request},
    receive
        {Name, Response} -&gt; Response
    end.

loop(Name, Mod) -&gt;
    receive
        {From, {swap_code, NewMod}} -&gt;
            From ! {Name, ack},
            loop(Name, NewMod);
        {From, Request} -&gt;
            Response  = Mod:handle(Request),
            From ! {Name, Response},
            loop(Name, Mod)
    end.

-module(echo_server).
-export([echo/2, handle/1]).

echo(Name, Message) -&gt; echo_server_general:rpc(Name, {echo, Message}).

handle({echo, Message}) -&gt; {ok, Message}.

%% shell output

(weasley@cnrd-tchen-mbp)1&gt; echo_server_general:start(s, echo_server).
true
(weasley@cnrd-tchen-mbp)2&gt; echo_server:echo(s, &quot;hello world&quot;).
{ok,&quot;hello world&quot;}</code></pre>
<p>Now the new requirement comes - our echo_server need to capitalize the first letter of the message and echo it back. Normally we need to shutdown the server, replace it with the new code, then restart the server again. You don&#39;t need to do so in Erlang.</p>
<pre><code>%% revised echo_server.erl
-module(echo_server).
-export([echo/2, handle/1]).

echo(Name, Message) -&gt; echo_server_general:rpc(Name, {echo, Message}).

handle({echo, Message}) -&gt; {ok, capfirst(Message)}.

capfirst([H|T]) when H &gt;= $a, H =&lt; $z -&gt;
    [H + ($A - $a)|T];
capfirst(Others) -&gt; Others.

%% shell output
(weasley@cnrd-tchen-mbp)4&gt; c(echo_server).
{ok,echo_server}
(weasley@cnrd-tchen-mbp)5&gt; echo_server_general:swap_code(s, echo_server).
ack
(weasley@cnrd-tchen-mbp)6&gt; echo_server:echo(s, &quot;hello world&quot;).
{ok,&quot;Hello world&quot;}</code></pre>
<p>Hot code reload is greatly useful not only for high availability of running software, but also very useful for software development life cycle. You don&#39;t need to waste lots of time to shutdown, load, and boot a big system for verifying a few lines of change.</p>
<p>I read several articles which claim hot code reload is not so useful in real world. People fears about the chaos of module versions of the hot reloaded software. Understandable. People tend to fear about unknown, and things that beyond their knowledge and vision. The power of the hot code reload will be discovered a decade later, when there&#39;s corresponding software management tools and theory appears. Erlang is too ahead its time that after more than 20 years its philosophy is still ahead of time.</p>
<h3>Fault Tolerance</h3>
<p>The industry dreams on nine nines (99.9999999%) of system availability. However, software is made by people. People will make mistakes. Murphy&#39;s law says anything can go wrong will go wrong. So we can not avoid mistakes. Instead of getting us out of mistakes, a more important question is: how could our software survive with all kinds of mistakes?</p>
<p>Other languages train people to use defensive programming to try to protect your software from crash, but Erlang&#39;s philosophy is &quot;let it crash&quot;. Why?</p>
<p>If someone built a house for you that as long as one of the window breaks the house will fall completely, will you stay in the house? Absolutely no. You need a house that you can still live in it though window is broken. You can later ask expert to fix it.</p>
<p>This is the difference between applications written in C and in Erlang. Crash is not a serious problem if you know how to recover from the crash. In Erlang: </p>
<ul>
<li>a process crashing will not impact unrelated processes.</li>
<li>crashed process will notify the processes linked to it.</li>
<li>supervisor could be used to recover from the crash, e.g. restart the crashed process.</li>
</ul>
<h3>Speed</h3>
<p>the performance of Erlang code has some drawbacks compared with C:</p>
<ul>
<li>the code runs on top of VM</li>
<li>runtime type deduction</li>
<li>pattern matching</li>
<li>...</li>
</ul>
<p>So how slow is Erlang? Inspired by this <a href="http://stackoverflow.com/questions/6964392/speed-comparison-with-project-euler-c-vs-python-vs-Erlang-vs-haskell">post</a>, I did the following tests in my mbp:</p>
<pre><code>➜  comparison  time ./euler12.bin
842161320
./euler12.bin  5.90s user 0.01s system 99% cpu 5.910 total
➜  comparison  time erl -noshell -s euler12 solve
842161320
erl -noshell -s euler12 solve  11.09s user 0.19s system 100% cpu 11.269 total
➜  comparison  time pypy euler12.py
842161320
pypy euler12.py  9.92s user 0.05s system 96% cpu 10.305 total
➜  comparison  time ./euler12.py
842161320
./euler12.py  66.32s user 0.04s system 99% cpu 1:06.43 total</code></pre>
<p>We can see that C code is almost 2x faster than Erlang. This is not bad for Erlang, considering the benefits it brings. Think about a I/O intensive situation. Think about concurrent or distributed situation. Erlang wins for sure.</p>
<p>Sooner or later one DIE will have a thousand cores. Even if nowadays Erlang cannot excel in performance, it will in future.</p>
<h3>Adoption</h3>
<p>There are quite a few famous software built with Erlang:</p>
<ul>
<li><a href="http://couchdb.apache.org/">couchDB</a>. A NoSQL database. </li>
<li><a href="http://www.rabbitmq.com/">RabbitMQ</a>. A distributed message queue system.</li>
<li><a href="http://www.ejabberd.im/">ejabberd</a>. An instant message server.</li>
<li><a href="http://www.adelcogroup.com/EricssonAXD301.htm">AXD301 ATM switch</a>. Probably the only system in this planet reached nine nines. It hasn&#39;t been shutdown for 20 years.</li>
<li>And a lot more companies, including Amazon, Facebook, Yahoo!, T-Mobile, use Erlang in their systems, see <a href="http://stackoverflow.com/questions/1636455/where-is-Erlang-used-and-why">Where is Erlang used and why?</a></li>
</ul>
<h2>How to learn Erlang?</h2>
<p>Erlang is really difficult to learn. But once you mastered it, you&#39;re the king. I like the words from Evan Miller, the creator of Erlang Web MVC framwork <a href="http://www.chicagoboss.org/">Chicago Boss</a>, in a good article named <a href="http://www.evanmiller.org/joy-of-erlang.html">Joy of erlang</a>:</p>
<blockquote>
<p>In the movie Avatar, there&#39;s this big badass bird-brained pterodactyl thing called a Toruk that the main character must learn to ride in order to regain the trust of the blue people. As a general rule, Toruks do not like to be ridden, but if you fight one, subdue it, and then link your Blue Man ponytail to the Toruk&#39;s ptero-tail, you get to own the thing for life. Owning a Toruk is awesome; it&#39;s like owning a flying car you can control with your mind, which comes in handy when battling large chemical companies, impressing future colleagues, or delivering a pizza. But learning to ride a Toruk is dangerous, and very few people succeed.</p>
</blockquote>
<p><img src="/assets/files/snapshots/toruk.jpg" alt="toruk"></p>
<p>It reflects perfectly how hard I learned Erlang. BTW, I&#39;ve far from conquering it. </p>
<p>Before learning Erlang, I have good master of C, Python and Javascript, programmed a little bit on C++, Java and Ruby. You can see my brain is filled with <a href="http://en.wikipedia.org/wiki/Imperative_programming">Imperative programming</a>. So the biggest challenges for me is to get used to functional programming, which implies <strong>mind change</strong>.</p>
<h3>No state change for variables</h3>
<p>Variables can only be bound to but not changed. Suddenly I found I could not program.</p>
<p>For example, to implement upper(str) without using any helper function, such as map().</p>
<p>In Python, it&#39;s super easy and pretty straight forward:</p>
<pre><code>def upper(str):
    str1 = &#39;&#39;
    for c in str:
        str1 += c.upper()
    return str1</code></pre>
<p>But in erlang, without changing the internal state, how can I achieve it?</p>
<p>The ingredient is accumulator. Bear this paradigm in mind when writing Erlang code. The code looks like this:</p>
<pre><code>upper(S) -&gt;
    upper(S, []).

upper([], N) -&gt;
    lists:reverse(N);
upper([H|T], N) when H &gt; $a, H =&lt; $z -&gt;
    upper(T, [H + ($A - $a)|N]);
upper([H|T], N) -&gt;
    upper(T, [H|N]).</code></pre>
<p>The function itself doesn&#39;t have any internal state change, but we have achieved the same goal by having an accumulator passed as a parameter. This is a fundamental paradigm in functional programming world. <strong>Master it or die</strong>.</p>
<h3>Pattern matching</h3>
<p>Pattern matching makes Erlang program beautiful and easy to understand. In C, a function is unique inside its scope. You cannot define a <code>fun(x)</code> firstly, then define <code>fun(x, y)</code> later. But in Erlang, there&#39;s no such limitation. You could define as many as functions as long as their parameters are different, you could also define as many as <a href="http://www.erlang.org/doc/reference_manual/functions.html">clauses</a> for a function as long as their patterns are different. Take the above <code>upper()</code> function as an example. You call <code>upper(&quot;#hello&quot;)</code>:</p>
<ul>
<li>as there&#39;s only one parameter, the call matches with <code>upper(S)</code>, so we call <code>upper(&quot;#hello&quot;, [])</code>.</li>
<li>For <code>upper(&quot;#hello&quot;, [])</code>, as &quot;#hello&quot; cannot match [], and the first char &quot;#&quot; doesn&#39;t match with the guard condition, the call matched <code>upper([H|T], N)</code>, so it calls <code>upper(&quot;hello&quot;, [$#])</code>.</li>
<li>The following calls all matched with <code>upper([H|T], N) when H &gt; $a, H =&lt; $z</code>, and it will change the char to uppercase. So the call sequence is:<pre><code>upper(&quot;ello&quot;, [$H, $#])
upper(&quot;llo&quot;, [$E, $H, $#])
upper(&quot;lo&quot;, [$L, $E, $H, $#])
upper(&quot;o&quot;, [$L, $L, $E, $H, $#])
upper([], [$O, $L, $L, $E, $H, $#])</code></pre>
</li>
<li>for <code>upper([], [$O, $L, $L, $E, $H, $#])</code>, it matches <code>upper([], N)</code>, <code>lists:reverse(N)</code> is returned.</li>
</ul>
<p>Pattern matching allows you to break your code logic into pieces, as a result, the body of each clause of a function is much smaller and more readable. That&#39;s why usually you see a C function is more than a hundred lines of code but an Erlang function clause usually takes no more than twenty lines of code.</p>
<p>Note that the sequence of the clauses are important. Erlang executes the first matched clause.</p>
<h3>The magic of recursive</h3>
<p>When studying C programming, I was trained that recursion is a poison that you should use as little as possible. But in functional programming world, recursion is another fundamental paradigm.</p>
<p>Look back into the code I&#39;ve written in this article so far. Do you see regular loop? No. But how about recursive function? Everywhere. Recursion replaces for/while loop, making a clean iteration or looping solution. Why? Think about the for loop in C. It involves with state change - for every step you change the iterating factor until it match the exiting criteria. But Erlang doesn&#39;t allow internal state change, so it uses recursion to replace normal for/while loop.</p>
<p>But you have doubts.</p>
<h4>The performance of recursion is poor</h4>
<p>This is a pseudo-proposition. </p>
<p>Let me give you an example. The common sense is that passing parameters by registers is much faster than by stack. Intel CPU relies on stack push/pop so much for function calls since it has fewer general purpose registers than RISC CPUs. To boost performance it introduces the register stack so that push/pop operation is lightening-y fast - as fast as using registers.</p>
<p>Let&#39;s come back to recursion. We use little recursion in C, according to 80/20 principle, there&#39;s no immediate need to optimize it, right? But for Erlang, recursion is the lifeline of the code. How dare the compiler not to optimize it? So your intuition is wrong - recursion is not necessarily slow. Yes it is slow in C, but very fast in Erlang. </p>
<h4>It usually leads to stack overflow</h4>
<p>Not exactly if you program in a right way. Erlang optimize the stack specially for <a href="https://en.wikipedia.org/wiki/Tail_call">tail recursion</a>. Let me give you an example:</p>
<pre><code>fac(1) -&gt; 1;
fac(N) when N &gt; 0 -&gt; N * fac(N-1).</code></pre>
<p>This is not a tail recursion since the stack must be kept for calculation.</p>
<p>Let&#39;s make it a tail recursion one:</p>
<pre><code>fac1(N) -&gt; fac1(N, 1).

fac1(1, M) -&gt; M;
fac1(N, M) when N &gt; 0 -&gt; fac1(N-1, N * M).</code></pre>
<p>Each time a function call is made we can safely drop the stack of the last call, this is tail recursion.</p>
<p>The benefit of tail recursion is that you need only to keep a very small, constant memory footprint for recursion. So there&#39;s no worry about stack overflow for long running recursive programs.</p>
<p>In Erlang, you should program the code with tail recursion as long as it is possible.</p>
<h3>Functional programming in mind</h3>
<p>Pay attention to the data that could be recursively accessed, such as list (including string). List could be processed like this:</p>
<pre><code>retrieve([H|T]) -&gt; {H, T}.

%% or even
retrieve1([H1, H2|T]) -&gt; {H1, H2, T}</code></pre>
<p>Bear map/reduce in mind.</p>
<p>Focus on algorithm, think how you achieve it with math formula. Then it should be easy to write it down with Erlang. Divide and conquer your problem. Do not get into details.</p>
<p>Let&#39;s take atoi(S) as an example.</p>
<p>The formula:</p>
<pre><code>
         |- S[0] is &#39;-&#39;:  -1 * atoi(s[1:], 0)
atoi(S) -+
         |- else:         atoi(S, 0)

              |- S is []:       Acc
atoi(S, Acc) -+- S[X] is digit: atoi(S[X+1:], 10 * Acc + digit(S))
              |- else:          Acc</code></pre>
<p>Thus we could write code like this:</p>
<pre><code>-module(math).
-export([atoi/1]).

atoi([$-|S]) -&gt;
    -1 * atoi(S, 0);
atoi(S) -&gt;
    atoi(S, 0).

atoi([], Acc) -&gt; Acc;
atoi([H|T], Acc) when H &gt;= $0, H =&lt; $9 -&gt;
    atoi(T, 10 * Acc + (H - $0));
atoi(_S, Acc) -&gt; Acc.</code></pre>
<p>Think of how you write C code for <code>atoi()</code>. The Erlang program is close to what your algorithm is. You can make it correct almost on your first try.</p>
<h3>Embrace processes</h3>
<p>Process is not hard to use if you&#39;re willing to use it. It helps organize your system in a loosely coupled and asynchronous way. You just need to get used to it. Treat process as worker, as object, or anything you could analog.</p>
<h3>Let it fail</h3>
<p>For C programmer, normally you should write code that covers every possible value of the parameters. But Erlang not. Take this example:</p>
<pre><code>%% good code
fac(N) when is_integer(N), N &gt; 0 -&gt; fac(N, 1).

fac(1, Acc) -&gt; Acc;
fac(N, Acc) -&gt; fac(N-1, Acc * N).

%% bad code
fac(N) when is_integer(N), N &gt; 0 -&gt; fac(N, 1).
fac(N)                           -&gt; {error, &quot;argument must be positive integer&quot;}

fac(1, Acc) -&gt; Acc;
fac(N, Acc) -&gt; fac(N-1, Acc * N).</code></pre>
<p>Execute the good code with bad parameter will cause exception, like the following:</p>
<pre><code>1&gt; c(math).
{ok,math}
2&gt; math:fac(10).
3628800
3&gt; math:fac(-10).
** exception error: no function clause matching math:fac(-10) (math.erl, line 14)</code></pre>
<p>Should we write code to process the negative integer? YES in C, NO in Erlang. The bade code saves the process from exception but it leads unnecessary handling for the caller. Caller needs to add extra code to handle this pointless return value, which only makes the system more complicated. Let the exception happen. Let the process crash. Handle exception only in the place that need to handle it.</p>
<h2>Materials to learn Erlang</h2>
<p>Congratulations! After reading this long article now it&#39;s your turn to conquer your Toruk. Here&#39;s your weapon:</p>
<ol>
<li><strong>Joe Armstrong</strong>&#39;s book <strong>&quot;Programming Erlang - software for a concurrent world&quot;</strong>. The best way to learn a language is to read the book of the language&#39;s father. I highly recommend you to read this book thoroughly, especially the chapters regarding with sequential programming, concurrent programming and OTP.</li>
<li><a href="http://www.erlang.org/doc/">Erlang doc</a>. Read on when you have doubts.</li>
<li>Implement in Erlang for the problems you&#39;re facing in day-to-day work. For example:<ul>
<li>Count the words for a given file.</li>
<li>Implement cloc (giving a directory, count the lines of code for different languages).</li>
<li>Write a message server that keeps top N unread messages in memory while keeping the rest in mnesia.</li>
<li>Write a markdown interpreter.</li>
<li>Write a web framework based on mochiweb.</li>
<li>Write a L3/L4 firewall that handles symmetric NAT translation (to focus on the problem itself you should use the data from tcpdump).</li>
</ul>
</li>
<li>Read open source software, such as ranch, cowboy, boss_db, etc.</li>
</ol>
<p>Hope you have fun!</p>
]]></description>
            <link>http://tchen.me/posts/2013-07-22-why-should-c-programmers-learn-erlang.html</link>
            <guid isPermaLink="true">
                http://tchen.me/posts/2013-07-22-why-should-c-programmers-learn-erlang.html            </guid>
            <dc:creator><![CDATA[Tyr Chen]]></dc:creator>
            <pubDate>Tue, 23 Jul 2013 01:32:00 GMT</pubDate>
        </item>
    </channel>
</rss>